<!doctype html>
<html>
<head>
<meta charset='UTF-8'><meta name='viewport' content='width=device-width initial-scale=1'>
<title>玩转Java并发编程</title><link href='https://fonts.loli.net/css?family=Open+Sans:400italic,700italic,700,400&subset=latin,latin-ext' rel='stylesheet' type='text/css' /><style type='text/css'>html {overflow-x: initial !important;}:root { --bg-color:#ffffff; --text-color:#333333; --select-text-bg-color:#B5D6FC; --select-text-font-color:auto; --monospace:"Lucida Console",Consolas,"Courier",monospace; }
html { font-size: 14px; background-color: var(--bg-color); color: var(--text-color); font-family: "Helvetica Neue", Helvetica, Arial, sans-serif; -webkit-font-smoothing: antialiased; }
body { margin: 0px; padding: 0px; height: auto; bottom: 0px; top: 0px; left: 0px; right: 0px; font-size: 1rem; line-height: 1.42857; overflow-x: hidden; background: inherit; tab-size: 4; }
iframe { margin: auto; }
a.url { word-break: break-all; }
a:active, a:hover { outline: 0px; }
.in-text-selection, ::selection { text-shadow: none; background: var(--select-text-bg-color); color: var(--select-text-font-color); }
#write { margin: 0px auto; height: auto; width: inherit; word-break: normal; overflow-wrap: break-word; position: relative; white-space: normal; overflow-x: visible; padding-top: 40px; }
#write.first-line-indent p { text-indent: 2em; }
#write.first-line-indent li p, #write.first-line-indent p * { text-indent: 0px; }
#write.first-line-indent li { margin-left: 2em; }
.for-image #write { padding-left: 8px; padding-right: 8px; }
body.typora-export { padding-left: 30px; padding-right: 30px; }
.typora-export .footnote-line, .typora-export li, .typora-export p { white-space: pre-wrap; }
@media screen and (max-width: 500px) {
  body.typora-export { padding-left: 0px; padding-right: 0px; }
  #write { padding-left: 20px; padding-right: 20px; }
  .CodeMirror-sizer { margin-left: 0px !important; }
  .CodeMirror-gutters { display: none !important; }
}
#write li > figure:last-child { margin-bottom: 0.5rem; }
#write ol, #write ul { position: relative; }
img { max-width: 100%; vertical-align: middle; }
button, input, select, textarea { color: inherit; font: inherit; }
input[type="checkbox"], input[type="radio"] { line-height: normal; padding: 0px; }
*, ::after, ::before { box-sizing: border-box; }
#write h1, #write h2, #write h3, #write h4, #write h5, #write h6, #write p, #write pre { width: inherit; }
#write h1, #write h2, #write h3, #write h4, #write h5, #write h6, #write p { position: relative; }
p { line-height: inherit; }
h1, h2, h3, h4, h5, h6 { break-after: avoid-page; break-inside: avoid; orphans: 2; }
p { orphans: 4; }
h1 { font-size: 2rem; }
h2 { font-size: 1.8rem; }
h3 { font-size: 1.6rem; }
h4 { font-size: 1.4rem; }
h5 { font-size: 1.2rem; }
h6 { font-size: 1rem; }
.md-math-block, .md-rawblock, h1, h2, h3, h4, h5, h6, p { margin-top: 1rem; margin-bottom: 1rem; }
.hidden { display: none; }
.md-blockmeta { color: rgb(204, 204, 204); font-weight: 700; font-style: italic; }
a { cursor: pointer; }
sup.md-footnote { padding: 2px 4px; background-color: rgba(238, 238, 238, 0.7); color: rgb(85, 85, 85); border-radius: 4px; cursor: pointer; }
sup.md-footnote a, sup.md-footnote a:hover { color: inherit; text-transform: inherit; text-decoration: inherit; }
#write input[type="checkbox"] { cursor: pointer; width: inherit; height: inherit; }
figure { overflow-x: auto; margin: 1.2em 0px; max-width: calc(100% + 16px); padding: 0px; }
figure > table { margin: 0px !important; }
tr { break-inside: avoid; break-after: auto; }
thead { display: table-header-group; }
table { border-collapse: collapse; border-spacing: 0px; width: 100%; overflow: auto; break-inside: auto; text-align: left; }
table.md-table td { min-width: 32px; }
.CodeMirror-gutters { border-right: 0px; background-color: inherit; }
.CodeMirror-linenumber { user-select: none; }
.CodeMirror { text-align: left; }
.CodeMirror-placeholder { opacity: 0.3; }
.CodeMirror pre { padding: 0px 4px; }
.CodeMirror-lines { padding: 0px; }
div.hr:focus { cursor: none; }
#write pre { white-space: pre-wrap; }
#write.fences-no-line-wrapping pre { white-space: pre; }
#write pre.ty-contain-cm { white-space: normal; }
.CodeMirror-gutters { margin-right: 4px; }
.md-fences { font-size: 0.9rem; display: block; break-inside: avoid; text-align: left; overflow: visible; white-space: pre; background: inherit; position: relative !important; }
.md-diagram-panel { width: 100%; margin-top: 10px; text-align: center; padding-top: 0px; padding-bottom: 8px; overflow-x: auto; }
#write .md-fences.mock-cm { white-space: pre-wrap; }
.md-fences.md-fences-with-lineno { padding-left: 0px; }
#write.fences-no-line-wrapping .md-fences.mock-cm { white-space: pre; overflow-x: auto; }
.md-fences.mock-cm.md-fences-with-lineno { padding-left: 8px; }
.CodeMirror-line, twitterwidget { break-inside: avoid; }
.footnotes { opacity: 0.8; font-size: 0.9rem; margin-top: 1em; margin-bottom: 1em; }
.footnotes + .footnotes { margin-top: 0px; }
.md-reset { margin: 0px; padding: 0px; border: 0px; outline: 0px; vertical-align: top; background: 0px 0px; text-decoration: none; text-shadow: none; float: none; position: static; width: auto; height: auto; white-space: nowrap; cursor: inherit; -webkit-tap-highlight-color: transparent; line-height: normal; font-weight: 400; text-align: left; box-sizing: content-box; direction: ltr; }
li div { padding-top: 0px; }
blockquote { margin: 1rem 0px; }
li .mathjax-block, li p { margin: 0.5rem 0px; }
li { margin: 0px; position: relative; }
blockquote > :last-child { margin-bottom: 0px; }
blockquote > :first-child, li > :first-child { margin-top: 0px; }
.footnotes-area { color: rgb(136, 136, 136); margin-top: 0.714rem; padding-bottom: 0.143rem; white-space: normal; }
#write .footnote-line { white-space: pre-wrap; }
@media print {
  body, html { border: 1px solid transparent; height: 99%; break-after: avoid; break-before: avoid; }
  #write { margin-top: 0px; padding-top: 0px; border-color: transparent !important; }
  .typora-export * { -webkit-print-color-adjust: exact; }
  html.blink-to-pdf { font-size: 13px; }
  .typora-export #write { padding-left: 32px; padding-right: 32px; padding-bottom: 0px; break-after: avoid; }
  .typora-export #write::after { height: 0px; }
}
.footnote-line { margin-top: 0.714em; font-size: 0.7em; }
a img, img a { cursor: pointer; }
pre.md-meta-block { font-size: 0.8rem; min-height: 0.8rem; white-space: pre-wrap; background: rgb(204, 204, 204); display: block; overflow-x: hidden; }
p > .md-image:only-child:not(.md-img-error) img, p > img:only-child { display: block; margin: auto; }
p > .md-image:only-child { display: inline-block; width: 100%; }
#write .MathJax_Display { margin: 0.8em 0px 0px; }
.md-math-block { width: 100%; }
.md-math-block:not(:empty)::after { display: none; }
[contenteditable="true"]:active, [contenteditable="true"]:focus { outline: 0px; box-shadow: none; }
.md-task-list-item { position: relative; list-style-type: none; }
.task-list-item.md-task-list-item { padding-left: 0px; }
.md-task-list-item > input { position: absolute; top: 0px; left: 0px; margin-left: -1.2em; margin-top: calc(1em - 10px); border: none; }
.math { font-size: 1rem; }
.md-toc { min-height: 3.58rem; position: relative; font-size: 0.9rem; border-radius: 10px; }
.md-toc-content { position: relative; margin-left: 0px; }
.md-toc-content::after, .md-toc::after { display: none; }
.md-toc-item { display: block; color: rgb(65, 131, 196); }
.md-toc-item a { text-decoration: none; }
.md-toc-inner:hover { text-decoration: underline; }
.md-toc-inner { display: inline-block; cursor: pointer; }
.md-toc-h1 .md-toc-inner { margin-left: 0px; font-weight: 700; }
.md-toc-h2 .md-toc-inner { margin-left: 2em; }
.md-toc-h3 .md-toc-inner { margin-left: 4em; }
.md-toc-h4 .md-toc-inner { margin-left: 6em; }
.md-toc-h5 .md-toc-inner { margin-left: 8em; }
.md-toc-h6 .md-toc-inner { margin-left: 10em; }
@media screen and (max-width: 48em) {
  .md-toc-h3 .md-toc-inner { margin-left: 3.5em; }
  .md-toc-h4 .md-toc-inner { margin-left: 5em; }
  .md-toc-h5 .md-toc-inner { margin-left: 6.5em; }
  .md-toc-h6 .md-toc-inner { margin-left: 8em; }
}
a.md-toc-inner { font-size: inherit; font-style: inherit; font-weight: inherit; line-height: inherit; }
.footnote-line a:not(.reversefootnote) { color: inherit; }
.md-attr { display: none; }
.md-fn-count::after { content: "."; }
code, pre, samp, tt { font-family: var(--monospace); }
kbd { margin: 0px 0.1em; padding: 0.1em 0.6em; font-size: 0.8em; color: rgb(36, 39, 41); background: rgb(255, 255, 255); border: 1px solid rgb(173, 179, 185); border-radius: 3px; box-shadow: rgba(12, 13, 14, 0.2) 0px 1px 0px, rgb(255, 255, 255) 0px 0px 0px 2px inset; white-space: nowrap; vertical-align: middle; }
.md-comment { color: rgb(162, 127, 3); opacity: 0.8; font-family: var(--monospace); }
code { text-align: left; vertical-align: initial; }
a.md-print-anchor { white-space: pre !important; border-width: initial !important; border-style: none !important; border-color: initial !important; display: inline-block !important; position: absolute !important; width: 1px !important; right: 0px !important; outline: 0px !important; background: 0px 0px !important; text-decoration: initial !important; text-shadow: initial !important; }
.md-inline-math .MathJax_SVG .noError { display: none !important; }
.html-for-mac .inline-math-svg .MathJax_SVG { vertical-align: 0.2px; }
.md-math-block .MathJax_SVG_Display { text-align: center; margin: 0px; position: relative; text-indent: 0px; max-width: none; max-height: none; min-height: 0px; min-width: 100%; width: auto; overflow-y: hidden; display: block !important; }
.MathJax_SVG_Display, .md-inline-math .MathJax_SVG_Display { width: auto; margin: inherit; display: inline-block !important; }
.MathJax_SVG .MJX-monospace { font-family: var(--monospace); }
.MathJax_SVG .MJX-sans-serif { font-family: sans-serif; }
.MathJax_SVG { display: inline; font-style: normal; font-weight: 400; line-height: normal; zoom: 90%; text-indent: 0px; text-align: left; text-transform: none; letter-spacing: normal; word-spacing: normal; overflow-wrap: normal; white-space: nowrap; float: none; direction: ltr; max-width: none; max-height: none; min-width: 0px; min-height: 0px; border: 0px; padding: 0px; margin: 0px; }
.MathJax_SVG * { transition: none 0s ease 0s; }
.MathJax_SVG_Display svg { vertical-align: middle !important; margin-bottom: 0px !important; margin-top: 0px !important; }
.os-windows.monocolor-emoji .md-emoji { font-family: "Segoe UI Symbol", sans-serif; }
.md-diagram-panel > svg { max-width: 100%; }
[lang="mermaid"] svg, [lang="flow"] svg { max-width: 100%; height: auto; }
[lang="mermaid"] .node text { font-size: 1rem; }
table tr th { border-bottom: 0px; }
video { max-width: 100%; display: block; margin: 0px auto; }
iframe { max-width: 100%; width: 100%; border: none; }
.highlight td, .highlight tr { border: 0px; }
svg[id^="mermaidChart"] { line-height: 1em; }
mark { background: rgb(255, 255, 0); color: rgb(0, 0, 0); }
.md-html-inline .md-plain, .md-html-inline strong, mark .md-inline-math, mark strong { color: inherit; }
mark .md-meta { color: rgb(0, 0, 0); opacity: 0.3 !important; }


.CodeMirror { height: auto; }
.CodeMirror.cm-s-inner { background: inherit; }
.CodeMirror-scroll { overflow: auto hidden; z-index: 3; }
.CodeMirror-gutter-filler, .CodeMirror-scrollbar-filler { background-color: rgb(255, 255, 255); }
.CodeMirror-gutters { border-right: 1px solid rgb(221, 221, 221); background: inherit; white-space: nowrap; }
.CodeMirror-linenumber { padding: 0px 3px 0px 5px; text-align: right; color: rgb(153, 153, 153); }
.cm-s-inner .cm-keyword { color: rgb(119, 0, 136); }
.cm-s-inner .cm-atom, .cm-s-inner.cm-atom { color: rgb(34, 17, 153); }
.cm-s-inner .cm-number { color: rgb(17, 102, 68); }
.cm-s-inner .cm-def { color: rgb(0, 0, 255); }
.cm-s-inner .cm-variable { color: rgb(0, 0, 0); }
.cm-s-inner .cm-variable-2 { color: rgb(0, 85, 170); }
.cm-s-inner .cm-variable-3 { color: rgb(0, 136, 85); }
.cm-s-inner .cm-string { color: rgb(170, 17, 17); }
.cm-s-inner .cm-property { color: rgb(0, 0, 0); }
.cm-s-inner .cm-operator { color: rgb(152, 26, 26); }
.cm-s-inner .cm-comment, .cm-s-inner.cm-comment { color: rgb(170, 85, 0); }
.cm-s-inner .cm-string-2 { color: rgb(255, 85, 0); }
.cm-s-inner .cm-meta { color: rgb(85, 85, 85); }
.cm-s-inner .cm-qualifier { color: rgb(85, 85, 85); }
.cm-s-inner .cm-builtin { color: rgb(51, 0, 170); }
.cm-s-inner .cm-bracket { color: rgb(153, 153, 119); }
.cm-s-inner .cm-tag { color: rgb(17, 119, 0); }
.cm-s-inner .cm-attribute { color: rgb(0, 0, 204); }
.cm-s-inner .cm-header, .cm-s-inner.cm-header { color: rgb(0, 0, 255); }
.cm-s-inner .cm-quote, .cm-s-inner.cm-quote { color: rgb(0, 153, 0); }
.cm-s-inner .cm-hr, .cm-s-inner.cm-hr { color: rgb(153, 153, 153); }
.cm-s-inner .cm-link, .cm-s-inner.cm-link { color: rgb(0, 0, 204); }
.cm-negative { color: rgb(221, 68, 68); }
.cm-positive { color: rgb(34, 153, 34); }
.cm-header, .cm-strong { font-weight: 700; }
.cm-del { text-decoration: line-through; }
.cm-em { font-style: italic; }
.cm-link { text-decoration: underline; }
.cm-error { color: red; }
.cm-invalidchar { color: red; }
.cm-constant { color: rgb(38, 139, 210); }
.cm-defined { color: rgb(181, 137, 0); }
div.CodeMirror span.CodeMirror-matchingbracket { color: rgb(0, 255, 0); }
div.CodeMirror span.CodeMirror-nonmatchingbracket { color: rgb(255, 34, 34); }
.cm-s-inner .CodeMirror-activeline-background { background: inherit; }
.CodeMirror { position: relative; overflow: hidden; }
.CodeMirror-scroll { height: 100%; outline: 0px; position: relative; box-sizing: content-box; background: inherit; }
.CodeMirror-sizer { position: relative; }
.CodeMirror-gutter-filler, .CodeMirror-hscrollbar, .CodeMirror-scrollbar-filler, .CodeMirror-vscrollbar { position: absolute; z-index: 6; display: none; }
.CodeMirror-vscrollbar { right: 0px; top: 0px; overflow: hidden; }
.CodeMirror-hscrollbar { bottom: 0px; left: 0px; overflow: hidden; }
.CodeMirror-scrollbar-filler { right: 0px; bottom: 0px; }
.CodeMirror-gutter-filler { left: 0px; bottom: 0px; }
.CodeMirror-gutters { position: absolute; left: 0px; top: 0px; padding-bottom: 30px; z-index: 3; }
.CodeMirror-gutter { white-space: normal; height: 100%; box-sizing: content-box; padding-bottom: 30px; margin-bottom: -32px; display: inline-block; }
.CodeMirror-gutter-wrapper { position: absolute; z-index: 4; background: 0px 0px !important; border: none !important; }
.CodeMirror-gutter-background { position: absolute; top: 0px; bottom: 0px; z-index: 4; }
.CodeMirror-gutter-elt { position: absolute; cursor: default; z-index: 4; }
.CodeMirror-lines { cursor: text; }
.CodeMirror pre { border-radius: 0px; border-width: 0px; background: 0px 0px; font-family: inherit; font-size: inherit; margin: 0px; white-space: pre; overflow-wrap: normal; color: inherit; z-index: 2; position: relative; overflow: visible; }
.CodeMirror-wrap pre { overflow-wrap: break-word; white-space: pre-wrap; word-break: normal; }
.CodeMirror-code pre { border-right: 30px solid transparent; width: fit-content; }
.CodeMirror-wrap .CodeMirror-code pre { border-right: none; width: auto; }
.CodeMirror-linebackground { position: absolute; left: 0px; right: 0px; top: 0px; bottom: 0px; z-index: 0; }
.CodeMirror-linewidget { position: relative; z-index: 2; overflow: auto; }
.CodeMirror-wrap .CodeMirror-scroll { overflow-x: hidden; }
.CodeMirror-measure { position: absolute; width: 100%; height: 0px; overflow: hidden; visibility: hidden; }
.CodeMirror-measure pre { position: static; }
.CodeMirror div.CodeMirror-cursor { position: absolute; visibility: hidden; border-right: none; width: 0px; }
.CodeMirror div.CodeMirror-cursor { visibility: hidden; }
.CodeMirror-focused div.CodeMirror-cursor { visibility: inherit; }
.cm-searching { background: rgba(255, 255, 0, 0.4); }
@media print {
  .CodeMirror div.CodeMirror-cursor { visibility: hidden; }
}


:root {
    --side-bar-bg-color: #fafafa;
    --control-text-color: #777;
}

@include-when-export url(https://fonts.loli.net/css?family=Open+Sans:400italic,700italic,700,400&subset=latin,latin-ext);

html {
    font-size: 16px;
}

body {
    font-family: "JetBrains Mono","Open Sans","Clear Sans","Helvetica Neue",Helvetica,Arial,sans-serif;
    color: rgb(51, 51, 51);
    line-height: 1.6;
}

#write {
    max-width: 860px;
  	margin: 0 auto;
  	padding: 30px;
    padding-bottom: 100px;
}
#write > ul:first-child,
#write > ol:first-child{
    margin-top: 30px;
}

a {
    color: #4183C4;
}
h1,
h2,
h3,
h4,
h5,
h6 {
    position: relative;
    margin-top: 1rem;
    margin-bottom: 1rem;
    font-weight: bold;
    line-height: 1.4;
    cursor: text;
}
h1:hover a.anchor,
h2:hover a.anchor,
h3:hover a.anchor,
h4:hover a.anchor,
h5:hover a.anchor,
h6:hover a.anchor {
    text-decoration: none;
}
h1 tt,
h1 code {
    font-size: inherit;
}
h2 tt,
h2 code {
    font-size: inherit;
}
h3 tt,
h3 code {
    font-size: inherit;
}
h4 tt,
h4 code {
    font-size: inherit;
}
h5 tt,
h5 code {
    font-size: inherit;
}
h6 tt,
h6 code {
    font-size: inherit;
}
h1 {
    padding-bottom: .3em;
    font-size: 2.25em;
    line-height: 1.2;
    border-bottom: 1px solid #eee;
}
h2 {
   padding-bottom: .3em;
    font-size: 1.75em;
    line-height: 1.225;
    border-bottom: 1px solid #eee;
}
h3 {
    font-size: 1.5em;
    line-height: 1.43;
}
h4 {
    font-size: 1.25em;
}
h5 {
    font-size: 1em;
}
h6 {
   font-size: 1em;
    color: #777;
}
p,
blockquote,
ul,
ol,
dl,
table{
    margin: 0.8em 0;
}
li>ol,
li>ul {
    margin: 0 0;
}
hr {
    height: 2px;
    padding: 0;
    margin: 16px 0;
    background-color: #e7e7e7;
    border: 0 none;
    overflow: hidden;
    box-sizing: content-box;
}

li p.first {
    display: inline-block;
}
ul,
ol {
    padding-left: 30px;
}
ul:first-child,
ol:first-child {
    margin-top: 0;
}
ul:last-child,
ol:last-child {
    margin-bottom: 0;
}
blockquote {
    border-left: 4px solid #dfe2e5;
    padding: 0 15px;
    color: #777777;
}
blockquote blockquote {
    padding-right: 0;
}
table {
    padding: 0;
    word-break: initial;
}
table tr {
    border-top: 1px solid #dfe2e5;
    margin: 0;
    padding: 0;
}
table tr:nth-child(2n),
thead {
    background-color: #f8f8f8;
}
table tr th {
    font-weight: bold;
    border: 1px solid #dfe2e5;
    border-bottom: 0;
    margin: 0;
    padding: 6px 13px;
}
table tr td {
    border: 1px solid #dfe2e5;
    margin: 0;
    padding: 6px 13px;
}
table tr th:first-child,
table tr td:first-child {
    margin-top: 0;
}
table tr th:last-child,
table tr td:last-child {
    margin-bottom: 0;
}

.CodeMirror-lines {
    padding-left: 4px;
}

.code-tooltip {
    box-shadow: 0 1px 1px 0 rgba(0,28,36,.3);
    border-top: 1px solid #eef2f2;
}

.md-fences,
code,
tt {
    border: 1px solid #e7eaed;
    background-color: #f8f8f8;
    border-radius: 3px;
    padding: 0;
    padding: 2px 4px 0px 4px;
    font-size: 0.9em;
}

code {
    background-color: #f3f4f4;
    padding: 0 2px 0 2px;
}

.md-fences {
    margin-bottom: 15px;
    margin-top: 15px;
    padding-top: 8px;
    padding-bottom: 6px;
}


.md-task-list-item > input {
  margin-left: -1.3em;
}

@media print {
    html {
        font-size: 13px;
    }
    table,
    pre {
        page-break-inside: avoid;
    }
    pre {
        word-wrap: break-word;
    }
}

.md-fences {
	background-color: #f8f8f8;
}
#write pre.md-meta-block {
	padding: 1rem;
    font-size: 85%;
    line-height: 1.45;
    background-color: #f7f7f7;
    border: 0;
    border-radius: 3px;
    color: #777777;
    margin-top: 0 !important;
}

.mathjax-block>.code-tooltip {
	bottom: .375rem;
}

.md-mathjax-midline {
    background: #fafafa;
}

#write>h3.md-focus:before{
	left: -1.5625rem;
	top: .375rem;
}
#write>h4.md-focus:before{
	left: -1.5625rem;
	top: .285714286rem;
}
#write>h5.md-focus:before{
	left: -1.5625rem;
	top: .285714286rem;
}
#write>h6.md-focus:before{
	left: -1.5625rem;
	top: .285714286rem;
}
.md-image>.md-meta {
    /*border: 1px solid #ddd;*/
    border-radius: 3px;
    padding: 2px 0px 0px 4px;
    font-size: 0.9em;
    color: inherit;
}

.md-tag {
    color: #a7a7a7;
    opacity: 1;
}

.md-toc { 
    margin-top:20px;
    padding-bottom:20px;
}

.sidebar-tabs {
    border-bottom: none;
}

#typora-quick-open {
    border: 1px solid #ddd;
    background-color: #f8f8f8;
}

#typora-quick-open-item {
    background-color: #FAFAFA;
    border-color: #FEFEFE #e5e5e5 #e5e5e5 #eee;
    border-style: solid;
    border-width: 1px;
}

/** focus mode */
.on-focus-mode blockquote {
    border-left-color: rgba(85, 85, 85, 0.12);
}

header, .context-menu, .megamenu-content, footer{
    font-family: "Segoe UI", "Arial", sans-serif;
}

.file-node-content:hover .file-node-icon,
.file-node-content:hover .file-node-open-state{
    visibility: visible;
}

.mac-seamless-mode #typora-sidebar {
    background-color: #fafafa;
    background-color: var(--side-bar-bg-color);
}

.md-lang {
    color: #b4654d;
}

.html-for-mac .context-menu {
    --item-hover-bg-color: #E6F0FE;
}

#md-notification .btn {
    border: 0;
}

.dropdown-menu .divider {
    border-color: #e5e5e5;
}

.ty-preferences .window-content {
    background-color: #fafafa;
}

.ty-preferences .nav-group-item.active {
    color: white;
    background: #999;
}


</style>
</head>
<body class='typora-export os-windows' >
<div  id='write'  class = 'is-node'><h3><a name="01问题引入多个线程读写同一共享变量是否存在并发问题" class="md-header-anchor"></a><strong><span>01_问题引入：多个线程读写同一共享变量是否存在并发问题？</span></strong></h3><h4><a name="一经典面试题" class="md-header-anchor"></a><span>一、经典面试题 </span></h4><p><span>有没有在JAVA笔试或面试中遇见过这样的题目：统计服务器某个接口的访问次数。</span></p><p><span>这时我们容易大手一挥写出来下面的代码：</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/75200600_1621856049.png" referrerpolicy="no-referrer" alt="img"></p><p><span>这个类中accessCount字段表示接口被访问的次数， 每次访问接口的时候就调用一次access()方法，访问次数+1，累积下来，就能统计出接口被访问的次数了。</span></p><p><span>也许有些小白同学写出这样的方法会沾沾自喜，觉得离收到offer更进了一步，但是有点并发编程经验的同学都能想到这样一种常见的场景，就是接口很可能被多个线程同时访问，即access()方法被多个线程调用。那么问题来了：多线程调用access()方法时，接口访问次数统计的结果是否能保证准确呢？</span></p><p><span>答案显而易见：不能。</span></p><p><span>### </span></p><h4><a name="二内存模型概念" class="md-header-anchor"></a><span>二、内存模型概念</span></h4><p><span>接下来分析一下为什么上面统计的结果会有问题？我们先来简单理解一下内存模型的概念，大家都知道，我们的程序是运行在Java虚拟机上面的，Java虚拟机本身有自己的内存模型， Java的内存模型和计算机的CPU内存模型又有很多相同之处，这里的话，先稍微介绍一下CPU的内存模型。</span></p><p>&nbsp;</p><p><span>计算机在执行程序的时候，每条指令都是在CPU中执行的，而在CPU执行指令的过程中会涉及到数据的读取和写入操作，而在计算机运行过程中所有的数据都是存放在主存中的(比如一台普通的4C8G机器，这个8G就是指主存的容量)，CPU则是从主存中读取数据进行运算。如图1：</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/97603900_1621856049.png" referrerpolicy="no-referrer" alt="img"><span>图1</span></p><p><span>但是，这样会存在一个问题，由于CPU执行速度非常快，比计算机主存的读取和写入的速度快了很多，这样就会导致CPU的执行速度大大下降。</span></p><p><span>因此，每个CPU都会自带一个高速缓冲区，在运行的时候，会将需要运行的数据从计算机主存先复制到CPU的高速缓冲区中，然后CPU再基于高速缓冲区的数据进行运算，运算结束之后，再将高速缓冲区的数据刷新到主存中。这样CPU的执行指令的速度就可以大大提升。如图2：</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/28496200_1621856050.png" referrerpolicy="no-referrer" alt="img"><span>图2</span></p><p><span>### </span></p><h4><a name="三java内存模型" class="md-header-anchor"></a><span>三、Java内存模型</span></h4><p><span>JVM定义的内存模型和上面所说的内存模型有很多相似之处，只是JVM的内存模型屏蔽了不同的操作系统和底层硬件之间的内存访问差异，实现了在各个平台都能达到一致的内存访问效果。Java的内存模型如图3所示：</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/54670400_1621856050.png" referrerpolicy="no-referrer" alt="img"><span>图3</span></p><p><span>JVM启动之后，操作系统会为JVM进程分配一定的内存空间，这部分内存空间就称为“主内存”。</span></p><p><span>另外Java程序的所有工作都由线程来完成，而每个线程都会有一小块内存，称为“工作内存”, Java中的线程在执行的过程中，会先将数据从主内存中复制到线程的工作内存，然后再执行计算，执行计算之后，再把计算结果刷新到“主内存”中。</span></p><p><span>好了，了解了Java的内存模型基本原理之后，我们再来分析一下接口访问计数器为什么统计结果不对。</span></p><p><span>### </span></p><h4><a name="四基于内存模型一步一步分析缓存一致性问题" class="md-header-anchor"></a><span>四、基于内存模型一步一步分析缓存一致性问题</span></h4><p><span>假设现在有两个线程同时访问了这个接口的access()方法，两个线程都执行了accessCount++，在内存中是怎么样执行的呢？</span></p><p><span>首先我们要明白，计算机需要执行accessCount++ 这个语句，需要分为以下3个步骤：</span></p><ol start='' ><li><span>从主存中读取accessCount的值</span></li><li><span>将accessCount的值进行加1</span></li><li><span>将accessCount的值写回主存中</span></li></ol><p><span>先来看看第1步，假设两个线程同时来执行accessCount()方法，如图4：</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/72036100_1621856050.png" referrerpolicy="no-referrer" alt="img"><span>图4</span></p><p><span>上面图4中在第1个步骤的时候，线程1和线程2都会把accessCount的值从主存中复制到线程所属的工作内存中，两个线程此时得到的accessCount的值都是0。</span></p><p><span>接着两个线程执行第2步操作：将accessCount的值进行加1。如图5所示：</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/kpevzdfz07wk.jpg" referrerpolicy="no-referrer" alt="5.jpg"><span>图5</span></p><p><span>图5中，线程1和线程2都进行了第2步的计算，然后线程1得到的结果是 accessCount=1,线程2得到的结果也是accessCount=1。</span></p><p><span>接着两个线程都到了第三步：将accessCount的值写回主存中，如图6所示：</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/kpew031z0reh.jpg" referrerpolicy="no-referrer" alt="6.jpg"><span>图6</span></p><p><span>线程1和线程2都计算完之后就会将计算结果刷新回主存，特别注意一下图中红框的内容，这是两个线程把计算结果刷新回主存的步骤，两个红框中操作的执行顺序不分先后(在实际运行情况，两个操作的顺序是随机的，可能是线程1先刷新，也可能是线程2先刷新)，但是这不影响结果，因为无论是线程1还是线程2，写回主存的结果都是accessCount=1。</span></p><p><span>但是实际上，我们观察到是2个线程都执行了一次access()方法，按照预期来说accessCount的值应该是等于2才对。</span></p><p><span>这种多个线程访问同一个对象时，调用这个对象的方法得到不正确的结果，这种问题称为线程安全问题。</span></p><p><span>通常来说，解决线程安全问题都有一些常见的解决方案，这部分内容会在下一篇文章详细分析，但是在此之前，我们可以思考一下我们这个线程安全问题为什么会产生呢？</span></p><p><span>回顾一下accessCount++这个代码，需要分为3个步骤：</span></p><p><span>1、从主存中读取accessCount的值</span></p><p><span>2、将accessCount的值进行加1</span></p><p><span>3、将accessCount的值写回主存中</span></p><p><span>经过我们前面的分析，思考一下，如何才能让计算结果为accessCount=2呢？</span></p><p><span>很显然，如果线程2能等待线程1把3个步骤都执行完，线程2才开始执行第1个步骤就可以得到正确的答案。也就是说，假如能将这3个步骤看做一个整体，要不全部执行完、要不全部不执行，就能解决问题了。</span></p><p><span>这里需要引申出一个并发中很重要的概念：原子性</span></p><p><span>原子性即一个操作或者多个操作，要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。</span></p><p><span>对应前面的场景，就是如果我们能保证accessCount++这个操作的3个步骤是原子性的，比如线程1开始了第一个步骤，那线程2如果要执行的话那就等着吧，等到线程1把3个步骤都执行完，线程2才能开始第一个步骤。那这样就能解决线程安全的问题了！</span></p><h4><a name="五总结" class="md-header-anchor"></a><span>五、总结</span></h4><p><span>总结一下本文的内容，首先从一个常见的面试题：统计服务器接口的访问次数，引出来了多线程并发访问共享变量的问题。</span></p><p><span>接着简单介绍了一下计算机CPU内存模型，在这基础上，咱们又去理解了Java的内存模型，紧接着基于Java的内存模型一步一图分析线程安全问题产生的原因。</span></p><p><span>最后提出一些解决问题的思路，从而引出并发编程中一个很重要的概念：原子性。下篇文章会对一些常见的并发问题进行分析，同时给出一些并发问题常见的解决方案。敬请期待，再见。</span></p><p>&nbsp;</p><h3><a name="02锦囊妙计解决并发问题的方法有哪些" class="md-header-anchor"></a><strong><span>02_锦囊妙计：解决并发问题的方法有哪些？</span></strong></h3><h4><a name="一前文回顾" class="md-header-anchor"></a><strong><span>一、前文回顾</span></strong></h4><p><span>上一篇文章我们提到多线程读写共享变量时，由于多个线程同时操作主内存中的共享变量时，会把其拷贝到每个线程的工作内存中进行操作，所以会出现缓存不一致的问题。</span></p><p>&nbsp;</p><p><span>本篇文章我们将盘点一下常见并发问题的解决方法有哪些? 这里用一张图说明：</span></p><p>&nbsp;</p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/15735400_1622345382.png" referrerpolicy="no-referrer" alt="img"></p><p><span>图1</span></p><p><span>从上图我们看到，解决并发问题的方法分为两大类：无锁和有锁。无锁可分为：局部变量、不可变对象、ThreadLocal、CAS原子类；而有锁的方式又分为synchronized关键字和ReentrantLock可重入锁。</span></p><p>&nbsp;</p><p><span>下面我们来分析下为什么这些方法能解决并发问题？</span></p><p>&nbsp;</p><p><span>首先需要声明的是，这些方法都需要在合适的场景下使用才能发挥作用。在下面的内容中，我们会用常见的例子来讲解每种方法，保证大家能有所收获。</span></p><h4><a name="二局部变量" class="md-header-anchor"></a><span>二、局部变量</span></h4><p><span>大家看到这个标题可能会觉得奇怪，为什么局部变量能解决并发问题呢？其实严格来说，是“善用局部变量可以避免出现线程安全问题”。因为局部变量仅仅存在于每个线程的工作内存中，假设有2个线程执行如下代码：</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/37313200_1622345382.png" referrerpolicy="no-referrer" alt="img"></p><p><span>只有当每个线程都执行到“int i =0”这一行代码的时候，会在各自线程所在的工作内存中创建这个变量，如下面图2所示：</span></p><p>&nbsp;</p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/b_u_5efbf242e79a5_klVaiiYb/kpew1m2k0442.jpg" referrerpolicy="no-referrer" alt="1.jpg"></p><p><span>图2</span></p><p><span>看到这里你有没有恍然大悟的感觉？原来每个线程都只在自己的工作内存操作各自变量“i”, 不同线程之间的“i”根本没有任何交集，所以也就不存在的并发问题了。</span></p><p>&nbsp;</p><h4><a name="三不可变对象" class="md-header-anchor"></a><span>三、不可变对象</span></h4><p><span>所谓的不可变对象是指一经创建，就对外的状态就不会改变的对象。如果一个对象的状态是亘古不变的，那么自然就不存在什么并发问题了。因为对象是不可变的，所以无论多少个线程，对它做什么操作，它都是不变的。</span></p><p>&nbsp;</p><p><span>举个例子，我们常用的字符串对象就是一个不可变对象，比如：String s=“Hello” ，注意这里的字符串是指“Hello”，而不是指引用“Hello”这个字符串的变量s，即便我们使用“Hello” 这个字符串和字符串“World”组合得到一个新的字符串“HelloWorld”，原本的“Hello”字符串也不会发生变化，这就是咱们说的不可变对象。</span></p><p>&nbsp;</p><h4><a name="四threadlocal" class="md-header-anchor"></a><span>四、ThreadLocal</span></h4><p><span>ThreadLoca本质上也是在每个线程有自己的一个副本，每个线程的副本是互不影响，没有任何关系的。</span></p><p>&nbsp;</p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/62530700_1632627200.jpg" referrerpolicy="no-referrer" alt="1632624185.jpg"></p><p><span>图3</span></p><p><span>如图3所示，一个命名为“i”的ThreadLocal类，它会在每个线程都有一个Integer的对象，虽然每个线程都会从主存内中把Integer对象拷贝到工作内存中，但是线程1和线程2拷贝过来的对象并不是同一个对象，其中每个对象只会被其中一个线程操作，这种场景不存在所谓的“共享变量”，也就不存在并发问题了。</span></p><p>&nbsp;</p><h4><a name="五cas原子类" class="md-header-anchor"></a><span>五、cas原子类</span></h4><p><span>CAS的意思是Compare And Swap，英文翻译过来的意思是“比较并置换”，CAS机制当中使用了3个基本操作数：内存地址V，旧的预期值A，要修改的新值B，只有当内存地址V所对应的值和旧的预期值A相等的时候，才会将内存地址V对应的值更新为新的值B。</span></p><p>&nbsp;</p><p><span>在Java中的实现则通常是指以英文Atomic为前缀的一系列类，它们都采用了CAS的思想。</span></p><p>&nbsp;</p><p><span>Atomic系列的使用的是一种无锁化的CAS操作，是基于乐观锁的，它的并发性能比较高，可以多个线程同时执行，并且保证不会出现线程安全问题。</span></p><p>&nbsp;</p><p><span>让我们来看看AtomicInteger的简单使用：</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/87596100_1622345382.png" referrerpolicy="no-referrer" alt="img"></p><p><span>首先声明一个AtomicInteger counter的成员变量，接着在atomicAdd()方法中调用incrementAndGet()，atomicAdd 即使是被多线程调用，也不会有并发问题。</span></p><p>&nbsp;</p><p><span>再让我们来看看AtomicInteger的源码：</span></p><p>&nbsp;</p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/1640500_1622345383.png" referrerpolicy="no-referrer" alt="img"></p><p><span>可以看到在源码内部存在一个Unsafe的实例，Unsafe类提供硬件级别的原子操作，因为Java无法直接访问到操作系统底层的硬件，为此Java使用native方法来拓展这部分功能，其中Unsafe类就是一个操作入口。Unsafe提供了几种功能，其中包括分配和释放内存，挂起和恢复线程，定位对象字段内存地址，修改对象的字段值，CAS操作。</span></p><p>&nbsp;</p><p><span>其中我们主要用到的是Unsafe的CAS操作，其中主要是调用了unsafe的getAddnt方法：</span></p><p>&nbsp;</p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/21234300_1622345383.png" referrerpolicy="no-referrer" alt="img"></p><p><span>可以看到首先通过var5这个变量获取到旧的值，接着调用compareAndSwapInt方法通过</span></p><p><span>CAS操作来对数据进行比较并置换，如果操作失败了，会进入while循环，直到操作成功，其中compareAndSwapInt方法是一个native方法，底层是通过C++来实现的，它可以保证整个操作是原子性的，从而避免并发问题。</span></p><p>&nbsp;</p><p><span>我们再来回顾一下上一篇文章提到的面试题：统计某个接口的访问次数。如果采用Atomic系列的原子类对代码进行改写的话，就不会有并发问题了：</span></p><p>&nbsp;</p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/39342900_1622345383.png" referrerpolicy="no-referrer" alt="img"></p><p><span>实际运行情况如图4：</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/58919600_1622345383.png" referrerpolicy="no-referrer" alt="img"></p><p><span>图4</span></p><p><span>有2个线程同时去调用access()方法，其中图4中中间淡绿色区域的操作是原子操作，要不全部都执行，要不全部不执行。</span></p><p>&nbsp;</p><p><span>假设此时主存的accessCount的值为0，线程1和线程2同时通过CAS对accessCount的值进行累加，线程1和线程2都需要将accessCount从0更新到1，结果线程1很幸运地成功了，将accessCount的值更新为1。而线程2就失败了，线程2失败后会再次通过CAS操作进行累加，这时线程2重新读取最新的accessCount的值为1，接着将accessCount的值从1更新为2，最后咱们就得到了准确的计算结果。</span></p><p><span>下次再遇见这样的面试题，咱们就可以自信满满了。</span></p><h4><a name="六synchronizedreentrantlock加锁" class="md-header-anchor"></a><span>六、Synchronized/ReentrantLock加锁</span></h4><p><span>Synchronized和ReentrantLock都是采用了悲观锁的策略。因为他们的实现非常类似，只不过一种是通过语言层面来实现(Synchronized)，另一种是通过编程方式实现(ReentrantLock)，所以咱们把两种方式放在一起分析了。</span></p><p>&nbsp;</p><p><span>先来看看一个i++的例子，通过这两种方式都能保证线程安全：</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/56998100_1622677158.png" referrerpolicy="no-referrer" alt="image.png"></p><p>&nbsp;</p><p><span>代码中lockMethod1使用了ReentrantLock的方式对累加操作进行加锁，在lock()方法调用之后和unlock方法调用之前的代码能够保证执行的时候是原子性的。如果多个线程同时调用lockMethod1的话，也不会存在线程安全问题。</span></p><p>&nbsp;</p><p><span>lockMethon2中，直接在方法上加了synchronized关键字，意味着这个方法在执行的时候也是原子性的，也同样不会存在线程安全问题。</span></p><p><span>在i++这个操作上面，主要分为3个步骤：</span></p><p><span>\1. 读取i的值</span></p><p><span>\2. 将i的值加1</span></p><p><span>\3. 将i的值写回主存中</span></p><p><span>这上面的3个操作都通过加锁可以保证是原子性的，要么3个操作都执行，要么3个操作都不执行，所以可以解决线程安全问题。</span></p><p><span>加锁的原理如图5：</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/75657400_1622345383.png" referrerpolicy="no-referrer" alt="img"></p><p><span>图5</span></p><p><span>首先两个线程都去争抢同一个锁，假设线程1获取到了锁，而线程2获取不到锁，就会进入等待队列，等到线程1，执行完代码逻辑之后，会去通知线程2：嘿，哥们，我用完了，你可以去尝试获取锁了，这时线程2会重新尝试去获取锁，假如线程2获取锁成功，线程2才开始执行代码。</span></p><h4><a name="七总结" class="md-header-anchor"></a><span>七、总结 </span></h4><p><span>最后做一下小结，本篇文章介绍了一些常见的解决并发问题的方法，这些方法分为无锁和有锁两大类，其中无锁的方法有采用局部变量、ThreadLocal、不可变对象、CAS原子类等形式的方法；而有锁的方法也可分为通过Synchronized的方式和ReentrantLock的方式。文中分别对这些方法进行了介绍，并且通过画图和代码分析其中的实现原理，希望大家能好好学习，理解吸收这些内容。</span></p><p>&nbsp;</p><p><span>下篇文章我们会继续讲解“不可变对象”，来一个小小的实战，敬请期待，再见。</span></p><p>&nbsp;</p><h3><a name="03小试牛刀如何快速实现一个不可变类" class="md-header-anchor"></a><strong><span>03_小试牛刀：如何快速实现一个不可变类？</span></strong></h3><h4><a name="一案例分析" class="md-header-anchor"></a><span>一、案例分析</span></h4><p><span>今天这篇文章我们将通过一个车辆管理系统的案例讲解实现不可变类的思路。在这个案例中，需要对车辆的信息进行跟踪，其中车辆的位置信息的代码如下图（图1）：</span></p><h4><a name="imghttpwechatapppro-1252524126filemyqcloudcomimageueditor341404001622348613png" class="md-header-anchor"></a><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/34140400_1622348613.png" referrerpolicy="no-referrer" alt="img"></h4><p><span>图1</span></p><p><span>图中是一个位置信息类，包含代表坐标的变量X和Y，和用来对车辆位置信息进行更新的方法setXY，接下来我们看下实现车辆信息追踪代码（图2）：</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/87416300_1622348613.png" referrerpolicy="no-referrer" alt="img"></p><p><span>图2</span></p><p><span>当车辆的位置信息发生变更的时候，我们可以调用updateLocation方法来更新车辆的位置，另外也可以通过调用getLocation方法来获取车辆的信息。</span></p><p>&nbsp;</p><p><span>但Location类的setXY方法不是一个线程安全的方法，我们可以参考下图（图3）做一下具体分析：</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/41871900_1622348614.png" referrerpolicy="no-referrer" alt="img"></p><p><span>图3</span></p><p><span>如图3所示，一开始某辆车的位置信息为x=1.0 y=1.0，接着线程1调用updateLocation方法来更新位置信息为x = 2.0，y = 2.0 ，这时线程1只来得及更新了x的值，y的值还没有更新，好巧不巧，线程2也来读取车辆的位置信息，此时它得到的结果是 x =2.0，y = 1.0。 这可是这个车根本不曾到达过的“诗和远方”。</span></p><p>&nbsp;</p><p><span>为了确保车辆信息的更新具备线程安全的特性，我们可以将位置信息类改造为不可变类，如果车辆的位置信息发生变化，咱们通过替换整个Location对象来实现，而不是通过setXY方法来实现。 </span></p><p>&nbsp;</p><h4><a name="二如何实现一个不可变类" class="md-header-anchor"></a><span>二、如何实现一个不可变类？</span></h4><p><span>那么怎么将一个类改造为不可变类呢？所谓的不可变类是指一个对象一经创建就不再改变。</span></p><p><span>在我们车辆管理系统中来说就是Location类一旦创建就不能变了，不能改变X的值，也不能改变Y的值。</span></p><p>&nbsp;</p><p><span>说到这就有点意思了，如果Location类中的X的值不能变，Y的值也不能变，那么我们是不是可以使用Java的关键字final来修饰这两个字段，通过Java语言的语法特性来保证这两个字段的不可变，如图4:</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/93316400_1622348614.png" referrerpolicy="no-referrer" alt="img"></p><p><span>图4</span></p><p><span>接着还是说X和Y的值不能改变，这个时候setXY方法的存在是不是不太合理？所以需要将setXY方法也去掉。</span></p><p>&nbsp;</p><h4><a name="三继续思考如果当前类被子类继承还是一个不可变类吗" class="md-header-anchor"></a><span>三、继续思考：如果当前类被子类继承还是一个不可变类吗？ </span></h4><p>&nbsp;</p><p><span>接着我们再思考一个问题：假设我有一个子类继承了Location，然后重写了它的getX方法怎么办？如图5：</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/35258300_1622348615.png" referrerpolicy="no-referrer" alt="img"><span>图5</span></p><p><span>如图5所示，假设有人继承Location类，然后重写getX方法。比如说我本来一个Location对象的X值为1的，但是这个子类确返回了 1 + 1 = 2。这很显然不符合不可变对象的行为，因为它的子类可以改变它的方法行为。 为了杜绝这种情况，我们需要将Location类设计为不可继承的，通过final修饰符修饰即可。</span></p><p>&nbsp;</p><p><span>那么最终版本的不可变的Location如图6：</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/74338700_1622348615.png" referrerpolicy="no-referrer" alt="img"></p><p><span>图6</span></p><p><span>接着，如果车辆位置发生变化的时候，通过替换整个Location来表示，这样就能避免前面的问题了。</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/23776400_1622348616.png" referrerpolicy="no-referrer" alt="img"></p><p><span>图7</span></p><p><span>如图7中，如果车辆位置发生了变化，可以通过替换整个Location从而避免线程安全问题。</span></p><h4><a name="" class="md-header-anchor"></a><span> </span></h4><h4><a name="四回头看看如何将一个类改造成不可变类" class="md-header-anchor"></a><span>四、回头看看：如何将一个类改造成不可变类？</span></h4><p>&nbsp;</p><p><span>通过上面的例子，我们大概了解了使用可变的类会引发什么样问题，以及如何将一个类改造成不可变类，来解决线程安全问题。最后我们总结一下实现不可变类的一些思路：</span></p><ol start='' ><li><span>使用final关键字修饰所有成员变量，避免其被修改，也可以保证多线程环境下被final关键字修饰的变量所引用的对象的初始化安全，即final修饰的字段在其他线程可见时，必定是初始化完成的。</span></li><li><span>使用private修饰所有成员变量，可以防止子类及其他地方通过引用直接修改变量值。</span></li><li><span>禁止提供修改内部状态的公开接口(比如我们前面例子中的setXY方法)</span></li><li><span>禁止不可变类被外部继承，防止子类改变其定义的方法的行为。</span></li><li><span>如果类中存在数组或集合，在提供给外部访问之前需要做防御性复制</span></li></ol><p><span>前面4点比较好理解，我们在前面改造Location为不可变类的过程中都有运用到，第5点则需要另外做一下说明</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/65613500_1622348616.png" referrerpolicy="no-referrer" alt="img"></p><p><span>图8</span></p><p><span>如图8所示，DefensiveReplicaDemo类中有一个List</span><Integer><span>类型的数据，使用了final关键字修饰，其中数据内容为1，2，3(构造函数添加进去的)。并且提供了一个getData()的方法。</span></p><p><span>注意看红框内的代码，调用了data.add(4)，因为返回的是一个引用，指向的对象和DefensiveReplicaDemo类中的data指向的对象是同一个，这样就会导致DefensiveReplicaDemo类中的data数据内容改变为1，2，3，4。 为了避免这种情况，我们通常会做防御性复制，如图9：</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/12378000_1622348617.png" referrerpolicy="no-referrer" alt="img"></p><p><span>图9</span></p><p><span>图9中，在返回data之前，创建了一个新的List对象返回，并且使用Collections.unmodifiableList方法进行包装，这样能保证外部无法修改我们返回的结果，那么DefensiveReplicaDemo的data集合的值永远会是1，2，3。</span></p><p>&nbsp;</p><h4><a name="五总结-n214" class="md-header-anchor"></a><span>五、总结</span></h4><p>&nbsp;</p><p><span>小结一下，本文我们通过一个车辆管理系统追踪车辆位置信息的案例引出可变类存在什么问题，然后介绍如何一步一步的将可变的Location类改造为不可变类，从而避免线程安全问题。最终提纲挈领的概括了一下实现不可变类的一些要点。</span></p><p>&nbsp;</p><h3><a name="04案例实战百万流量的短信网关系统如何基于不可变模式解决并发问题" class="md-header-anchor"></a><strong><span>04_案例实战：百万流量的短信网关系统，如何基于不可变模式解决并发问题？</span></strong></h3><h4><a name="一上节回顾" class="md-header-anchor"></a><span>一、上节回顾</span></h4><p><span>通过前面一篇文章的学习，我们通过一个案例了解了可变类可能会导致什么样的线程安全问题，同时也学习了什么是不可变类，如何将一个可变类改造为一个不可变类。</span></p><p><span>本篇文章则继续基于一个真实的“百万流量的短信网关系统”，更深入地讲解如何通过不可变模式来解决并发问题的。</span></p><p>&nbsp;</p><h4><a name="二业务背景介绍" class="md-header-anchor"></a><span>二、业务背景介绍</span></h4><p><span>首先介绍一下业务背景，有一个每天有百万流量的短信网关系统，这个系统会使用第三方短信服务商（比如说阿里云、腾讯云、百度云等等）的短信发送功能。</span></p><p>&nbsp;</p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/8162600_1622349082.png" referrerpolicy="no-referrer" alt="img"></p><p><span>图1</span></p><p><span>短信网关后面对接着多家三方短信服务提供商，当我们需要发送短信的时候，短信网关会根据一定的策略(比如说选择费率最低的、或者到达率最高的)从三方短信厂商中选择一家，调用他们的接口给用户发送短信。</span></p><p><span>另外因为短信服务厂商市面上有很多，所以我们系统需要根据公司运营情况对服务商进行PK，即对服务商进行多维度的考察，假设某个服务商的考察结果不尽人意，就会被替换掉。如图2所示</span></p><p>&nbsp;</p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/40693700_1622349082.png" referrerpolicy="no-referrer" alt="img"></p><p><span>图2</span></p><p><span>图2中左上角会定时对短信服务上进行PK，如果发现某个服务商不行了，则会在短信网关后台管理服务中更新短信服务商列表，也就是把某些PK中输掉的服务商替换。</span></p><h4><a name="三短信服务商基本信息" class="md-header-anchor"></a><span>三、短信服务商基本信息</span></h4><p><span>1、先来看看短信服务商的基本信息：</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/74975500_1622349082.png" referrerpolicy="no-referrer" alt="img"></p><p><span>图3</span></p><p><span>如图3所示，短信服务商信息包括服务商请求的url以及每次发送的字节数量。</span></p><p>&nbsp;</p><h4><a name="四短信路由网关" class="md-header-anchor"></a><span>四、短信路由网关</span></h4><p><span>再者短信服务上服务商信息列表是保存在数据库中的，由于这个数据会比较常用，而每次发送短信之前都需要根据一定的策略来选择服务商，所以在系统启动的时候，会将所有的短信服务上列表从数据库中加载出来放在内存里，有一个叫做SmsRouter的类专门去做这个事情，代码如下图（图4）所示：</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/10545900_1622349083.png" referrerpolicy="no-referrer" alt="img"></p><p><span>图4</span></p><p><span>如图4所示，SmsRouter在构造函数中调用了loadSmsInfoRouteMapFromDb方法，把短信服务商信息从数据库中加载到内存中(这里使用模拟的方式)，用字段smsInfoRouteMap保存。其中smsInfoRouteMap的Key为服务商排名。</span></p><p><span>当短信服务商发生变更的时候的时候，会先更新更新数据库，然后去更新内存中的短信服务商信息。</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/55060100_1622349083.png" referrerpolicy="no-referrer" alt="img"></p><p><span>图5</span></p><p><span>图5中代码将服务商排名为3的服务商改为另外一个服务商。但是这里有一个问题，因为这里设置url和设置maxSizeInBytes并不是一个原子操作，可能出现其中一个线程刚刚设置了URL，另一个线程过来读取服务商排名为3的服务商的场景，这样读取排名为3的服务商得到的一个结果就是是：</span></p><p><span>SmsInfo(url = &quot;</span><a href='https://www.jiguang.cn' target='_blank' class='url'>https://www.jiguang.cn</a><span>&quot;, 182)。</span></p><p><span>这个结果是一个中间状态，其中url和maxSizeInBytes并不是属于同一个服务商的，这样很可能会导致程序出现问题。</span></p><p>&nbsp;</p><h4><a name="五基于不可变模式改造代码" class="md-header-anchor"></a><span>五、基于不可变模式改造代码</span></h4><p><span>接下来需要使用不可变模式来改造代码，避免这样的线程安全问题，第一步先将SmsInfo改造为不可变对象，改造后的结果如下：</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/85747100_1622349083.png" referrerpolicy="no-referrer" alt="img"></p><p><span>图6</span></p><p><span>图6中，将SmsInfo改造为不可变对象，声明这个类时使用final关键字修饰，表示其不可被继承，另外每个字段都使用了private final进行修饰。</span></p><p><span>接着在需要将获取服务商列表的代码改造为防御性复制，如图7所示</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/26860400_1622349084.png" referrerpolicy="no-referrer" alt="img"></p><p><span>图7</span></p><p><span>在图7中，在返回smsInfoRouteMap数据之前，做了防御性复制，即便外部改变获取到对象的状态，也不会影响SmsRouter本身的smsInfoRouteMap数据。</span></p><p><span>接着提供一个直接替换SmsRouter实例的方法，便于用来刷新整个服务商信息：</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/61225200_1622349084.png" referrerpolicy="no-referrer" alt="img"></p><p><span>图8</span></p><p><span>在短信服务商发生变更的时候，代码如下：</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/89433100_1622349084.png" referrerpolicy="no-referrer" alt="img"></p><p><span>图9</span></p><p><span>当短信服务商列表发生变化的时候，我们通过调用changeRouteInfo方法，更新数据库中的服务商信息，接着替换整个SmsRouter实例。</span></p><p><span>这样一来，SmsRouter在构造函数的时候会调用loadSmsInfoRouteMapFromDb方法将更新后的短信服务商列表从数据库中读取出来，然后更新到内存中。</span></p><p><span>到此为止，我们就通过不可变模式避免了短信网关中服务商列表更新的线程安全问题，这归功于短信服务上信息SmsInfo的不可变性，从而避免了修改SmsInfo在多线程环境下的线程安全问题，另外在SmsRouter获取服务上列表的过程中，对服务商列表进行了了防御性复制，避免外部其他的类对SmsRouter中的短信服务商列表的进行修改。</span></p><p>&nbsp;</p><h4><a name="六总结" class="md-header-anchor"></a><span>六、总结</span></h4><p><span>当然了，有人可能会想到：解决短信服务上更新的线程安全问题可以加锁啊！通过加锁的方式实现当然也是可以的，但是我们这篇文章主题是通过不可变类来避免线程安全问题，所以这里演示的是通过不可变对象的方式，其实两种方式都可以，本篇文章只是提供一个可行的方案。实现不可变类在实战中比较有用，希望大家能深入理解并灵活使用。</span></p><p>&nbsp;</p><h3><a name="05源码分析等效不可变对象copyonwritearraylist适用场景剖析" class="md-header-anchor"></a><strong><span>05_源码分析：等效不可变对象CopyOnWriteArrayList适用场景剖析</span></strong></h3><h4><a name="一开篇词" class="md-header-anchor"></a><span>一、开篇词</span></h4><p>&nbsp;</p><p><span>本篇文章我们分析一下等效不可变对象在在源码中的应用,主要是围绕CopyOnWriteArrayList的原理来展开，CopyOnWriteArrayList的源码中运用了不可变对象模式，使得集合在进行遍历操作的时候，不用加锁也能保证线程安全。</span></p><p>&nbsp;</p><h4><a name="二等效不可变对象" class="md-header-anchor"></a><span>二、等效不可变对象</span></h4><p><span>通过前面的文章分析，我们知道了什么是不可变对象，而等效不可变对象的意思就是说对象基本符合不可变对象的一些特征，但是某些情况下内部状态可能会改变，这样的解释可能有点难以理解，这里结合CopyOnWriteArrayList的代码来讲解，如图1所示：</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/54765600_1622349725.png" referrerpolicy="no-referrer" alt="img"></p><p><span>图1</span></p><p><span>可以看到CopyOnWriteArrayList源码中维护一个array对象数组用于存储集合的每个元素，并且array数组只能通过getArray和setArray方法来访问。</span></p><p>&nbsp;</p><p><span>接下来看看CopyOnWriteArrayList在进行数据遍历和新增一个元素的方法：</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/89262900_1622349725.png" referrerpolicy="no-referrer" alt="img"><span>图2</span></p><p><span>在图2中，在调用iterator方法的时候，会通过getArray()方法获取array数组，然后基于这个数组进行遍历遍历。另外再新增一个元素，调用add方法的时候，也是通过getArray()获取到对象数组，然后直接新生成一个数组，最后把旧的数组的值复制到新的数组中，然后直接使用新的数组覆盖实例变量array。</span></p><h4><a name="三回头看看实例变量array就是一个等效不可变对象" class="md-header-anchor"></a><span>三、回头看看：实例变量array就是一个等效不可变对象？</span></h4><p><span>我们仔细思考一下，在array对象每次被创建之后，其内容就不再被改变。（数组的长度和每个元素都不变）。另外就算我们对CopyOnWriteArrayList进行集合元素的增删，这里也不是直接改变原数组的元素，而是直接新建了一个新的数组，替换掉array对象。在这个时候，旧的那个数组还是没有改变过。</span></p><p><span>但是这里会存在一些差异，因为实例变量array本质上是一个数组，而数组的各个元素都是一个对象，每个对象内部的状态是可以替换的。因此实例变量并非严格意义上的不可变对象，所以我们称之为等效不可变对象。</span></p><p><span>举个例子说明一下这种情况，如图3所示：</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/23349200_1622349726.png" referrerpolicy="no-referrer" alt="img"></p><p><span>图3</span></p><p><span>我们有一个类Message，其中有一个字段叫做msg，这个字段通常情况下会在构造函数中指定，也可以通过setMsg方法设定。</span></p><p><span>我们首先创建了一个CopyOnWriteArrayList对象，然后新建了一个Message对象，其中msg的值为“你好，张三”, 接着我们将这个字段添加到CopyOnWriteArrayList中。此时</span></p><p><span>CopyOnWriteArrayList中的array内容大致如下：</span></p><p><span>array = [ Message{msg =“你好，张三”, hashCode = 001} ]</span></p><p><span>其中array数组不会再继续改变，这意味对于实例变量array来说，里面的元素不会改变(不会从hashCode为001的对象变成其他对象)，但是CopyOnWriteArrayList无法限制调用者</span></p><p><span>的一些行为，比如将 hashCode为001的对象中的msg字段的值改变。</span></p><p><span>如图3中红色框的代码，将msg字段设置为“你好，李四”。这样array的内容大致如下：</span></p><p><span>array = [ Message{msg =“你好，李四”, hashCode = 001} ]</span></p><p><span>可以看到，array数组所对应存储的对象是不可变的，但是存储的对象的内部状态是可能改变的，所以这种情况下array就被叫做等效不可变对象。</span></p><h4><a name="四写时复制机制" class="md-header-anchor"></a><span>四、写时复制机制</span></h4><p><span>通过前面的分析，我们了解了什么叫做等效不可变对象，但是CopyOnWriteArrayList的设计之精妙远不止于此，让我们再瞧一眼这个类的名字：CopyOnWrite，翻译过来就是“写时复制”，这个写时复制是CopyOnWriteArrayList设计的一大亮点。</span></p><p>&nbsp;</p><p><span>我们回顾一下图2中对CopyOnWriteArrayList进行迭代和添加元素的代码：</span></p><p>&nbsp;</p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/64199300_1622349726.png" referrerpolicy="no-referrer" alt="img"></p><p><span>图2</span></p><p><span>可以看到，我们对集合进行迭代的情况，本质上是一个读操作。而往集合中新增一个元素本质上是一个写操作。</span></p><p><span>写时复制机制主要体现在写操作上，从图2中代码可以看到，在进行写操作的时候，首先是基于array这份数据复制出来一份数据，接着在复制出来的数据基础上进行写操作。同理，我们看看另一种写场景: 删除一个元素</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/11592000_1622349727.png" referrerpolicy="no-referrer" alt="img"></p><p><span>图4</span></p><p><span>如图4所示，主要看红色框，在移除一个元素的时候，最终都是基于原有的数组复制一个新的数组，然后直接用新的数据替换掉旧的数组。</span></p><p><span>写时复制的最终目的是为了在读多写少的场景，通过写时复制的机制，让大量的读请求在无需加锁牺牲性能的情况下保证多线程并发读写的情况下线程安全。</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/41675300_1622349727.png" referrerpolicy="no-referrer" alt="img"></p><p><span>图4</span></p><p><span>图4中演示了两个线程并发读取CopyOnWriteArrayList的情况，其中线程1需要通过iterator()方法读取数据，其中集合中的元素为元素1、元素2，但是这个时候线程2需要往集合中添加一个元素：元素3，这个时候线程2的操作是直接基于集合当前的数据进行复制一份到新的一个数组，最后将array变量指向新的一个数组。</span></p><p><span>注意思考这样的一个场景：假设线程1在遍历元素的时候，读到了元素1，但是还没有读到元素2的时候，线程2添加了元素3，这个时候线程1是无法读取到元素3的。这是因为线程1和线程2操作的数组不是同一个数组。 这也是CopyOnWriteArrayList的一个特点：弱一致性。意思就是说线程1看到的是某一时刻的一份“快照数据”，无法保证能读取到最新的数据。</span></p><h4><a name="五copyonwritearraylist的使用场景" class="md-header-anchor"></a><span>五、CopyOnWriteArrayList的使用场景</span></h4><p><span>总的来说，CopyOnWriteArrayList适用于读多写少的场景，接下来我们看看CopyOnWriteArrayList的一些实际的运用场景，我们平时和数据库打交道想必不少，而使用Java语言操作数据库一般都是通过JDBC来实现。通常来说我们都要在程序启动的时候加载对应数据库的驱动，如图5所示：</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/69677000_1622349727.png" referrerpolicy="no-referrer" alt="img"></p><p><span>图5</span></p><p><span>第一步需要加载对应的数据库驱动，比如MySql驱动或者Oracle驱动，现在Mysql数据库为主流数据库，所以我们看看Mysql的驱动程序：</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/1806000_1622349728.png" referrerpolicy="no-referrer" alt="img"></p><p><span>图6</span></p><p><span>在图6中，Mysql的Driver有一块静态代码块，表示在加载类的时候会执行这段代码，最终执行了DriverManager的registerDriver程序。</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/38656300_1622349728.png" referrerpolicy="no-referrer" alt="img"></p><p><span>图7</span></p><p><span>图7中registerDriver方法，实际上是往registerDrivers中添加了一个DriverInfo对象，而registerDrivers就是一个CopyOnWriteArrayList。</span></p><p><span>来分析一下，registerDrivers就是用来保存不同的数据库驱动的，而通常来说，一个项目上只有一个数据库类型，就算在一些复杂的场景下，可能一个项目对应多个数据库类型，有Mysql数据库也有Oracle数据库，甚至其他的一些数据库。但是无论有多少个数据库类型，数据库的驱动程序一般都是在程序启动的时候加载的，也就是说registerDriver方法一般来说都是在程序启动的时候进行调用的，在后续程序运行过程中一般不会再调用这个方法，这种场景完美符合“写少”的定义，基本上在程序运行过程中，不会再进行写操作(也就是add/remove等操作)</span></p><p><span>接下来我们在分析下读操作，什么情况下会对数据库驱动程序进行读取呢？在我们程序中需要调用JDBC得到数据库连接的时候，会去遍历所有的driver，然后找到一个driver，然后通过那个特定的driver来获取连接，代码如图8：</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/71130900_1622349728.png" referrerpolicy="no-referrer" alt="img"></p><p><span>图8</span></p><p><span>在图8中，截取了一段getConnection方法的代码，可以看到红框中，对通过遍历registerDrivers，然后判断每个驱动程序能否被加载，如果可以加载就通过驱动程序来获取connection。这个getConnection方法会被频繁调用，因为一般开发一些项目的话，需要经常和数据库进行交互，会经常需要获取连接，所以getConnection的调用频率肯定会高一些。</span></p><p><span>JDBC驱动程序列表这种数据，因为驱动程序变更的情况比较少，但是遍历这个驱动程序列表的情况比较多，所以是符合读多写少的特性，所以这个使用CopyOnWriteArrayList来维护比较合适。</span></p><h4><a name="六总结-n337" class="md-header-anchor"></a><span>六、总结</span></h4><p><span>在文章末尾，我们来回顾一下本篇文章的内容，首先我们通过CopyOnWriteArrayList来解释什么是不可变对象，接着通过分析写时复制机制，知道了CopyOnWriteArrayList的实现本质上是通过弱一致性提升读请求并发，适合用在数据读多写少的场景；最后通过了JDBC中的数据库驱动程序列表管理，分析这种数据的读多写少的特性，演示了源码中使用CopyOnWriteArrayList的场景。</span></p><p>&nbsp;</p><h3><a name="06基础回顾线程在执行过程中的状态是如何流转的" class="md-header-anchor"></a><strong><span>06_基础回顾：线程在执行过程中的状态是如何流转的？</span></strong></h3><h4><a name="-一线程的生命周期" class="md-header-anchor"></a><span>** 一、线程的生命周期** </span></h4><p><span>首先，我们了解下，Java线程在运行生命周期中可能处于的6种不同状态：</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/91206200_1622350054.png" referrerpolicy="no-referrer" alt="img"></p><p>&nbsp;</p><p><span>下面是JDK源码：src/main/java/java/lang/Thread.java 中 线程状态State枚举 代码：</span></p><pre spellcheck="false" class="md-fences md-end-block ty-contain-cm modeLoaded" lang=""><div class="CodeMirror cm-s-inner CodeMirror-wrap" lang=""><div style="overflow: hidden; position: relative; width: 3px; height: 0px; top: 0px; left: 8px;"><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0" style="position: absolute; bottom: -1em; padding: 0px; width: 1000px; height: 1em; outline: none;"></textarea></div><div class="CodeMirror-scrollbar-filler" cm-not-content="true"></div><div class="CodeMirror-gutter-filler" cm-not-content="true"></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer" style="margin-left: 0px; margin-bottom: 0px; border-right-width: 0px; padding-right: 0px; padding-bottom: 0px;"><div style="position: relative; top: 0px;"><div class="CodeMirror-lines" role="presentation"><div role="presentation" style="position: relative; outline: none;"><div class="CodeMirror-measure"></div><div class="CodeMirror-measure"></div><div style="position: relative; z-index: 1;"></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline" style="position: relative;"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter" style="left: 0px; width: 0px;"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">public enum State { &nbsp; &nbsp;  NEW, &nbsp;  RUNNABLE, &nbsp;  BLOCKED, &nbsp;  WAITING, &nbsp; &nbsp; TIMED_WAITING, &nbsp;  TERMINATED;}</span></pre></div></div></div></div></div></div><div style="position: absolute; height: 0px; width: 1px; border-bottom: 0px solid transparent; top: 46px;"></div><div class="CodeMirror-gutters" style="display: none; height: 46px;"></div></div></div></pre><p>&nbsp;</p><h4><a name="二线程的状态流转图" class="md-header-anchor"></a><span>二、线程的状态流转图</span></h4><p>&nbsp;</p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/25452800_1622350055.png" referrerpolicy="no-referrer" alt="img"></p><h4><a name="三线程各个状态说明" class="md-header-anchor"></a><span>三、线程各个状态说明</span></h4><p><span>1、NEW（初始化状态） </span></p><p><span>实现Runnable接口和继承Thread可以得到一个线程类，new一个实例出来，线程就进入了初始化状态。</span></p><p><span>我们用代码来实现下创建线程的2个过程</span></p><p><span>方法一：继承Thread类</span></p><pre spellcheck="false" class="md-fences md-end-block ty-contain-cm modeLoaded" lang=""><div class="CodeMirror cm-s-inner CodeMirror-wrap" lang=""><div style="overflow: hidden; position: relative; width: 3px; height: 0px; top: 0px; left: 8px;"><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0" style="position: absolute; bottom: -1em; padding: 0px; width: 1000px; height: 1em; outline: none;"></textarea></div><div class="CodeMirror-scrollbar-filler" cm-not-content="true"></div><div class="CodeMirror-gutter-filler" cm-not-content="true"></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer" style="margin-left: 0px; margin-bottom: 0px; border-right-width: 0px; padding-right: 0px; padding-bottom: 0px;"><div style="position: relative; top: 0px;"><div class="CodeMirror-lines" role="presentation"><div role="presentation" style="position: relative; outline: none;"><div class="CodeMirror-measure"><pre><span>xxxxxxxxxx</span></pre></div><div class="CodeMirror-measure"></div><div style="position: relative; z-index: 1;"></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline" style="position: relative;"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter" style="left: 0px; width: 0px;"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">public class ThreadTest extends Thread { &nbsp;  private String name; &nbsp;  public ThreadTest(String name) { &nbsp; &nbsp; &nbsp;  this.name = name; &nbsp;  } &nbsp;  public void run() { &nbsp; &nbsp; &nbsp;  for (int i = 1; i &lt; 11; i++) { &nbsp; &nbsp; &nbsp; &nbsp;  System.out.println(Thread.currentThread().getName() + " thread " + i); &nbsp; &nbsp; &nbsp;  } &nbsp;  } &nbsp;  public static void main(String[] args) { &nbsp; &nbsp; &nbsp;  ThreadTest t1 = new ThreadTest("thread1"); &nbsp; &nbsp; &nbsp;  ThreadTest t2 = new ThreadTest("thread2"); &nbsp; &nbsp; &nbsp;  ThreadTest t3 = new ThreadTest("thread3"); &nbsp; &nbsp; &nbsp;  t1.start(); &nbsp; &nbsp; &nbsp;  t2.start(); &nbsp; &nbsp; &nbsp;  t3.start(); &nbsp;  }}</span></pre></div></div></div></div></div></div><div style="position: absolute; height: 0px; width: 1px; border-bottom: 0px solid transparent; top: 161px;"></div><div class="CodeMirror-gutters" style="display: none; height: 161px;"></div></div></div></pre><p><span>方法二：实现Runnable接口</span></p><pre spellcheck="false" class="md-fences md-end-block ty-contain-cm modeLoaded" lang=""><div class="CodeMirror cm-s-inner CodeMirror-wrap" lang=""><div style="overflow: hidden; position: relative; width: 3px; height: 0px; top: 0px; left: 8px;"><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0" style="position: absolute; bottom: -1em; padding: 0px; width: 1000px; height: 1em; outline: none;"></textarea></div><div class="CodeMirror-scrollbar-filler" cm-not-content="true"></div><div class="CodeMirror-gutter-filler" cm-not-content="true"></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer" style="margin-left: 0px; margin-bottom: 0px; border-right-width: 0px; padding-right: 0px; padding-bottom: 0px;"><div style="position: relative; top: 0px;"><div class="CodeMirror-lines" role="presentation"><div role="presentation" style="position: relative; outline: none;"><div class="CodeMirror-measure"><pre><span>xxxxxxxxxx</span></pre></div><div class="CodeMirror-measure"></div><div style="position: relative; z-index: 1;"></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline" style="position: relative;"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter" style="left: 0px; width: 0px;"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">public class TestRunnable implements Runnable { &nbsp; &nbsp;  public void run() { &nbsp; &nbsp; &nbsp;  for(int i=1;i&lt;11;i++){ &nbsp;  <span class="cm-tab" role="presentation" cm-text="	">  </span><span class="cm-tab" role="presentation" cm-text="	">    </span> System.out.println(Thread.currentThread().getName()+" thread "+ i); &nbsp; &nbsp; &nbsp;  } &nbsp;  } &nbsp; &nbsp; &nbsp;  public static void main(String[] args) { &nbsp; &nbsp; &nbsp;  Thread t1=new Thread(new TestRunnable(),"thread1"); &nbsp; &nbsp; &nbsp;  Thread t2=new Thread(new TestRunnable(),"thread2"); &nbsp; &nbsp; &nbsp;  Thread t3=new Thread(new TestRunnable(),"thread3"); &nbsp; &nbsp; &nbsp;  t1.start(); &nbsp; &nbsp; &nbsp;  t2.start(); &nbsp; &nbsp; &nbsp;  t3.start(); &nbsp;  }}</span></pre></div></div></div></div></div></div><div style="position: absolute; height: 0px; width: 1px; border-bottom: 0px solid transparent; top: 138px;"></div><div class="CodeMirror-gutters" style="display: none; height: 138px;"></div></div></div></pre><p>&nbsp;</p><p>&nbsp;</p><p><span> 2、RUNNABLE（就绪，运行中状态） </span></p><p><span>READY 就绪</span></p><ol start='' ><li><span>就绪状态只是说你自个儿运行，调度程序没有挑选到你，你就永远是就绪状态。</span></li><li><span>调用线程的start()方法，此线程进入就绪状态。</span></li><li><span>当前线程sleep()方法结束，其他线程join()结束，等待用户输入完毕，某个线程拿到对象锁，这些线程也将进入就绪状态。</span></li><li><span>当前线程时间片用完了，调用当前线程的yield()方法，当前线程进入就绪状态。</span></li><li><span>锁池里的线程拿到对象锁后，进入就绪状态。</span></li></ol><p>&nbsp;</p><p><span>3、RUNNING 运行中状态</span></p><p><span>线程调度程序从可运行池中选择一个线程作为当前线程时线程所处的状态。这也是线程进入运行状态的唯一一种方式。</span></p><p>&nbsp;</p><p><span>4、BLOCKED（阻塞状态） </span></p><p><span>阻塞状态是线程阻塞在进入synchronized关键字修饰的方法或代码块(获取锁)之前时的状态。</span></p><p>&nbsp;</p><p><span>5、WAITING（等待状态） </span></p><p><span>调用sleep或是wait方法后线程处于WAITING状态，等待被唤醒。</span></p><p>&nbsp;</p><p><span>6、TIMED_WAITING（等待超时状态） </span></p><p><span>调用sleep或是wait方法后线程处于TIMED_WAITING状态，等待被唤醒或时间超时自动唤醒。</span></p><p>&nbsp;</p><p><span>7、TERMINATED（终止状态） </span></p><ol start='' ><li><span>当线程的run()方法完成时，或者主线程的main()方法完成时，我们就认为它终止了。这个线程对象也许是活的，但是，它已经不是一个单独执行的线程。线程一旦终止了，就不能复生。</span></li><li><span>在一个终止的线程上调用start()方法，会抛出java.lang.IllegalThreadStateException异常。</span></li></ol><p>&nbsp;</p><p>&nbsp;</p><h4><a name="四线程状态之间的转换" class="md-header-anchor"></a><span>四、线程状态之间的转换</span></h4><p><span>1、 NEW到RUNNABLE 状态</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/52349000_1622350055.png" referrerpolicy="no-referrer" alt="img"></p><p><span>实现Runnable接口和继承Thread可以得到一个线程类，创建这个类的实例对象，就是NEW状态；</span></p><p><span>而NEW状态的线程是不会被操作系统调度，因此也不会被执行。所以，当这个线程要执行时，就必须调用这个对象的start()方法，将NEW 状态转换到 RUNNABLE 状态。</span></p><p>&nbsp;</p><pre spellcheck="false" class="md-fences md-end-block ty-contain-cm modeLoaded" lang=""><div class="CodeMirror cm-s-inner CodeMirror-wrap" lang=""><div style="overflow: hidden; position: relative; width: 3px; height: 0px; top: 0px; left: 8px;"><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0" style="position: absolute; bottom: -1em; padding: 0px; width: 1000px; height: 1em; outline: none;"></textarea></div><div class="CodeMirror-scrollbar-filler" cm-not-content="true"></div><div class="CodeMirror-gutter-filler" cm-not-content="true"></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer" style="margin-left: 0px; margin-bottom: 0px; border-right-width: 0px; padding-right: 0px; padding-bottom: 0px;"><div style="position: relative; top: 0px;"><div class="CodeMirror-lines" role="presentation"><div role="presentation" style="position: relative; outline: none;"><div class="CodeMirror-measure"><pre><span>xxxxxxxxxx</span></pre></div><div class="CodeMirror-measure"></div><div style="position: relative; z-index: 1;"></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline" style="position: relative;"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter" style="left: 0px; width: 0px;"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">TestThread test= new TestThread ();Thread thread = new Thread(test);thread.start();</span></pre></div></div></div></div></div></div><div style="position: absolute; height: 0px; width: 1px; border-bottom: 0px solid transparent; top: 23px;"></div><div class="CodeMirror-gutters" style="display: none; height: 23px;"></div></div></div></pre><p>&nbsp;</p><p><span>2、RUNNABLE与BLOCKED 的状态转换</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/77331600_1622350055.png" referrerpolicy="no-referrer" alt="img"></p><p><span>目前只有当线程等待synchronized 的隐式锁时，线程才会从RUNNABLE 向BLOCKED 转换。</span></p><p>&nbsp;</p><p><span>我们知道，被synchronized 关键字修饰的方法、代码块在同一时刻只允许一个线程执行，其他线程只能等待。</span></p><p>&nbsp;</p><p><span>所以，这种情况下，等待的线程就会从 RUNNABLE 转换到 BLOCKED 状态。而当等待的线程获得 synchronized 隐式锁时，就又会从 BLOCKED 转换到 RUNNABLE 状态。</span></p><p>&nbsp;</p><p><span>如下面代码所示：</span></p><pre spellcheck="false" class="md-fences md-end-block ty-contain-cm modeLoaded" lang=""><div class="CodeMirror cm-s-inner CodeMirror-wrap" lang=""><div style="overflow: hidden; position: relative; width: 3px; height: 0px; top: 0px; left: 8px;"><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0" style="position: absolute; bottom: -1em; padding: 0px; width: 1000px; height: 1em; outline: none;"></textarea></div><div class="CodeMirror-scrollbar-filler" cm-not-content="true"></div><div class="CodeMirror-gutter-filler" cm-not-content="true"></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer" style="margin-left: 0px; margin-bottom: 0px; border-right-width: 0px; padding-right: 0px; padding-bottom: 0px;"><div style="position: relative; top: 0px;"><div class="CodeMirror-lines" role="presentation"><div role="presentation" style="position: relative; outline: none;"><div class="CodeMirror-measure"><pre><span>xxxxxxxxxx</span></pre></div><div class="CodeMirror-measure"></div><div style="position: relative; z-index: 1;"></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline" style="position: relative;"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter" style="left: 0px; width: 0px;"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">public class Account { &nbsp;  public void draw(double drawAmount) { &nbsp; &nbsp; &nbsp;  synchronized(this) { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; System.out.println("hello"); &nbsp; &nbsp; &nbsp;  } &nbsp;  } &nbsp;  public synchronized void drawTask(double drawAmount) { &nbsp; &nbsp; &nbsp;  System.out.println("hello"); &nbsp;  }}</span></pre></div></div></div></div></div></div><div style="position: absolute; height: 0px; width: 1px; border-bottom: 0px solid transparent; top: 69px;"></div><div class="CodeMirror-gutters" style="display: none; height: 69px;"></div></div></div></pre><p>&nbsp;</p><p>&nbsp;</p><p><span>3、RUNNABLE与WAITING 的状态转换</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/8177000_1622350056.png" referrerpolicy="no-referrer" alt="img"></p><p><span>有3种场景会触发线程从RUNNABLE向WAITING 转换；</span></p><p>&nbsp;</p><ol start='' ><li><span>获得 synchronized 隐式锁的线程，调用 Object.wait() 方法。</span></li></ol><p>&nbsp;</p><ol start='' ><li><span>另外一种，调用线程同步 Thread.join() 方法。</span></li></ol><p><span>例如有一个线程对象 thread A，当调用 A.join() 的时候，执行这条语句的线程会等待 thread A 执行完，而等待中的这个线程，其状态会从 RUNNABLE 转换到 WAITING。当线程 thread A 执行完，原来等待它的线程又会从 WAITING 状态转换到 RUNNABLE。</span></p><p>&nbsp;</p><ol start='' ><li><span>最后一种，调用 LockSupport.park() 方法。Java 并发包中的锁，都是基于LockSupport 对象实现的。调用 LockSupport.park() 方法，当前线程会阻塞，线程的状态会从 RUNNABLE 转换到 WAITING。调用 LockSupport.unpark(Thread thread) 方法，可唤醒目标线程，目标线程的状态又会从 WAITING 状态转换到 RUNNABLE。</span></li></ol><p><span>代码样例：</span></p><pre spellcheck="false" class="md-fences md-end-block ty-contain-cm modeLoaded" lang=""><div class="CodeMirror cm-s-inner CodeMirror-wrap" lang=""><div style="overflow: hidden; position: relative; width: 3px; height: 0px; top: 0px; left: 8px;"><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0" style="position: absolute; bottom: -1em; padding: 0px; width: 1000px; height: 1em; outline: none;"></textarea></div><div class="CodeMirror-scrollbar-filler" cm-not-content="true"></div><div class="CodeMirror-gutter-filler" cm-not-content="true"></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer" style="margin-left: 0px; margin-bottom: 0px; border-right-width: 0px; padding-right: 0px; padding-bottom: 0px;"><div style="position: relative; top: 0px;"><div class="CodeMirror-lines" role="presentation"><div role="presentation" style="position: relative; outline: none;"><div class="CodeMirror-measure"><pre><span>xxxxxxxxxx</span></pre></div><div class="CodeMirror-measure"></div><div style="position: relative; z-index: 1;"></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline" style="position: relative;"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter" style="left: 0px; width: 0px;"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">public void startThread() { &nbsp;  Thread t = new Thread( new Runnable() { &nbsp; &nbsp; &nbsp;  public void run() { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  System.out.println( "开始执行线程..."); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  System.out.println( "进入等待状态..."); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  synchronized (object) { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  try { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  object.wait(); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  } catch (InterruptedException e) { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  e.printStackTrace(); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  } &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  } &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  System.out.println( "线程结束..."); &nbsp; &nbsp; &nbsp;  } &nbsp;  }); &nbsp;  t.start();}</span></pre></div></div></div></div></div></div><div style="position: absolute; height: 0px; width: 1px; border-bottom: 0px solid transparent; top: 138px;"></div><div class="CodeMirror-gutters" style="display: none; height: 138px;"></div></div></div></pre><p>&nbsp;</p><p><span>4、RUNNABLE与TIMED_WAITING 的状态转换</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/32659300_1622350057.png" referrerpolicy="no-referrer" alt="img"></p><p><span>有5种场景会触发RUNNABLE向TIMED_WAITING转换：</span></p><p>&nbsp;</p><ol start='' ><li><span>调用带超时参数的 Thread.sleep(long millis) 方法；</span></li><li><span>获得 synchronized 隐式锁的线程，调用带超时参数的 Object.wait(long timeout) 方法；</span></li><li><span>调用带超时参数的 Thread.join(long millis) 方法；</span></li><li><span>调用带超时参数的 LockSupport.parkNanos(Object blocker, long deadline) 方法；</span></li><li><span>调用带超时参数的 LockSupport.parkUntil(long deadline) 方法。</span></li></ol><p><span>这里你会发现 TIMED_WAITING 和 WAITING 状态的区别，仅仅是触发条件多了超时参数。</span></p><p>&nbsp;</p><p><span>代码样例：</span></p><pre spellcheck="false" class="md-fences md-end-block ty-contain-cm modeLoaded" lang=""><div class="CodeMirror cm-s-inner CodeMirror-wrap" lang=""><div style="overflow: hidden; position: relative; width: 3px; height: 0px; top: 0px; left: 8px;"><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0" style="position: absolute; bottom: -1em; padding: 0px; width: 1000px; height: 1em; outline: none;"></textarea></div><div class="CodeMirror-scrollbar-filler" cm-not-content="true"></div><div class="CodeMirror-gutter-filler" cm-not-content="true"></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer" style="margin-left: 0px; margin-bottom: 0px; border-right-width: 0px; padding-right: 0px; padding-bottom: 0px;"><div style="position: relative; top: 0px;"><div class="CodeMirror-lines" role="presentation"><div role="presentation" style="position: relative; outline: none;"><div class="CodeMirror-measure"><pre><span>xxxxxxxxxx</span></pre></div><div class="CodeMirror-measure"></div><div style="position: relative; z-index: 1;"></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline" style="position: relative;"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter" style="left: 0px; width: 0px;"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">public void startThread() { &nbsp;  Thread t = new Thread(new Runnable() { &nbsp; &nbsp; &nbsp;  @Override &nbsp; &nbsp; &nbsp;  public void run() { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  System.out.println("开始执行线程..."); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  System.out.println("进入睡眠状态..."); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  try { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  Thread.sleep(3000); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; } catch (InterruptedException e) { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  e.printStackTrace(); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  } &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  System.out.println("线程结束..."); &nbsp; &nbsp; &nbsp;  } &nbsp;  }); &nbsp;  t.start();}</span></pre></div></div></div></div></div></div><div style="position: absolute; height: 0px; width: 1px; border-bottom: 0px solid transparent; top: 138px;"></div><div class="CodeMirror-gutters" style="display: none; height: 138px;"></div></div></div></pre><p>&nbsp;</p><p><span>5、RUNNABLE到TERMINATED 状态</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/55019800_1622350057.png" referrerpolicy="no-referrer" alt="img"></p><p><span>线程执行完 run() 方法后，会自动转换到 TERMINATED 状态，当然如果执行 run() 方法的时候异常抛出，也会导致线程终止。</span></p><p>&nbsp;</p><p><span>如果需要强制中断 run() 方法的执行，则调用 interrupt() 方法。interrupt() 方法仅仅是通知线程，让线程有机会执行一些后续操作，同时也可以无视这个通知。</span></p><p>&nbsp;</p><p><span>我们为了验证线程run()后，会自动转到terminated状态，所以，使用thread.getState()方法来获取“线程状态”。</span></p><p>&nbsp;</p><p><span>代码样例：</span></p><pre spellcheck="false" class="md-fences md-end-block ty-contain-cm modeLoaded" lang=""><div class="CodeMirror cm-s-inner CodeMirror-wrap" lang=""><div style="overflow: hidden; position: relative; width: 3px; height: 0px; top: 0px; left: 8px;"><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0" style="position: absolute; bottom: -1em; padding: 0px; width: 1000px; height: 1em; outline: none;"></textarea></div><div class="CodeMirror-scrollbar-filler" cm-not-content="true"></div><div class="CodeMirror-gutter-filler" cm-not-content="true"></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer" style="margin-left: 0px; margin-bottom: 0px; border-right-width: 0px; padding-right: 0px; padding-bottom: 0px;"><div style="position: relative; top: 0px;"><div class="CodeMirror-lines" role="presentation"><div role="presentation" style="position: relative; outline: none;"><div class="CodeMirror-measure"><pre><span>xxxxxxxxxx</span></pre></div><div class="CodeMirror-measure"></div><div style="position: relative; z-index: 1;"></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline" style="position: relative;"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter" style="left: 0px; width: 0px;"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">public class ThreadTerminatedState implements Runnable { &nbsp;  public static void main(String[] args) { &nbsp; &nbsp; &nbsp;  Thread thread = new Thread(new ThreadTerminatedState()); &nbsp; &nbsp; &nbsp;  //NEW &nbsp; &nbsp; &nbsp; &nbsp; System.out.println( thread.getState()); &nbsp; &nbsp; &nbsp;  thread.start(); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  //RUNNABLE &nbsp; &nbsp; &nbsp; &nbsp; System.out.println( thread.getState()); &nbsp; &nbsp; &nbsp;  try { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  Thread.sleep(1000); &nbsp; &nbsp; &nbsp;  } catch (InterruptedException e) { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  e.printStackTrace(); &nbsp; &nbsp; &nbsp;  } &nbsp; &nbsp; &nbsp;  //TERMINATED &nbsp; &nbsp; &nbsp;  System.out.println( thread.getState()); &nbsp;  } &nbsp;  @Override &nbsp;  public void run() { &nbsp; &nbsp; &nbsp;  for (int i = 0; i &lt; 10000; i++) { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  System.out.println(i); &nbsp; &nbsp; &nbsp;  } &nbsp;  }}</span></pre></div></div></div></div></div></div><div style="position: absolute; height: 0px; width: 1px; border-bottom: 0px solid transparent; top: 184px;"></div><div class="CodeMirror-gutters" style="display: none; height: 184px;"></div></div></div></pre><p>&nbsp;</p><p><span>以上代码输出如下结果：</span></p><p><span>NEW</span></p><p><span>RUNNABLE</span></p><p><span>0</span></p><p><span>1</span></p><p><span>2</span></p><p><span>.....略</span></p><p><span>TERMINATED</span></p><p>&nbsp;</p><h4><a name="五总结-n474" class="md-header-anchor"></a><span>五、总结</span></h4><p><span>好了，本小节到此就结束了，谢谢阅读，现在大家知道了线程在执行过程中的状态是如何流转了的吧，记住文章最开头的线程6种状态的脑图，面试被问到类似问题时不再迷路！</span></p><p>&nbsp;</p><h3><a name="07技术挑战如何解决百万交易系统转账过程中循环等待性能太差的问题" class="md-header-anchor"></a><strong><span>07_技术挑战：如何解决百万交易系统转账过程中循环等待，性能太差的问题？</span></strong></h3><h4><a name="一问题描述" class="md-header-anchor"></a><strong><span>一、问题描述</span></strong><span> </span></h4><p><span>在很多互联网公司的交易系统中，会出现这种场景，【账户A】转账给【账户B】，同时【账户B】也转账给【账户A】，两个账户都需要锁住余额，所以通常会申请两把锁。转账时，先锁住自己的账户，并获取对方的锁，保证同一时刻只能由一个线程去执行转账。</span></p><p>&nbsp;</p><p><span>这时可能就会出现，对方给我转账，同时我也给对方转账，那么双方都持有自己的锁，且尝试去获取对方的锁，这就造成可能一直申请不到对方的锁，循环等待发生“死锁”的问题！</span></p><p>&nbsp;</p><p><span>试想在互联网支付盛行的当下，如果系统中出现线程循环等待的情况，用户体验肯定是极差的。</span></p><p>&nbsp;</p><h4><a name="二什么是死锁" class="md-header-anchor"></a><span>二、什么是死锁</span></h4><p><span>我们先了解下什么是“死锁”？</span></p><p><span>“死锁” 是两个或两个以上的线程在执行过程中，互相持有对方所需要的资源，导致这些线程处于等待状态，无法继续执行。若无外力作用，它们都将无法推进下去，就进入了“永久”阻塞的状态。</span></p><p>&nbsp;</p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/69882800_1622350708.png" referrerpolicy="no-referrer" alt="img"></p><p><span>如上图所示：线程01获得了账户A的锁，且同时去尝试获取账户B的锁；但是，线程02已经获得了账户B的锁，所以，线程01只能等待。同样，线程02也无法获得账户A的锁（已被线程01获取），只能等待。于是，线程01和线程02都在等待对方持有的锁，且会无限期的等待下去，这就是我们所说的“死锁”了！</span></p><p>&nbsp;</p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/98667900_1622350708.png" referrerpolicy="no-referrer" alt="img"></p><p>&nbsp;</p><p>&nbsp;</p><h4><a name="三死锁代码" class="md-header-anchor"></a><span>三、死锁代码</span></h4><p><span>下面，我们来看下一个简单的会引起死锁的代码：</span></p><p>&nbsp;</p><pre spellcheck="false" class="md-fences md-end-block ty-contain-cm modeLoaded" lang=""><div class="CodeMirror cm-s-inner CodeMirror-wrap" lang=""><div style="overflow: hidden; position: relative; width: 3px; height: 0px; top: 0px; left: 8px;"><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0" style="position: absolute; bottom: -1em; padding: 0px; width: 1000px; height: 1em; outline: none;"></textarea></div><div class="CodeMirror-scrollbar-filler" cm-not-content="true"></div><div class="CodeMirror-gutter-filler" cm-not-content="true"></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer" style="margin-left: 0px; margin-bottom: 0px; border-right-width: 0px; padding-right: 0px; padding-bottom: 0px;"><div style="position: relative; top: 0px;"><div class="CodeMirror-lines" role="presentation"><div role="presentation" style="position: relative; outline: none;"><div class="CodeMirror-measure"><pre><span>xxxxxxxxxx</span></pre></div><div class="CodeMirror-measure"></div><div style="position: relative; z-index: 1;"></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline" style="position: relative;"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter" style="left: 0px; width: 0px;"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">public class DeadLock { &nbsp;  public static String obj1 = "obj1"; &nbsp;  public static String obj2 = "obj2"; &nbsp;  public static void main(String[] args) { &nbsp; &nbsp; &nbsp;  Thread a = new Thread(new Lock1()); &nbsp; &nbsp; &nbsp;  Thread b = new Thread(new Lock2()); &nbsp; &nbsp; &nbsp;  a.start(); &nbsp; &nbsp; &nbsp;  b.start(); &nbsp;  }}</span></pre></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">class Lock1 implements Runnable { &nbsp;  @Override &nbsp;  public void run() { &nbsp; &nbsp; &nbsp;  try { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  System.out.println("Lock1 running"); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  while (true) { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  synchronized (DeadLock.obj1) { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  System.out.println("Lock1 lock obj1"); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  Thread.sleep(3000); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  synchronized (DeadLock.obj2) { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  System.out.println("Lock1 lock obj2"); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  } &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  } &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  } &nbsp; &nbsp; &nbsp;  } catch (Exception e) { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  e.printStackTrace(); &nbsp; &nbsp; &nbsp;  } &nbsp;  }}</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">class Lock2 implements Runnable { &nbsp;  @Override &nbsp;  public void run() { &nbsp; &nbsp; &nbsp;  try { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  System.out.println("Lock2 running"); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  while (true) { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  synchronized (DeadLock.obj2) { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  System.out.println("Lock2 lock obj2"); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  Thread.sleep(3000); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  synchronized (DeadLock.obj1) { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  System.out.println("Lock2 lock obj1"); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  } &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  } &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  } &nbsp; &nbsp; &nbsp;  } catch (Exception e) { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  e.printStackTrace(); &nbsp; &nbsp; &nbsp;  } &nbsp;  }}</span></pre></div></div></div></div></div><div style="position: absolute; height: 0px; width: 1px; border-bottom: 0px solid transparent; top: 414px;"></div><div class="CodeMirror-gutters" style="display: none; height: 414px;"></div></div></div></pre><p>&nbsp;</p><p><span>将上述代码复制到java编译器中执行，得到下面的结果：</span></p><pre spellcheck="false" class="md-fences md-end-block ty-contain-cm modeLoaded" lang=""><div class="CodeMirror cm-s-inner CodeMirror-wrap" lang=""><div style="overflow: hidden; position: relative; width: 3px; height: 0px; top: 0px; left: 8px;"><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0" style="position: absolute; bottom: -1em; padding: 0px; width: 1000px; height: 1em; outline: none;"></textarea></div><div class="CodeMirror-scrollbar-filler" cm-not-content="true"></div><div class="CodeMirror-gutter-filler" cm-not-content="true"></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer" style="margin-left: 0px; margin-bottom: 0px; border-right-width: 0px; padding-right: 0px; padding-bottom: 0px;"><div style="position: relative; top: 0px;"><div class="CodeMirror-lines" role="presentation"><div role="presentation" style="position: relative; outline: none;"><div class="CodeMirror-measure"><pre><span>xxxxxxxxxx</span></pre></div><div class="CodeMirror-measure"></div><div style="position: relative; z-index: 1;"></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline" style="position: relative;"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter" style="left: 0px; width: 0px;"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">Lock1 runningLock1 lock obj1Lock2 runningLock2 lock obj2</span></pre></div></div></div></div></div></div><div style="position: absolute; height: 0px; width: 1px; border-bottom: 0px solid transparent; top: 23px;"></div><div class="CodeMirror-gutters" style="display: none; height: 23px;"></div></div></div></pre><p>&nbsp;</p><p><span>并没有打印 Lock1 lock obj2，和Lock1 lock obj2，线程发生死锁了。</span></p><p>&nbsp;</p><h4><a name="四死锁产生的原因" class="md-header-anchor"></a><span>四、死锁产生的原因</span></h4><p><span>虽然进程在运行过程中，可能发生死锁，但死锁的发生也必须具备一定的条件，死锁的发生必须具备以下四个必要条件：</span></p><ul><li><span>互斥，共享资源 X 和 Y 只能被一个线程占用；</span></li><li><span>占有且等待，线程01 已经取得共享资源 X，在等待共享资源 Y 的时候，不释放共享资源 X；</span></li><li><span>不可抢占，其他线程不能强行抢占线程01 占有的资源；</span></li><li><span>循环等待，线程01 等待线程02 占有的资源，线程02 等待线程01 占有的资源，就是循环等待。</span></li></ul><p>&nbsp;</p><h4><a name="五如何避免死锁" class="md-header-anchor"></a><span>五、如何避免死锁</span></h4><p><span>应用程序一旦发生死锁，并没有什么特别好的办法解决，通常情况下，我们只能重启系统。因此，解决死锁的最好的办法就是避免死锁。</span></p><p>&nbsp;</p><p><span>如何避免死锁发生呢？</span></p><p>&nbsp;</p><p><span>上面7.3节已经讲过了死锁产生的原因，所以，我们只要避免上述情况发生，就能规避死锁。</span></p><p>&nbsp;</p><ol start='' ><li><span>首先，“互斥”是没有办法避免的，对于“占用且等待”这个条件，我们可以一次性申请所有的资源，这样就不存在等待了。</span></li><li><span>对于“不可抢占”这个条件，占用部分资源的线程进一步申请其他资源时，如果申请不到，可以在一定时间后，主动释放它占有的资源，这样就解决了不可抢占这个条件。</span></li><li><span>对于“循环等待”，我们可以靠按“次序”申请资源来预防。所谓按序申请，就是给资源设定顺序，申请的时候可以先申请序号小的资源，再申请序号大的，这样资源线性化后，自然就不存在循环等待了。</span></li></ol><p><span>我们已经从理论上解决了如何避免死锁，那我们从代码上举几个例子来实践下这些理论。</span></p><p><span>1、 破坏占用且等待条件</span></p><p><span>我们要破坏占用且等待，就是一次性申请占有所有的资源，我们拿文章开头的【账户A】、【账户B】来举例，就是一次性申请账户A，账户B的锁，当线程01拿到账户A、B全部的锁后，再执行具体的操作。</span></p><pre spellcheck="false" class="md-fences md-end-block ty-contain-cm modeLoaded" lang=""><div class="CodeMirror cm-s-inner CodeMirror-wrap" lang=""><div style="overflow: hidden; position: relative; width: 3px; height: 0px; top: 0px; left: 8px;"><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0" style="position: absolute; bottom: -1em; padding: 0px; width: 1000px; height: 1em; outline: none;"></textarea></div><div class="CodeMirror-scrollbar-filler" cm-not-content="true"></div><div class="CodeMirror-gutter-filler" cm-not-content="true"></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer" style="margin-left: 0px; margin-bottom: 0px; border-right-width: 0px; padding-right: 0px; padding-bottom: 0px;"><div style="position: relative; top: 0px;"><div class="CodeMirror-lines" role="presentation"><div role="presentation" style="position: relative; outline: none;"><div class="CodeMirror-measure"><pre><span>xxxxxxxxxx</span></pre></div><div class="CodeMirror-measure"></div><div style="position: relative; z-index: 1;"></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline" style="position: relative;"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter" style="left: 0px; width: 0px;"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">public class DeadLock02 { &nbsp;  public static void main(String[] args) { &nbsp; &nbsp; &nbsp;  Account a = new Account(); &nbsp; &nbsp; &nbsp;  Account b = new Account(); &nbsp; &nbsp; &nbsp;  a.transfer(b,100); &nbsp; &nbsp; &nbsp;  b.transfer(a,200); &nbsp;  }</span></pre></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> static class Allocator { &nbsp; &nbsp; &nbsp;  private List&lt;Object&gt; als = new ArrayList&lt;Object&gt;(); &nbsp; &nbsp; &nbsp;  // 一次性申请所有资源 &nbsp; &nbsp; &nbsp;  synchronized boolean apply(Object from, Object to){ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  if(als.contains(from) || als.contains(to)){ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  return false; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  } else { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  als.add(from); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  als.add(to); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  } &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  return true; &nbsp; &nbsp; &nbsp;  } &nbsp; &nbsp; &nbsp;  synchronized void clean(Object from, Object to){ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  als.remove(from); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  als.remove(to); &nbsp; &nbsp; &nbsp;  } &nbsp;  }</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> static class Account { &nbsp; &nbsp; &nbsp;  private Allocator actr = DeadLock02.getInstance(); &nbsp; &nbsp; &nbsp;  private int balance; &nbsp; &nbsp; &nbsp;  void transfer(Account target, int amt){ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  while(!actr.apply(this, target)); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  try{ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  synchronized(this){ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  System.out.println(this.toString()+" lock obj1"); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  synchronized(target){ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  System.out.println(this.toString()+" lock obj2"); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  if (this.balance &gt; amt){ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  this.balance -= amt; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  target.balance += amt; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  } &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  } &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  } &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  } finally { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  //执行完后，再释放持有的资源 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  actr.clean(this, target); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  } &nbsp; &nbsp; &nbsp;  } &nbsp;  }</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">private void Allocator(){}; &nbsp;  private static class SingleTonHoler{ &nbsp; &nbsp; &nbsp;  private static Allocator INSTANCE = new Allocator(); &nbsp;  } &nbsp;  public static Allocator getInstance(){ &nbsp; &nbsp; &nbsp;  return SingleTonHoler.INSTANCE; &nbsp;  }}</span></pre></div></div></div></div></div><div style="position: absolute; height: 0px; width: 1px; border-bottom: 0px solid transparent; top: 483px;"></div><div class="CodeMirror-gutters" style="display: none; height: 483px;"></div></div></div></pre><p><span>得到的结果</span></p><p><span>Account@3cd1f1c8 lock obj1</span></p><p><span>Account@3cd1f1c8 lock obj2</span></p><p><span>Account@3a4afd6d lock obj1</span></p><p><span>Account@3a4afd6d lock obj2</span></p><p>&nbsp;</p><p><span>2、 破坏不可抢占条件</span></p><p>&nbsp;</p><p><span>破坏不抢占条件，需要发生死锁的线程能够主动释放它占有的资源，但使用synchronized是做不到的。原因为synchronized申请不到资源时，线程直接进入了阻塞状态，而线程进入了阻塞状态也就没有办法释放它占有的资源了。</span></p><p><span>不过JDK中的java.util.concurrent提供了Lock解决这个问题。</span></p><p><span>显式使用Lock类中的定时tryLock功能来代替内置锁机制，可以检测死锁和从死锁中恢复过来。使用内置锁的线程获取不到锁会被阻塞，而显式锁可以指定一个超时时限（Timeout），在等待超过该时间后tryLock就会返回一个失败信息，也会释放其拥有的资源。</span></p><pre spellcheck="false" class="md-fences md-end-block ty-contain-cm modeLoaded" lang=""><div class="CodeMirror cm-s-inner CodeMirror-wrap" lang=""><div style="overflow: hidden; position: relative; width: 3px; height: 0px; top: 0px; left: 8px;"><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0" style="position: absolute; bottom: -1em; padding: 0px; width: 1000px; height: 1em; outline: none;"></textarea></div><div class="CodeMirror-scrollbar-filler" cm-not-content="true"></div><div class="CodeMirror-gutter-filler" cm-not-content="true"></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer" style="margin-left: 0px; margin-bottom: 0px; border-right-width: 0px; padding-right: 0px; padding-bottom: 0px;"><div style="position: relative; top: 0px;"><div class="CodeMirror-lines" role="presentation"><div role="presentation" style="position: relative; outline: none;"><div class="CodeMirror-measure"><pre><span>xxxxxxxxxx</span></pre></div><div class="CodeMirror-measure"></div><div style="position: relative; z-index: 1;"></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline" style="position: relative;"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter" style="left: 0px; width: 0px;"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">public class DeadLock { &nbsp;  public static ReentrantLock lock1 = new ReentrantLock(); &nbsp;  public static ReentrantLock lock2 = new ReentrantLock(); &nbsp;  public static void main(String[] args) { &nbsp; &nbsp; &nbsp;  Thread a = new Thread(new Lock1()); &nbsp; &nbsp; &nbsp;  Thread b = new Thread(new Lock2()); &nbsp; &nbsp; &nbsp;  a.start(); &nbsp; &nbsp; &nbsp;  b.start(); &nbsp;  } &nbsp;  static class Lock1 implements Runnable { &nbsp; &nbsp; &nbsp;  @Override &nbsp; &nbsp; &nbsp;  public void run() { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  try { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  System.out.println("Lock1 running"); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  while (true) { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  if (lock1.tryLock(1, TimeUnit.MILLISECONDS)) { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  System.out.println("Lock1 lock obj1"); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  //Thread.sleep(3000); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  if (lock2.tryLock(1, TimeUnit.MILLISECONDS)) { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  System.out.println("Lock1 lock obj2"); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  } &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  } &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  } &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  } catch (Exception e) { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  e.printStackTrace(); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  } finally { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  lock1.unlock(); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  lock2.unlock(); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  } &nbsp; &nbsp; &nbsp;  } &nbsp;  }</span></pre></div></div></div></div></div></div><div style="position: absolute; height: 0px; width: 1px; border-bottom: 0px solid transparent; top: 299px;"></div><div class="CodeMirror-gutters" style="display: none; height: 299px;"></div></div></div></pre><h4><a name="-n547" class="md-header-anchor"></a><span> </span></h4><p><span>3、破坏循环等待条件</span></p><p><span>破坏这个条件，只需要对系统中的资源进行统一编号，进程可在任何时刻提出资源申请，必须按照资源的编号顺序提出。这样做就能保证系统不出现死锁。这就是“资源有序分配法”。</span></p><pre spellcheck="false" class="md-fences md-end-block ty-contain-cm modeLoaded" lang=""><div class="CodeMirror cm-s-inner CodeMirror-wrap" lang=""><div style="overflow: hidden; position: relative; width: 3px; height: 0px; top: 0px; left: 8px;"><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0" style="position: absolute; bottom: -1em; padding: 0px; width: 1000px; height: 1em; outline: none;"></textarea></div><div class="CodeMirror-scrollbar-filler" cm-not-content="true"></div><div class="CodeMirror-gutter-filler" cm-not-content="true"></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer" style="margin-left: 0px; margin-bottom: 0px; border-right-width: 0px; padding-right: 0px; padding-bottom: 0px;"><div style="position: relative; top: 0px;"><div class="CodeMirror-lines" role="presentation"><div role="presentation" style="position: relative; outline: none;"><div class="CodeMirror-measure"><pre><span>xxxxxxxxxx</span></pre></div><div class="CodeMirror-measure"></div><div style="position: relative; z-index: 1;"></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline" style="position: relative;"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter" style="left: 0px; width: 0px;"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">class Account { &nbsp;  private int id; &nbsp;  private int balance; &nbsp;  void transfer(Account target, int amt){ &nbsp; &nbsp; &nbsp;  Account left = this; &nbsp; &nbsp; &nbsp;  Account right = target; &nbsp; &nbsp; &nbsp;  if (this.id &gt; target.id) { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  left = target; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  right = this; &nbsp; &nbsp; &nbsp;  } &nbsp; &nbsp; &nbsp;  synchronized(left){ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  synchronized(right){ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  if (this.balance &gt; amt){ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  this.balance -= amt; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  target.balance += amt; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  } &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  } &nbsp; &nbsp; &nbsp;  } &nbsp;  }}</span></pre></div></div></div></div></div></div><div style="position: absolute; height: 0px; width: 1px; border-bottom: 0px solid transparent; top: 138px;"></div><div class="CodeMirror-gutters" style="display: none; height: 138px;"></div></div></div></pre><h4><a name="-n551" class="md-header-anchor"></a><span> </span></h4><h4><a name="六总结-n552" class="md-header-anchor"></a><span>六、总结</span></h4><p>&nbsp;</p><p><span>让我们最后再回顾下今天学习的内容，你是否对死锁有了相对透彻的理解呢？</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/34121200_1622350709.png" referrerpolicy="no-referrer" alt="img"></p><p>&nbsp;</p><p>&nbsp;</p><h3><a name="08性能优化基于guarded-suspension模式优化百万交易系统" class="md-header-anchor"></a><strong><span>08_性能优化：基于Guarded Suspension模式，优化百万交易系统</span></strong></h3><h4><a name="一-guarded-suspension模式简介" class="md-header-anchor"></a><strong><span>一、 Guarded Suspension模式简介</span></strong><span> </span></h4><p><span>guarded在这里是“保护”的意思；suspension在这里是“暂时挂起”的意思。所以，Guarded Suspension模式又称为“保护性暂挂模式”；</span></p><p>&nbsp;</p><p><span>在多线程开发中，常常为了提高应用程序的并发性，会将一个任务分解为多个子任务交给多个线程并行执行，而多个线程之间相互协作时，仍然会存在一个线程需要等待另外的线程完成后继续下一步操作。而Guarded Suspension模式可以帮助我们解决上述的等待问题。</span></p><p>&nbsp;</p><p><span>还是用交易系统的“转账”场景来讲述这个模式的实现。在上一篇文章中，我们提到，【账户A】转账给【账户B】，线程01需要持有账户A的锁，同时也需要持有账户B的锁，如果线程01拿不到两个锁，则进行while(!actr.apply(this, target))死循环的方式来循环等待，直到一次全部获取到两个锁后，才进行后面的转账操作。</span></p><p>&nbsp;</p><p><span>在并发量不大的情况下，这种方案还是可以接受的，但是一旦并发量增大，获取锁的冲突增加的时候，这种方案就不适合了，因为在这种场景下，可能要循环上万次才能获得锁，非常消耗性能，互联网高并发下显然不适合。</span></p><p><span>在这种场景下，最好的方案就是使用Guarded Suspension模式，如果线程01拿不到所有的锁，就阻塞自己，进入“等待WAITING”状态。当线程01要求的所有条件都满足后，“通知”等待状态的线程01重新执行。</span></p><h4><a name="二看牙医的就诊流程" class="md-header-anchor"></a><span>二、看牙医的就诊流程</span></h4><p><span>在讲述“等待-通知”机制之前，我以周末看牙医的就诊流程举例，因为它有完善的“等待-通知”机制。通过这个流程，我们可以更好的理解Guarded Suspension模式的“等待-通知”机制。</span></p><p>&nbsp;</p><p><span>牙医的就诊流程大致是这样的：</span></p><p><span>如下图所示：</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/29817400_1622351187.png" referrerpolicy="no-referrer" alt="img"></p><ol start='' ><li><span>患者到了医院后，先去挂牙科号，然后到牙科门诊分诊，等待叫号；</span></li><li><span>当叫到自己的号时，患者就可以找医生就诊了；</span></li><li><span>当医生检查完成后，会开治疗费缴费单，患者去交费，同时叫下一位患者；</span></li><li><span>当患者交完费后，拿缴费单重新分诊，等待叫号；</span></li><li><span>当护士再次叫到自己的号时，患者再去找大夫进行治疗。（等待-通知）</span></li></ol><p><span>大家看完我这个看牙医的案例，应该了解到“等待 - 通知”机制的就医流程，不仅能够保证同一时刻，一个牙医大夫只为一个患者服务，而且还能够保证大夫和患者的就医效率。</span></p><p><span>患者挂完号到就诊室门口等待分诊，类似于线程要去获取互斥锁；当患者被叫到号时，类似线程已经获取到锁了。</span></p><p><span>大夫检查完让患者去缴费（牙科不缴费不治疗），类似于线程要求的条件没有满足。患者去缴费时，类似于线程进入等待状态；</span></p><p><span>然后大夫叫下一个患者，类似线程释放持有的互斥锁。</span></p><p><span>患者交完费，类似于线程要求的条件已经满足；患者拿缴费单重新等待分诊，类似于线程需要重新获取互斥锁。</span></p><p><span>综合以上流程，就可以得出一个完整的等待 - 通知机制：线程首先获取互斥锁，当线程要求的条件不满足时，释放互斥锁，进入等待状态；当要求的条件满足时，通知等待的线程，重新获取互斥锁。</span></p><h4><a name="-n591" class="md-header-anchor"></a><span> </span></h4><h4><a name="三代码举例" class="md-header-anchor"></a><span>三、代码举例</span></h4><p><span>下面我们写一段代码来描述这段“等待-通知”机制：</span></p><h4><a name="类图" class="md-header-anchor"></a><span>类图</span></h4><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/52160000_1622351187.png" referrerpolicy="no-referrer" alt="img"></p><p><span>1、 创建GuardedQueue类</span></p><pre spellcheck="false" class="md-fences md-end-block ty-contain-cm modeLoaded" lang=""><div class="CodeMirror cm-s-inner CodeMirror-wrap" lang=""><div style="overflow: hidden; position: relative; width: 3px; height: 0px; top: 0px; left: 8px;"><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0" style="position: absolute; bottom: -1em; padding: 0px; width: 1000px; height: 1em; outline: none;"></textarea></div><div class="CodeMirror-scrollbar-filler" cm-not-content="true"></div><div class="CodeMirror-gutter-filler" cm-not-content="true"></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer" style="margin-left: 0px; margin-bottom: 0px; border-right-width: 0px; padding-right: 0px; padding-bottom: 0px;"><div style="position: relative; top: 0px;"><div class="CodeMirror-lines" role="presentation"><div role="presentation" style="position: relative; outline: none;"><div class="CodeMirror-measure"><pre><span>xxxxxxxxxx</span></pre></div><div class="CodeMirror-measure"></div><div style="position: relative; z-index: 1;"></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline" style="position: relative;"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter" style="left: 0px; width: 0px;"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">public class GuardedQueue { &nbsp;  private final Queue&lt;Integer&gt; sourceList; &nbsp;  public GuardedQueue() { &nbsp; &nbsp; &nbsp;  this.sourceList = new LinkedBlockingQueue&lt;&gt;(); &nbsp;  } &nbsp; &nbsp; &nbsp;  public synchronized Integer get() { &nbsp; &nbsp; &nbsp;  while (sourceList.isEmpty()) { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  try { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  wait(); &nbsp;  // &lt;--- 如果队列为null，等待 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  } catch (InterruptedException e) { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  e.printStackTrace(); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  } &nbsp; &nbsp; &nbsp;  } &nbsp; &nbsp; &nbsp;  return sourceList.peek(); &nbsp;  } &nbsp; &nbsp; &nbsp;  public synchronized void put(Integer e) { &nbsp; &nbsp; &nbsp;  sourceList.add(e); &nbsp; &nbsp; &nbsp;  notifyAll();  //&lt;--- 通知，继续执行 &nbsp;  }}</span></pre></div></div></div></div></div></div><div style="position: absolute; height: 0px; width: 1px; border-bottom: 0px solid transparent; top: 161px;"></div><div class="CodeMirror-gutters" style="display: none; height: 161px;"></div></div></div></pre><p>&nbsp;</p><p><span>2、测试一下</span></p><pre spellcheck="false" class="md-fences md-end-block ty-contain-cm modeLoaded" lang=""><div class="CodeMirror cm-s-inner CodeMirror-wrap" lang=""><div style="overflow: hidden; position: relative; width: 3px; height: 0px; top: 0px; left: 8px;"><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0" style="position: absolute; bottom: -1em; padding: 0px; width: 1000px; height: 1em; outline: none;"></textarea></div><div class="CodeMirror-scrollbar-filler" cm-not-content="true"></div><div class="CodeMirror-gutter-filler" cm-not-content="true"></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer" style="margin-left: 0px; margin-bottom: 0px; border-right-width: 0px; padding-right: 0px; padding-bottom: 0px;"><div style="position: relative; top: 0px;"><div class="CodeMirror-lines" role="presentation"><div role="presentation" style="position: relative; outline: none;"><div class="CodeMirror-measure"><pre><span>xxxxxxxxxx</span></pre></div><div class="CodeMirror-measure"></div><div style="position: relative; z-index: 1;"></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline" style="position: relative;"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter" style="left: 0px; width: 0px;"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">public class App { &nbsp;  public static void main(String[] args) { &nbsp; &nbsp; &nbsp;  GuardedQueue guardedQueue = new GuardedQueue(); &nbsp; &nbsp; &nbsp;  ExecutorService executorService = Executors.newFixedThreadPool(3); &nbsp; &nbsp; &nbsp;  executorService.execute(() -&gt; { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  guardedQueue.get(); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  } &nbsp; &nbsp; &nbsp;  ); &nbsp; &nbsp; &nbsp;  Thread.sleep(2000); &nbsp; &nbsp; &nbsp;  executorService.execute(() -&gt; { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  guardedQueue.put(20); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  } &nbsp; &nbsp; &nbsp;  ); &nbsp; &nbsp; &nbsp;  executorService.shutdown(); &nbsp; &nbsp; &nbsp;  executorService.awaitTermination(30, TimeUnit.SECONDS); &nbsp;  }}</span></pre></div></div></div></div></div></div><div style="position: absolute; height: 0px; width: 1px; border-bottom: 0px solid transparent; top: 161px;"></div><div class="CodeMirror-gutters" style="display: none; height: 161px;"></div></div></div></pre><h4><a name="-n601" class="md-header-anchor"></a><span> </span></h4><h4><a name="四总结与拓展" class="md-header-anchor"></a><span>四、总结与拓展</span></h4><p><span>Guarded Suspension模式的“等待-通知”机制是一种非常普遍的线程间协作的方式。我们在平时工作中经常看到有同学使用“轮询while(true)”的方式来等待某个状态，其实都可以用这个“等待-通知”机制来优化。</span></p><p>&nbsp;</p><p><span>另外，有同学可能会问为什么不用notify() 来实现通知机制呢？</span></p><p><span>Notify()和notifyAll()这两者是有区别的，notify() 是会随机地通知等待队列中的任意一个线程，而 notifyAll() 会通知等待队列中的所有线程。</span></p><p>&nbsp;</p><p><span>觉得 notify() 会更好一些的同学可能认为即便通知所有线程，也只有一个线程能够进入临界区。但是实际上使用 notify() 也很有风险，因为随机通知等待的线程，可能会导致某些线程永远不会被通知到。</span></p><p><span>所以除非经过深思熟虑，否则尽量使用 notifyAll()。</span></p><p>&nbsp;</p><h3><a name="09案例实战实现智能安防系统的报警功能一）" class="md-header-anchor"></a><strong><span>09_案例实战：实现智能安防系统的报警功能（一）</span></strong></h3><h4><a name="一章节回顾" class="md-header-anchor"></a><span>一、章节回顾</span></h4><p>&nbsp;</p><p><span>前面几篇文章讲解了多线程的几个模式和概念，这一篇文章开始，我们进入实战环节，讲述“智能安防系统报警”功能实现。</span></p><p>&nbsp;</p><p>&nbsp;</p><p><span>智能安防系统一般有下面这些产品组成：</span></p><p><span>1、智能门锁</span></p><p><span>2、监控摄像头</span></p><p><span>3、门磁、人体探测器</span></p><p><span>4、烟雾报警器、燃气探测器</span></p><p>&nbsp;</p><p><span>这些产品都需要报警功能，一旦监察到异常，就会向报警中心服务器上传报警信息，然后由报警中心程序通知对应的人员或者系统进行处理。</span></p><p>&nbsp;</p><h4><a name="二案例实战" class="md-header-anchor"></a><span>二、案例实战</span></h4><p><span>所以，这一讲，我们先实现以下几个最重要的功能：</span></p><ol start='' ><li><span>建立连接，确保报警模块和报警服务器连接建立</span></li><li><span>检查心跳，定时调度来检查和报警服务器的连接状态是否正常</span></li><li><span>重新连接，报警模块和报警中心失去连接后，重新建立连接</span></li><li><span>发送报警，发送报警信息给报警服务器（当还未建立连接的时候同步阻塞等待）</span></li></ol><p>&nbsp;</p><p><span>如下图所示：</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/59458300_1622351813.png" referrerpolicy="no-referrer" alt="img"></p><p>&nbsp;</p><p><span>我们先画个类图：</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/75240000_1622351813.png" referrerpolicy="no-referrer" alt="img"></p><p><span>init: 初始化报警服务，和报警服务器建立连接，并定时发送心跳信息</span></p><p><span>sendAlarm：发送报警信息给服务器</span></p><p><span>onConneted: 和报警中心建立连接</span></p><p><span>reConnected: 重新和报警中心建立连接</span></p><p><span>onDisconnected: 断开和报警中心的连接</span></p><p>&nbsp;</p><h4><a name="三代码编写" class="md-header-anchor"></a><span>三、代码编写</span></h4><p><span>我们下面一步一步来实现上面的功能：</span></p><p><span>1、 init初始化报警服务</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/97746600_1622351813.png" referrerpolicy="no-referrer" alt="img"></p><p><span>我们启动报警系统的客户端程序后，先会初始化报警服务，主要有两个步骤：</span></p><ol start='' ><li><span>new ConnectingTask()与报警中心服务器建立连接</span></li><li><span>new HeartbeatTask()心跳检查，新建定时调度线程，每隔n秒去检查一次连接</span></li></ol><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/24138300_1622351814.png" referrerpolicy="no-referrer" alt="img"></p><p><span>2、onConnected方法建立连接</span></p><p><span>通过blocker去唤醒一个线程，与告警中心服务器建立连接。</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/48948500_1622351814.png" referrerpolicy="no-referrer" alt="img"></p><p>&nbsp;</p><p><span>3、HeartbeatTask心跳检查</span></p><p>&nbsp;</p><p><span>建立定时器，并每隔5秒发送一次心跳检查，如果与告警中心服务器的连接断开，则重新建立连接。</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/71139600_1622351814.png" referrerpolicy="no-referrer" alt="img"></p><p>&nbsp;</p><p><span>4、tesConnection测试是否连接正常</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/87987500_1622351814.png" referrerpolicy="no-referrer" alt="img"></p><p><span>5、 onDisconnected断开连接</span></p><p><span>将connectedToServer设置为false，即可断开连接。</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/10019900_1622351815.png" referrerpolicy="no-referrer" alt="img"></p><p><span>6、 reConnected重新连接</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/32704800_1622351815.png" referrerpolicy="no-referrer" alt="img"></p><p><span>其实，在connectingTask.run()方法体里还是去执行的onConnected()方法建立与服务器的连接。</span></p><h4><a name="-n676" class="md-header-anchor"></a><span> </span></h4><h4><a name="四总结" class="md-header-anchor"></a><span>四、总结</span></h4><p>&nbsp;</p><p><span>好了，同学们，这一小节的功能就实现完了，下一小节我们将继续实现“上传报警系统给报警系统”，另外，如果当上传的过程中，报警系统和报警服务器还未连接的时候wait()同步等待流程。</span></p><p>&nbsp;</p><h3><a name="10案例实战实现智能安防系统的报警功能二）" class="md-header-anchor"></a><strong><span>10_案例实战：实现智能安防系统的报警功能（二）</span></strong></h3><h4><a name="一上节回顾-n682" class="md-header-anchor"></a><span>一、上节回顾</span></h4><p>&nbsp;</p><p><span>我们在上篇文章中讲了用代码实现报警系统和报警中心服务器之间(1)建立连接，然后(2)检查心跳，如果报警系统和报警服务器失去连接后(3)重新建立连接 的过程。</span></p><p>&nbsp;</p><h4><a name="二分析报警上报功能" class="md-header-anchor"></a><span>二、分析报警上报功能</span></h4><p><span>今天，我们在第一讲的基础上，使用代码实现下面的功能：</span></p><ol start='' ><li><span>上传信息，上传报警信息给报警中心服务器</span></li><li><span>同步等待，当报警系统和报警中心服务器还未建立连接的时候，wait()同步等待</span></li></ol><p><span>如图1所示：</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/56437600_1622361292.png" referrerpolicy="no-referrer" alt="img"></p><p><span>图1</span></p><h4><a name="三编写代码实现报警功能" class="md-header-anchor"></a><span>三、编写代码实现报警功能</span></h4><p>&nbsp;</p><p><span>1、sendAlarm发送报警信息</span></p><p><span>发送报警信息到报警中心服务器。</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/90526500_1622361292.png" referrerpolicy="no-referrer" alt="img"></p><ol start='' ><li><span>我们建立一个发送信息的GuardedAction</span></li><li><span>校验一个保护条件“是否与报警中心服务器建立连接”</span></li><li><span>如果已建立连接（保护性条件满足），则通过blocker执行目标方法guardedAction</span></li><li><span>执行guardedAction.call() 方法，继续执行doSendAlarm()方法，发送报警信息alarmInfo对象;</span></li><li><span>如果连接未建立（条件不满足）则线程await()，等待被唤醒;</span></li></ol><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/21737400_1622361293.png" referrerpolicy="no-referrer" alt="img"></p><p><span>保护性条件，如果初始化或者其他条件下，报警系统和报警中心服务器建立连接，或者断开连接，会修改connectedToServer这个volatile布尔变量。所以，如果connectedToServer为true，则报警系统会向报警中心服务器发送报警信息。</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/51739100_1622361293.png" referrerpolicy="no-referrer" alt="img"></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/81094300_1622361293.png" referrerpolicy="no-referrer" alt="img"></p><p>&nbsp;</p><p><span>2、wait()同步等待</span></p><p><span>如果连接未建立（条件不满足）则发送告警的消息线程会await()等待，直到被唤醒;</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/23785000_1622361294.png" referrerpolicy="no-referrer" alt="img"></p><p><span>那线程什么时候被唤醒呢？ 我们在上一小节的代码实现中，会发现onConnected()方法中，和告警服务器建立连接时，blocker对象会执行signalAfter方法</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/57770800_1622361294.png" referrerpolicy="no-referrer" alt="img"></p><p><span>而报警服务与报警中心服务器建立连接后，signalAfter的call方法中会将connectedToServer修改为true，所以，当条件满足时，condition.signal() 会将线程唤醒，继续执行发送告警消息的方法。</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/90918700_1622361294.png" referrerpolicy="no-referrer" alt="img"></p><p><span>正因为signalAfter的call方法中会将connectedToServer修改为true后，callWithGuard()方法的while (!predicate.evaluate()) 会成为false，终止while()，继续执行下面的guardedAction.call()方法；</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/21743000_1622361295.png" referrerpolicy="no-referrer" alt="img"></p><p><span>最后，执行call()方法，发送告警消息；</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/53462500_1622361295.png" referrerpolicy="no-referrer" alt="img"></p><p>&nbsp;</p><h4><a name="四总结-n729" class="md-header-anchor"></a><span>四、总结  </span></h4><p><span>本案例实战到此结束了，最后，我们再回顾下整个案例实战，实现的功能：</span></p><ol start='' ><li><span>init: 初始化报警服务，和报警服务器建立连接，并定时发送心跳信息</span></li><li><span>sendAlarm：发送报警信息给服务器</span></li><li><span>onConneted: 和报警中心建立连接</span></li><li><span>reConnected: 重新和报警中心建立连接</span></li><li><span>onDisconnected: 断开和报警中心的连接</span></li><li><span>ConnectingTask: 与报警服务器建立连接的线程</span></li><li><span>HeartbeatTask：心跳检查线程</span></li><li><span>callWithGuard：当条件满足时，发送消息，不满足，线程等待await()</span></li><li><span>signalAfter：当重新连接后，条件满足true，线程被唤醒，继续发送告警消息</span></li></ol><p>&nbsp;</p><p><span>经过“智能安防系统报警”功能实现，你是否对多线程Guarded Suspension模式有了更深刻的认识。下一篇文章，我们将继续讲解Guarded Suspension模式在并发源码中的应用场景，敬请期待！</span></p><p>&nbsp;</p><h3><a name="11源码分析guarded-suspension模式在blockingqueue源码中" class="md-header-anchor"></a><strong><span>11_源码分析：Guarded Suspension模式在BlockingQueue源码中</span></strong></h3><p><strong><span>一、上节回顾</span></strong></p><p><span>在第八篇文章中，我用看牙医的亲身经历举例，引出并讲解了Guarded Suspension “保护性暂挂模式”的运用。这种“保护性暂挂”模式可以大大降低多线程获取锁时锁冲突带来的性能开销，当线程在访问某个对象时，发现条件不满足，就暂时挂起等待条件满足时再访问。</span></p><p><span>如果线程01拿不到所有的锁，就阻塞自己，进入“等待WAITING”状态。当线程01要求的所有条件都满足后，通知等待状态的线程01继续执行。</span></p><p>&nbsp;</p><h4><a name="二案例分析" class="md-header-anchor"></a><span>二、案例分析</span></h4><p><span>我们再举一个例子回顾下：</span></p><p><span>我们开发一个这样的服务器，它可以处理来自多个客户端的请求（即Request）。为了不丢失客户端的请求，它要维护一个缓冲区，客户的请求会先储存至缓冲区中，而服务器会从缓冲区中取出请求并执行，如果缓冲区中没有请求，则服务器就等待，直到接收到通知有新的请求存入缓冲区中，服务器再重整旗鼓进行请求的执行。</span></p><p>&nbsp;</p><p><span>现在我们来看一段样例代码：</span></p><p><span>public class RequestQueue {</span></p><p><span>  private Queue</span><Request><span> queue = new ArrayBlockingQueue&lt;&gt;(MAX_LIMIT);</span>
<span>  ReentrantLock lock = new ReentrantLock();</span>
<span>  Condition condition = lock.newCondition();</span></p><p><span>  public Request get() {</span>
<span>    Request result = null;</span>
<span>    lock.lock();</span>
<span>    try {</span>
<span>      while (queue.isEmpty()) {</span>
<span>        condition.await();       }</span>
<span>      result = queue.poll();</span>
<span>      condition.signalAll();</span>
<span>    } catch (InterruptedException e) {</span>
<span>      condition.signalAll();</span>
<span>    } finally {</span>
<span>      lock.unlock();</span>
<span>    }</span>
<span>    return result;</span>
<span>  }</span></p><p><span>  public void put(Request request) {</span>
<span>    lock.lock();</span>
<span>    try {</span>
<span>      while (queue.size() &gt;= LIMIT) {</span>
<span>        condition.await();</span>
<span>      }</span>
<span>      queue.offer(request);</span>
<span>      condition.signalAll();     } catch (InterruptedException e) {</span>
<span>      condition.signalAll();</span>
<span>    } finally {</span>
<span>      lock.unlock();</span>
<span>    }</span>
<span>  }</span>
<span>}</span></p><h4><a name="-n767" class="md-header-anchor"></a><span> </span></h4><h4><a name="三源码分析" class="md-header-anchor"></a><span>三、源码分析</span></h4><p>&nbsp;</p><p><span>上面样例代码使用一个基于数组的阻塞队列ArrayBlockingQueue做为缓冲区，如果缓冲区中isEmpty()没有请求，则线程进入等待状态，直到缓冲区非空时被signalAll()唤醒。</span></p><p><span>BlockingQueue为阻塞队列，在某些情况下对阻塞队列的访问可能会造成阻塞。被阻塞的情况主要有如下两种：</span></p><ul><li><span>当队列满了的时候进行入队列操作</span></li><li><span>当队列空了的时候进行出队列操作</span></li></ul><p>&nbsp;</p><p><span>通俗一点讲，就是当一个线程试图对一个已经满了的队列进行入队列操作时，它将会被阻塞，除非有另一个线程做了出队列操作；同样，当一个线程试图对一个空队列进行出队列操作时，它将会被阻塞，除非有另一个线程进行了入队列操作。我们看到这里，是不是觉得似曾相识！是的，BlockingQueue源码里就用到了Guarded Suspension保护性暂挂模式。</span></p><p>&nbsp;</p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/88704100_1622361675.png" referrerpolicy="no-referrer" alt="img"></p><p><span>图1</span></p><p><span>如图1所示：ArrayBlockingQueue的父接口BlockingQueue接口位于JDK的java.util.concurrent 包中(Java5版本开始提供)，是线程安全的。</span></p><p>&nbsp;</p><p><span>BlockingQueue常用的操作包括 add，offer，put，remove，poll，take，peek。</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/15853700_1622361676.png" referrerpolicy="no-referrer" alt="img"></p><p><span>如下代码所示：</span></p><p><span>public interface BlockingQueue</span><E><span> extends Queue</span><E><span> {</span></p><p><span>  //将指定的元素插入到此队列的尾部（如果立即可行且不会超过该队列的容量）</span>
<span>  //插入成功时返回 true，如果此队列已满，则抛IllegalStateException。</span>
<span>  boolean add(E e);</span></p><p><span>  //将指定的元素插入到此队列的尾部（如果立即可行且不会超过该队列的容量）</span>
<span>  // 将指定的元素插入此队列的尾部，如果该队列已满，</span>
<span>  //则在到达指定的等待时间之前等待可用的空间,该方法可中断</span>
<span>  boolean offer(E e, long timeout, TimeUnit unit) throws InterruptedException;</span></p><p><span>  //将指定的元素插入此队列的尾部，如果该队列已满，则一直等到（阻塞）。    void put(E e) throws InterruptedException;</span></p><p><span>  //获取并移除此队列的头部，如果没有元素则等待（阻塞），</span>
<span>  //直到有元素将唤醒等待线程执行该操作    E take() throws InterruptedException;</span></p><p><span>  //获取并移除此队列的头部，在指定的等待时间前一直等到获取元素，</span></p><p><span>//超过时间方法将结束   E poll(long timeout, TimeUnit unit) throws InterruptedException;</span></p><p><span>  //从此队列中移除指定元素的单个实例（如果存在）。    boolean remove(Object o);</span>
<span>}</span></p><p><span>下面我们来分析下ArrayBlockingQueue的源码，看看它的阻塞式“等待-通知”的插入和移除内部运行机制究竟是怎样的？</span></p><p>&nbsp;</p><h4><a name="四非阻塞式方法" class="md-header-anchor"></a><span>四、非阻塞式方法</span></h4><p><span>首先，我们先看下“非阻塞式”插入方法offer(E e)的源码实现</span></p><p><span>public boolean offer(E e) {</span>
<span>  checkNotNull(e);</span>
<span>  final ReentrantLock lock = this.lock;</span>
<span>  lock.lock();</span>
<span>  try {</span></p><p><span>//当队列元素个数与数组长度相等时，无法添加元素</span>
<span>    if (count == items.length) //如果队列已满，返回false</span>
<span>      return false;</span>
<span>    else {</span>
<span>      enqueue(e);</span>
<span>      return true;</span>
<span>    }</span>
<span>  } finally {</span>
<span>    lock.unlock();</span>
<span>  }</span>
<span>}</span>
<span>//offer方法public boolean offer(E e, long timeout, TimeUnit unit)</span>
<span>  throws InterruptedException {</span>
<span>  checkNotNull(e);</span>
<span>  long nanos = unit.toNanos(timeout);</span>
<span>  final ReentrantLock lock = this.lock;</span>
<span>  lock.lockInterruptibly();</span>
<span>  try {</span>
<span>    while (count == items.length) {</span>
<span>      if (nanos &lt;= 0)</span>
<span>        return false;</span>
<span>      nanos = notFull.awaitNanos(nanos);</span>
<span>    }</span>
<span>    enqueue(e);</span>
<span>    return true;</span>
<span>  } finally {</span>
<span>    lock.unlock();</span>
<span>  }</span>
<span>}</span></p><p>&nbsp;</p><p><span>//入队操作private void enqueue(E x) {</span>
<span>  //获取当前数组</span>
<span>  final Object[] items = this.items;</span>
<span>  //通过putIndex索引对数组进行赋值</span>
<span>  items[putIndex] = x;</span>
<span>  //索引自增，如果已是最后一个位置，重新设置 putIndex = 0;</span>
<span>  if (++putIndex == items.length)</span>
<span>    putIndex = 0;</span>
<span>  count++;//队列中元素数量加1</span>
<span>  //唤醒调用take()方法的线程，执行元素获取操作。</span>
<span>  notEmpty.signal();</span>
<span>}</span></p><p><span>这里的add方法和offer方法的实现相对简单，其中需要注意的是入队enqueue(E x)方法，其内部是通过putIndex索引直接将元素添加到数组items中。</span></p><p><span>如下图2所示：</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/42089300_1622361676.png" referrerpolicy="no-referrer" alt="img"></p><p><span>图2</span></p><h4><a name="-n807" class="md-header-anchor"></a><span> </span></h4><h4><a name="五-阻塞式方法" class="md-header-anchor"></a><span>五、 阻塞式方法</span></h4><p><span>接着，重头戏来了，我们看看“阻塞式”的插入put(E e) 方法。</span></p><p><span>//put方法，阻塞时可中断public void put(E e) throws InterruptedException {</span>
<span>  checkNotNull(e);</span>
<span>  final ReentrantLock lock = this.lock;</span>
<span>  lock.lockInterruptibly();//该方法可中断</span>
<span>  try {</span>
<span>    //当队列元素个数与数组长度相等时，无法添加元素</span>
<span>    while (count == items.length)</span>
<span>      //将当前调用线程挂起，添加到notFull条件队列中等待唤醒</span>
<span>      notFull.await();     enqueue(e);//如果队列没有满直接添加。</span>
<span>  } finally {</span>
<span>    lock.unlock();</span>
<span>  }</span>
<span>}</span>
<span>//入队操作private void enqueue(E x) {</span>
<span>  //获取当前数组</span>
<span>  final Object[] items = this.items;</span>
<span>  //通过putIndex索引对数组进行赋值</span>
<span>  items[putIndex] = x;</span>
<span>  //索引自增，如果已是最后一个位置，重新设置 putIndex = 0;</span>
<span>  if (++putIndex == items.length)</span>
<span>    putIndex = 0;</span>
<span>  count++;//队列中元素数量加1</span>
<span>  //唤醒调用take()方法的线程，执行元素获取操作。</span>
<span>  notEmpty.signal();}</span></p><p>&nbsp;</p><p><span>put方法是一个阻塞的方法，如果队列元素已满，那么当前线程将会被notFull condition条件对象挂起并添加到等待队列中，直到队列又重新满足notfull未满条件，即有队列元素出队了时，才会被唤醒，继续执行put添加操作。但如果队列元素本身就没有满，那么就直接调用入队enqueue(e)方法将元素加入到数组队列中。</span></p><p><span>总得来说添加线程的执行存在以下两种情况：</span></p><ul><li><span>队列已满，那么新到来的执行put操作的线程将被添加到notFull的条件队列中等待；</span></li><li><span>队列未满，当有线程执行了移除队列元素操作，移除成功同时唤醒put线程；</span></li></ul><p>&nbsp;</p><p><span>如图3所示：</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/67817700_1622361676.png" referrerpolicy="no-referrer" alt="img"></p><p><span>图3：队列已满</span></p><p>&nbsp;</p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/98327100_1622361676.png" referrerpolicy="no-referrer" alt="img"></p><p><span>图4：队列未满</span></p><p><span>再看下“阻塞式”删除take() 方法</span></p><p><span>public E take() throws InterruptedException {</span>
<span>  final ReentrantLock lock = this.lock;</span>
<span>  lock.lockInterruptibly();</span>
<span>  try {</span></p><p><span>//当队列长度为0     while (count == 0)</span></p><p><span> //执行阻塞操作       notEmpty.await();     return dequeue();//如果队列有元素执行删除操作   } finally {</span>
<span>    lock.unlock();</span>
<span>  }</span>
<span>}</span></p><p><span>//删除队列头元素并返回private E dequeue() {</span>
<span>  //拿到当前数组的数据</span>
<span>  final Object[] items = this.items;</span>
<span>  //获取要删除的对象</span>
<span>      E x = (E) items[takeIndex];</span>
<span>  //将数组中takeIndex索引位置设置为null</span>
<span>  items[takeIndex] = null;</span>
<span>  //takeIndex索引加1并判断是否与数组长度相等，</span>
<span>  //如果相等说明已到尽头，恢复为0</span>
<span>  if (++takeIndex == items.length)</span>
<span>    takeIndex = 0;</span>
<span>  count--;//队列个数减1</span>
<span>  if (itrs != null)</span>
<span>    itrs.elementDequeued();//同时更新迭代器中的元素数据</span>
<span>  //删除了元素说明队列有空位，唤醒notFull条件对象添加线程，执行添加操作</span>
<span>  notFull.signal();   return x;</span>
<span>}</span></p><p><span>take方法执行时，队列中有元素就删除，队列为空就阻塞等待（注意：这个阻塞是可以中断的），并且是加入notEmpty条件队列等待。</span></p><p><span>如果有新的线程通过put方法添加数据时，那么同时也会唤醒take线程，即在入队方法（enqueue）中唤醒notEmpty condition条件等待队列中的线程执行移除元素操作。</span></p><p><span>如果有新的线程通过take方法移除数据时，在出队方法（dequeue）中唤醒notFull condition条件等待队列中的线程，去执行插入元素操作。</span></p><p>&nbsp;</p><p><span>如下图5所示：</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/25098500_1622361677.png" referrerpolicy="no-referrer" alt="img"></p><p><span>图5：队列已空</span></p><p>&nbsp;</p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/58374800_1622361677.png" referrerpolicy="no-referrer" alt="img"></p><p><span>图6：队列未空</span></p><h4><a name="-n841" class="md-header-anchor"></a><span> </span></h4><h4><a name="六总结-n842" class="md-header-anchor"></a><span>六、总结</span></h4><p><span>到此关于Guarded Suspension模式在ArrayBlockingQueue阻塞式队列源码中的应用就分析完了。</span></p><p><span>让我们再总结一下：</span></p><p><span>当执行put操作时，如果队列满了，就加入到notFull的等待队列中，此时若有任务通过take操作移除元素时，会唤醒notFull condition条件等待队列中的线程，执行put操作。</span></p><p><span>当执行take操作时，如果队列为空，就加入到notEmpty的等待队列中，此时若有任务通过put操作插入元素时，会唤醒notEmpty condition条件等待队列中的线程，执行take操作。</span></p><p>&nbsp;</p><h3><a name="12探秘two-phase-termination两阶段终止）模式" class="md-header-anchor"></a><strong><span>12_探秘Two-phase Termination（两阶段终止）模式</span></strong></h3><h4><a name="一初识two-phase-termination两阶段终止）模式" class="md-header-anchor"></a><span>一、初识Two-phase Termination（两阶段终止）模式</span></h4><p>&nbsp;</p><p><span>有没有过这样的经历？辛辛苦苦搬了一天砖，刚回到家吃口杂酱面，这时Leader打电话来，告诉你线上出问题了, 让你回去加班，这时，你依依不舍的放下了碗筷，优雅的掏出纸巾，擦了擦脸上的酱汁，掏出镜子照了一下，发现自己还是如此的帅气，然后你又奔赴“前线”救火。</span></p><p>&nbsp;</p><p><span>刚才的场景重现，是为了给大家说明一个情况，即：当一些突发性事件降临时，首先要给被打断的一方预警，让其能对手头被打断的事做个收尾，避免一些事情只处理了一半，产生一些不良影响。比如满嘴酱汁的你跑到公司，也许会闹个大笑话。</span></p><p>&nbsp;</p><p><span>现在再讲讲如何终止线程，当咱们儒猿公众号的粉丝，周末点开专栏打算学习，正常情况就可以在知识的海洋里遨游了。</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/19178200_1622364180.png" referrerpolicy="no-referrer" alt="img"></p><p>&nbsp;</p><p><span>可如果由于网络等等不可控的因素，线程始终读取不到想要的网络资源，就会导致这样的情况：</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/63971500_1622364180.png" referrerpolicy="no-referrer" alt="img"></p><p>&nbsp;</p><p><span>网络连接出现问题，可能会出现两种情况：</span></p><ol start='' ><li><span>线程资源长期被占用着。</span></li><li><span>已建立的网络连接，无法被正常释放。</span></li></ol><p>&nbsp;</p><p><span>这些情况进而会导致服务器资源被白白占用，客户端的过来请求也会堆积的越来越多，无法被处理。用户体验也很差。毕竟这种时候，谁还能快乐的学习呢。</span></p><p>&nbsp;</p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/85044900_1622364180.png" referrerpolicy="no-referrer" alt="img"></p><p>&nbsp;</p><p><span>这时为了避免事态进一步恶化，我们必须想办法释放线程资源。那么要怎么做才能释放线程资源呢？</span></p><p>&nbsp;</p><p><span>文章开篇有讲到善后工作的重要性，放在程序里也一样，甚至更为重要，因为多个线程都是在协同为一个系统工作，当一个线程没有做好善后工作，那接连产生的问题也会让你无休止加班。</span></p><p>&nbsp;</p><p><span>接下来先来一张图，阐述清楚场景：</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/15887300_1622364181.png" referrerpolicy="no-referrer" alt="img"></p><p><span>上图画的是一个线程不断地从队列里取出数据，将其写入数据库里的过程。</span></p><p>&nbsp;</p><p><span>我们思考一下，如何去打断这个线程，有些人可能会想到用 interrupt()方法，但其实呢interrupt() 方法是将一个处于等待状态的线程唤醒，只不过这种唤醒方式会导致线程会抛出InterruptedException异常，从而导致其终止运行，但只要此异常被捕获并处理，那么线程依然可以继续运行。</span></p><p>&nbsp;</p><p><span>（关于等待状态的定义，同学们可以移步前面的文章06_基础回顾：线程在执行过程中的状态是如何流转的？进行复习。）</span></p><p>&nbsp;</p><p><span>还记得文章开头那个Leader吗？他的一通电话让程序员停止干饭。那么如何让一个线程能接收到终止执行那一通“电话”呢？也许可以通过一个按钮控制，如下面两张图所示：</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/39964700_1622364181.png" referrerpolicy="no-referrer" alt="img"></p><p>&nbsp;</p><p>&nbsp;</p><p><span>当“按钮”处于上图的那个状态，说明线程正常运行，按下这个状态下的“按钮”，相当于发出线程终止指令，此时”按钮“状态就切换如下图所示：</span></p><p>&nbsp;</p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/57842200_1622364181.png" referrerpolicy="no-referrer" alt="img"></p><p><span>这时再次按下上图的“按钮”也可以让线程重新运行，可以说当有了这个“按钮”之后，咱们可以轻轻松松的控制线程的运行状态。而在程序中，这个按钮是通过标记位的方式来做的。我们可以通过改变标记位来达到控制线程的运行状态。那么谁来改变标记位？答案就是另外一个线程。咱们可以把处理数据的线程想象成程序员，Leader想象成改变标记位的线程。如下图：</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/78003200_1622364181.png" referrerpolicy="no-referrer" alt="img"></p><p>&nbsp;</p><p>&nbsp;</p><p><span>上面提到的两个线程都需要关心“按钮”的状态。回顾下第一篇java的内存模型的文章时，我们知道，要让线程间准确的感知到“按钮”的状态，必须使其保证可见性，那么这个“按钮”必须用volitale 修饰符来修饰了。</span></p><p>&nbsp;</p><p><span>好了，这下我们知道了让线程停止的的方式了，那么我们怎么做善后工作呢，还拿上图举例子，如果让“程序员”线程还没把take出的数据处理完毕就会结束，那么无疑就会造成数据的的丢失，如图：</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/98748800_1622364181.png" referrerpolicy="no-referrer" alt="img"></p><p>&nbsp;</p><p><span>所以往往要给线程结束工作时的一个处理当前工作机制或者给予处理完成点工作的时间才行。如图：</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/65686900_1623809074.png" referrerpolicy="no-referrer" alt="图081.png"></p><p>&nbsp;</p><p><span>既要保证线程灵活的切换运行状态，又要保证线程优雅的处理完当前任务，就是两阶段终止模式（Two-phase Termination）的核心思想。</span></p><p>&nbsp;</p><p><span>综上所述两阶段终止模式的两个阶段总结起来分别为：</span></p><ol start='' ><li><span>发出信号，告知正在运行的线程将被终止。</span></li><li><span>接收到此信号的线程，做完善后工作，停止运行。</span></li></ol><p>&nbsp;</p><p><span>为了让大家更好的理解，这里通过一段代码说明一下:</span></p><p>&nbsp;</p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/47953800_1622364182.png" referrerpolicy="no-referrer" alt="img"></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/72336700_1622364182.png" referrerpolicy="no-referrer" alt="img"></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/38140300_1622364183.png" referrerpolicy="no-referrer" alt="img"></p><p><span>可能看代码还不是很明白，我们可以参考下图理解一下：</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/63197200_1622364183.png" referrerpolicy="no-referrer" alt="img"></p><h4><a name="二关于阻塞状态下线程如何终止的思考" class="md-header-anchor"></a><span>二、关于阻塞状态下线程如何终止的思考</span></h4><p>&nbsp;</p><ol start='' ><li><span>：  受interrupt方法影响的方法表：</span></li></ol><p>&nbsp;</p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/93130500_1622364183.png" referrerpolicy="no-referrer" alt="img"></p><p>&nbsp;</p><ol start='' ><li><span>关于线程阻塞无法感知标记位，如何停止线程执行的解决方案</span></li></ol><p><span>线程阻塞本质上是一段代码执行时间过长，那它自然也没有办法感知到标记位的改变，从而优雅的终止线程。那么当一个线程发生阻塞时我们又该怎么去终止它呢？如果线程发生阻塞想要停止，就不太符合两阶段终止的思想了，属于一种暴力解决方式，这里提供一段代码作为一种思路。</span></p><p>&nbsp;</p><p>&nbsp;</p><p><span>public class ThreadExecutor {</span>
<span>  /**</span>
<span>  </span><span>*</span><span> 执行线程</span>
<span>  */</span>
<span>  private Thread executeThread;</span>
<span>  /**</span>
<span>  </span><span>*</span><span> 运行状态</span>
<span>  */</span>
<span>  private volatile boolean isRunning = false;</span></p><p><span>  /**</span>
<span>  *</span>
<span>  </span><span>*</span><span> @param task 发生阻塞的线程任务</span>
<span>  */</span>
<span>  public void execute(Runnable task) {</span>
<span>    executeThread = new Thread(() -&gt; {</span>
<span>      Thread childThread = new Thread(task);</span></p><p><span>      // 子线程设置为守护线程</span>
<span>​      childThread.setDaemon(true);</span></p><p><span>      childThread.start();</span>
<span>​      try {</span>
<span>​        // 强行执行子线程，使其进入休眠状态</span>
<span>​        childThread.join();</span>
<span>​        isRunning= true;</span>
<span>​      } catch (InterruptedException e) {</span>
<span>​        //e.printStackTrace();</span>
<span>​      }</span>
<span>​    });</span></p><p><span>    executeThread.start();</span>
<span>  }</span></p><p><span>  /**</span>
<span>  *</span>
<span>  </span><span>*</span><span> @param mills 强制结束任务的时长阈值</span>
<span>  */</span>
<span>  public void shutdown(long mills) {</span>
<span>    long currentTime = System.currentTimeMillis();</span>
<span>    while (!isRunning) {</span>
<span>      if ((System.currentTimeMillis() - currentTime) &gt;= mills) {</span>
<span>        System.out.println(&quot;任务超时，需要结束他!&quot;);</span>
<span>        executeThread.interrupt();</span>
<span>        break;</span>
<span>      }</span></p><pre spellcheck="false" class="md-fences md-end-block ty-contain-cm modeLoaded" lang=""><div class="CodeMirror cm-s-inner CodeMirror-wrap" lang=""><div style="overflow: hidden; position: relative; width: 3px; height: 0px; top: 0px; left: 8px;"><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0" style="position: absolute; bottom: -1em; padding: 0px; width: 1000px; height: 1em; outline: none;"></textarea></div><div class="CodeMirror-scrollbar-filler" cm-not-content="true"></div><div class="CodeMirror-gutter-filler" cm-not-content="true"></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer" style="margin-left: 0px; margin-bottom: 0px; border-right-width: 0px; padding-right: 0px; padding-bottom: 0px;"><div style="position: relative; top: 0px;"><div class="CodeMirror-lines" role="presentation"><div role="presentation" style="position: relative; outline: none;"><div class="CodeMirror-measure"><pre><span>xxxxxxxxxx</span></pre></div><div class="CodeMirror-measure"></div><div style="position: relative; z-index: 1;"></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline" style="position: relative;"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter" style="left: 0px; width: 0px;"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">}</span></pre></div></div></div></div></div></div><div style="position: absolute; height: 0px; width: 1px; border-bottom: 0px solid transparent; top: 23px;"></div><div class="CodeMirror-gutters" style="display: none; height: 23px;"></div></div></div></pre><p><span>    isRunning = false;</span>
<span>  }</span>
<span>  public static void main(String[] args) {</span></p><p><span>    ThreadExecutor executor = new ThreadExecutor();</span>
<span>​    long start = System.currentTimeMillis();</span>
<span>​    executor.execute(() -&gt; {</span>
<span>​      try {</span>
<span>​        Thread.sleep(5000);</span>
<span>​      } catch (InterruptedException e) {</span>
<span>​        e.printStackTrace();</span>
<span>​      }</span>
<span>​    });</span>
<span>​    executor.shutdown(1000);</span>
<span>​    long end = System.currentTimeMillis();</span>
<span>​    System.out.println(end - start);</span>
<span>  }</span>
<span>}</span></p><p>&nbsp;</p><h3><a name="13案例实战结合分布式的报警系统带你玩转两阶段终止模式" class="md-header-anchor"></a><span>13_案例实战：结合分布式的报警系统带你玩转两阶段终止模式</span></h3><p><span>学习法。我们儒猿也有很多深得这种学习法要义的大佬，比如提出六遍学习法的小霸王。</span></p><p>&nbsp;</p><p><span>上一篇文章我们用大白话讲解两阶段终止模式，提到了两阶段终止模式的核心就是以修改标记位的方式，改变run方法的执行逻辑，使得run方法能够在优雅结束前处理完任务，那么这篇文章我们就通过研究案例的方式，再来理解一下它的抽象模型。</span></p><p>&nbsp;</p><p><span>下面就让我们通过一张图，引出案例背景，如下图（图1）：</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/57561200_1622365973.png" referrerpolicy="no-referrer" alt="img"></p><p><span> 图1</span></p><p><span>上图可以清晰看到：故障的机器通过各自的客户端程序，同时将报警信息发送到报警管理器上，让它进行报警信息的上报，这无疑会给报警管理器带来很大的负载，这个时候为了帮它分摊压力，我们给它安排上两个上报报警信息的节点-报警信息发送器，如下图（图2）：</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/76025300_1622365973.png" referrerpolicy="no-referrer" alt="img"></p><p><span>图2</span></p><p><span>这时，运营人员已经加了两台用于上报报警信息的节点，但报警管理器并不知道，所以两个新来的“小弟”，必须在报警管理器那里报备一下才行，如下图（图3）：</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/96506100_1622365973.png" referrerpolicy="no-referrer" alt="img"></p><p><span>图3</span></p><p><span>现在两个小弟完全就可以替报警管理器分担任务了，并且只有当接收到报警管理器下达的命令后，他们才会开始工作。 如下图（图4）：</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/33425700_1622365974.png" referrerpolicy="no-referrer" alt="img"></p><p><span>                    图4</span></p><p><span>如果是这样的话，我们的系统的设计就不够完美了，试想下如果有一天报警管理器放假了，两个小弟是不是也就没活干了，如下图（图5）：</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/59377900_1622365974.png" referrerpolicy="no-referrer" alt="img"></p><p><span>图5</span></p><p><span>从图上我们可以了解到，客户端（client）能接触到的只能是报警管理者。而它背后的两个报警信息发送器，客户端是没有感知的。就好比我们打开电脑的任务管理器，看到的是一个个进程的执行情况，而对于进程背后的多个线程，我们是没有感知的。当我们对一个进程下达关闭指令也就意味着线程也会停掉。在两阶段终止的模式里，扮演进程的角色被称之为ThreadOwner，也就是线程的持有者。结合我们的案例来说，这个ThreadOwner就是我们的报警管理器。</span></p><p>&nbsp;</p><p><span>现在我们分析下上图中的“消息”，这个指的是我们两阶段终止模式中控制线程启停的标记位，又称为TerminationToken。图中报警管理器管理的两个报警发送器“小弟”也可以对应上面“任务管理器”举例中线程的概念。接下来是重点来了，图中要求小弟具备的“善后的能力”，是什么呢？其实是感知到标记位被改变后，在run方法中继续完成剩余代码功能的能力。那我们如何改变标记位？这个问题的答案因场景而异，而不变的核心则在于，让报警管理器管理的成员符合一定的标准。 在java中制定一个标准的方式，可以通过一个接口（interface）。这个接口在两阶段终止的模式下被命名为Terminatable，需要实现的方法名为terminate，也就是用来改变标记位的方法， 如下图（图6）：</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/86904300_1622365974.png" referrerpolicy="no-referrer" alt="img"></p><p><span>图6</span></p><p><span>通过上面的讲解我们知道，要被报警管理器管理，需要实现Terminatable接口，并且实现它的terminate方法，还得配备一个用于控制run方法启停的TerminationToken。虽然我们不知道具体是谁会被管理，但是依据这两点要求 ，我们可以画出一个轮廓来，这个轮廓被称之为AbstractTerminationThread，其具体代码如下图（图7）所示：</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/10527100_1622365975.png" referrerpolicy="no-referrer" alt="img"></p><p><span>图7</span></p><p><span>上面抽象类的实现类，通常被称为ConcreteTerminatableThread。看到这里，如果你有较强的面向对象的设计能力也许立马能想到，使用这个定制化的线程类有个小缺陷，就是终止线程的判断逻辑和run方法执行的业务代码耦合在了一起。那么最好的方法，就是把业务方法逻辑剥离出来，减少维护上的麻烦。如下图（图8）：</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/38537300_1622365975.png" referrerpolicy="no-referrer" alt="img"></p><p><span>图8</span></p><p><span>可以看到这时run方法里，虽然包含了终止条件的判断与业务逻辑，但是由于定义了doRun方法，代码解耦了，也优雅多了。其实这个可终止线程还有两个比较重要的方法，doCleanUp和 doTerminate，在下一个实战案例里我们再详细说明。</span></p><p>&nbsp;</p><p><span>doCleanUp : 就是有“善后能力”代码 ，一般是无论如何都要执行的方法，通常会被 finally代码块中执行。如下图（图9）：</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/71150300_1622365975.png" referrerpolicy="no-referrer" alt="img"></p><p><span> 图9</span></p><p><span>doTerminate : 就是一些处理特殊情况的代码。比如说用socket获取输入流，发生阻塞无法感知到信号时。实际的运用如下图（图10），也是我们下一个要讲解的案例的剧透图。</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/19689600_1622365976.png" referrerpolicy="no-referrer" alt="img"></p><p><span>图10</span></p><p><span>下一篇文章，我们会更加详细讲解这两个方法。敬请期待。</span></p><p>&nbsp;</p><p><span>最后一点小建议，设计模式这种东西很精妙，但没有复杂场景的支撑，就像一个空中楼阁。如果为了套用它花费过多精力，那就本末倒置了。真正重要的是理解运用各种设计模式解决问题的思想。</span></p><p>&nbsp;</p><h3><a name="14案例实战模拟点餐系统中两阶段终止模式的运用" class="md-header-anchor"></a><strong><span>14_案例实战：模拟点餐系统中两阶段终止模式的运用</span></strong></h3><p><span>上一篇文章我们通过一个分布式报警管理器的案例，给大家讲清楚了两阶段终止模式的抽象模型。还基于AbstractTerminationThread类讲解了两阶段终止模式，现在我们继续讲解这个类的doTerminate和doCleanup两个方法。</span></p><p>&nbsp;</p><h4><a name="一图解doterminate和docleanup方法" class="md-header-anchor"></a><span>一、图解doTerminate和doCleanup方法</span></h4><p><span>让我们再回顾下terminate方法，它给一个应用发出停止信号，当这个管控应用的线程感知到信号后，就可以做一些收尾工作，尽快的终止相关run方法的执行。但terminate方法只是发送一个通知信号，并不能保证你期望终止的线程一定能接收到这个信号，这是什么意思呢？</span></p><p><span>让我参考下图（图1）：</span><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/34336000_1622366374.png" referrerpolicy="no-referrer" alt="img"></p><p><span>图1</span></p><p><span>如上图，张三的妈妈发出了一个终止信号给张三，但张三依然沉迷游戏，没对发出信号予以回应。此时张三妈妈，只能采取一些强硬的手段。如下图（图2）：</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/51406200_1622366374.png" referrerpolicy="no-referrer" alt="img"></p><p><span>                                 图2</span></p><p><span>张三的妈妈生拉硬拽，才让张三停止打游戏，这比耳提面命要费劲多了，同时张三也被弄哭了。</span></p><p>&nbsp;</p><p><span>上面的举例主要是为了引出两阶段终止模式中比较重要的两点：</span></p><ol start='' ><li><span>用发信号的方式让线程停止，前提是要接收的线程得回应才行。</span></li><li><span>如果发信号也终止不了线程，只能强制终止线程，这种方式就比较麻烦，也会附带一些副作用。</span></li></ol><p>&nbsp;</p><p><span>如果按照第二点说的强制终止，就可能出现异常的状况。这种状况从代码层面来说，就是你期望终止的线程执行时发生了阻塞，甚至是死锁。强制终止是通过doTerminate方法来完成的。</span></p><p>&nbsp;</p><p><span>那doCleanup方法具体又干了什么呢？还延续前面的例子讲解，见下图（图3）：</span><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/83220500_1622366374.png" referrerpolicy="no-referrer" alt="img"></p><p><span>图3</span></p><p><span>无论是听话的乖孩子张三，还是被母亲生拉硬拽的李四。只要他们停止打游戏，都必须找网吧老板买单。</span></p><p>&nbsp;</p><h4><a name="二实操环节doterminate和docleanup在代码中的演练" class="md-header-anchor"></a><span>二、实操环节：doTerminate和doCleanup在代码中的演练</span></h4><p>&nbsp;</p><p><span>下面我以模拟在餐馆吃饭的场景举例，讲解下doTerminate和doCleanup的运用，代码大致实现功能逻辑如图4:</span><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/1553400_1622366375.png" referrerpolicy="no-referrer" alt="img"></p><p><span> 图4</span></p><p><span>只要有顾客进店，都会被登记在册。只有满足了“登记顾客全部离场”和“熄灯了”两个条件，店员才能下班。图中的登记处，排队区，就餐区，在程序里由这两个属性代表，见下图（图5）：</span><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/21605900_1622366375.png" referrerpolicy="no-referrer" alt="img"></p><p><span>图5</span></p><p><span>排队去和就餐区是由一个线程池组成，登记处由一个线程安全的链表队列代表。其中为了演示方便，所有的socket连接都是BIO的方式。</span></p><p>&nbsp;</p><p><span>先看下我们预期的程序运行效果，再倒推运行流程，如图6：</span><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/37368600_1622366375.png" referrerpolicy="no-referrer" alt="img"></p><p><span> 图6</span></p><p><span>程序最理想的运行结果：用户用餐完离开，打烊打扫卫生，熄灯，程序停止，也就代表顺利关门了。</span></p><p>&nbsp;</p><p><span>此时我们先修改标记位，然后把程序里调用doTerminate方法的代码注释掉，如下图（图7）：</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/67992100_1622366375.png" referrerpolicy="no-referrer" alt="img"></p><p><span> 图7</span></p><p><span>注释掉doTerminate方法又是什么状况呢？如图8：</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/85609700_1622366375.png" referrerpolicy="no-referrer" alt="img"></p><p><span>图8</span></p><p><span>这时顾客离开店铺的信息没有了，程序也没有停止，这说明有线程还在运行。所以我们的doTerminate方法有什么内容呢？ 见下图（图9）：</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/8173200_1622366376.png" referrerpolicy="no-referrer" alt="img"></p><p><span> 图9</span></p><p><span>原来是从队列里取出客户端的处理器，进行终止操作。那么这个stop方法又干了什么呢？我们再跟进去看看，见下图（图10）：</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/27956500_1622366376.png" referrerpolicy="no-referrer" alt="img"></p><p><span>图10</span></p><p><span>再进入doStop方法里看看，如图11：</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/43273600_1622366376.png" referrerpolicy="no-referrer" alt="img"></p><p><span>图11</span></p><p><span>看到这里，我们恍然大悟，原来是socket连接一直阻塞着，导致了程序一直在运行。那么线程发生阻塞时，就没法感知到标记位变化了。具体在哪里阻塞，相信大家也猜到了，是在获取telnet输入流数据的时候发生了阻塞，如图12：</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/59546100_1622366376.png" referrerpolicy="no-referrer" alt="img"></p><p><span>图12</span></p><p><span>当标记位为true时进入循环，执行代码逻辑，而在readLine方法调用处发生了阻塞，所以改变了标记位也没用。</span></p><p><span>doTerminate方法到这里就讲解的差不多了，接下来咱们讲讲doCleanup方法。先把doTerminate方法放开，再把doCleanup的调用注释掉看效果，如图13：</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/94044300_1622366376.png" referrerpolicy="no-referrer" alt="img"></p><p><span>图13</span></p><p><span>不管是正常执行完毕，还是被异常中断都必须执行doCleanup。当把它注释掉程序的运行结果会是什么呢，如图14：</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/10807500_1622366377.png" referrerpolicy="no-referrer" alt="img"></p><p><span>图14</span></p><p><span>图中我们可以看到客户端断开连接，客人也走了，但是灯还没有关，就不能下班。我们的程序还是运行着的状态，如图15：</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/28068600_1622366377.png" referrerpolicy="no-referrer" alt="img"></p><p><span>图15</span></p><p><span>原来doCleanup方法中线程池执行了shutdownNow方法，让线程池停止服务。为什么不调用这个方法，程序就会一直运行呢？这其中原理是什么呢？又和两阶段终止设计模式有什么关系呢？请听下回分解！</span></p><p>&nbsp;</p><h3><a name="15源码中的运用两阶段终止模式在并发线程池中的应用场景" class="md-header-anchor"></a><strong><span>15_源码中的运用：两阶段终止模式在并发线程池中的应用场景</span></strong></h3><p><strong><span>1、开篇词</span></strong></p><p><span>上篇文章我们通过一个模拟点餐的案例讲解了AbstractTerminationThread类的doCleanup和doTerminate方法，最后抛出了一个问题：线程已经执行完毕，但没有关闭线程池，程序还会继续运行，这是怎么一回事？这和两阶段终止模式又有什么关系呢？本讲将通过画图+源码分析的方式给大家阐述明白。</span></p><p>&nbsp;</p><h3><a name="2图解线程池的原理" class="md-header-anchor"></a><span>2、图解线程池的原理</span></h3><p>&nbsp;</p><p><span>要讲清楚上面的问题，我们需要先搞懂线程池ThreadPoolExcutor的原理，现在就来了解下线程池的基本结构吧，如下图（图1）：</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/36158800_1622551119.png" referrerpolicy="no-referrer" alt="img"></p><p><span>图1</span></p><p><span>上图中我们可以看到线程池中几个比较重要的成员，其中workQueue是一个阻塞队列，worker则代表一个线程，command是需要线程执行的代码任务，就比如上一篇文章的clientHandler。</span></p><p>&nbsp;</p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/60199000_1622551119.png" referrerpolicy="no-referrer" alt="img"></p><p><span>图2</span></p><p><span>这里的线程一般可分为两种，下图中我们也用不同的颜色标识出来了，其中红色的线程都在执行任务。如果此时外部又派发任务过来了怎么办呢？如下图（图3）：</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/84071700_1622551119.png" referrerpolicy="no-referrer" alt="img"><span>图3</span></p><p><span>这时就会把这些任务放到上图中左边的阻塞队列中。如果队列满了又怎么办呢？那就会创建额外的黄色线程执行任务了，如下图（图4）：</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/20504600_1622551120.png" referrerpolicy="no-referrer" alt="img"></p><p><span>图4</span></p><p><span>那么问题来了，线程不可能是无休止创建的，如果红色线程，队列，都被任务占满了，同时黄色线程的数量也到了一个阈值，那么新来的任务怎么处理呢? 让我们参考一下下面这张图（图5）：</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/1880000_1622551121.png" referrerpolicy="no-referrer" alt="img"></p><p><span>图5</span></p><p><span>原来，我们的线程池就会把这个任务拒绝掉。如果外部指派的任务越来越少，而线程池逐渐将这些任务处理完了，红色线程和黄色线程的命运又会如何呢？</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/40114100_1622551121.png" referrerpolicy="no-referrer" alt="img"></p><p><span>图6</span></p><p><span>首先，如果黄色线程没有被分配到任务，就会被销毁。而红色线程即使没有被分配到任务，也不会被销毁，这就是两种颜色线程截然不同的命运。这里的红色线程我们叫它核心线程，黄色线程则是非核心线程，而衡量非核心线程没有被分配到任务就应被销毁的时长被称为keepAliveTime。</span></p><p>&nbsp;</p><p><span>看到这里，我们可以搞清楚上篇文章遗留的问题了，导致线程池没有被关闭，程序一直在运行的原因原来是：核心线程一直在运行。而且非核心线程在执行完任务后，空闲一段时间才能被销毁。所以当我们在程序中用了线程池的时候，只有让线程池关闭，才能终止程序。关闭线程池的关键则是在让存活的线程停止运行，这似乎和两阶段终止模式又有关联了，那么现在就接着上面文章，带大家一探究竟吧。</span></p><p>&nbsp;</p><h4><a name="3shutdownnow方法的源码剖析" class="md-header-anchor"></a><span>3、shutdownNow方法的源码剖析</span></h4><p><span>让我们继续一步一步跟一下shutdownNow方法的源码，如下图（图7）：</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/96810300_1622551121.png" referrerpolicy="no-referrer" alt="img"></p><p><span>图7</span></p><p><span>【1】这是一个底层安全检查机制，不是核心逻辑，我们先跳过。</span></p><p><span>【2】将线程池的状态改变为“STOP”，本质上是一个线程标记位的改变。</span></p><p><span>【3】对线程池中的所有线程都进行中止（interrupt）操作，让我们看下这个方法的具体内容，如下图（图8）：</span></p><p>&nbsp;</p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/25091500_1622551122.png" referrerpolicy="no-referrer" alt="img"></p><p><span>图8</span></p><p><span>对处于阻塞状态的线程池里的工作线程调用中止（interrupt）方法。现在我们去看下哪里会发生阻塞，这个时候就要去看看worker线程的执行代码了。</span></p><p>&nbsp;</p><p><span>注意：这里对线程池的源码的讲解比较碎片化，大家只需了解这个worker线程的使命是执行任务，最终调用Runnable实现类的run方法即可。如下图（图9）：</span></p><p>&nbsp;</p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/54035300_1622551122.png" referrerpolicy="no-referrer" alt="img"><span>图9</span></p><p><span>很明显 run方法的逻辑就是runWorker，方法参数就是worker本身，点进去看一下，如图10和11：</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/81213100_1622551122.png" referrerpolicy="no-referrer" alt="img"></p><p><span>图10</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/12741000_1622551123.png" referrerpolicy="no-referrer" alt="img"></p><p><span>图11</span></p><p><span>这里我们可以看到，我们传入的任务，最终是被worker线程，通过调用task的run方法执行的。如果当前的task执行完毕，就会从getTask方法中不断的获取任务执行，直到获取到不到为止。继续跟getTask的代码，如下图（图12）：</span></p><p>&nbsp;</p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/97464900_1622551123.png" referrerpolicy="no-referrer" alt="img"></p><p><span>图12</span></p><p>&nbsp;</p><p><span>（小提示：如果忘记了take方法的使用，可以移步 11_源码中的运用：Guarded Suspension模式在BlockingQueue源码中的应用 复习）</span></p><p>&nbsp;</p><p><span>我们可以看到getTask就是不断地从workQueue里获取任务来执行，当获取不到数据时会发生阻塞，就可以通过interrupt方法中断它们，继续执行循环体，如图13：</span></p><p>&nbsp;</p><p>&nbsp;</p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/19197700_1622551124.png" referrerpolicy="no-referrer" alt="img"></p><p><span>图13</span></p><p><span>很明显，现在状态是STOP常量值大于SHUTDOWN的常量值，那肯定返回空了，退出runWorker方法的while循环了，如图14</span></p><p>&nbsp;</p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/41915200_1622551124.png" referrerpolicy="no-referrer" alt="img"></p><p><span>图14</span></p><p><span> 退出之后执行这两行语句：</span></p><ol start='' ><li><span>completedAbruptly = false：正常的逻辑退出，没有因异常而退出</span></li><li><span>processWorkerExit(w, completedAbruptly):对runWorker做一个终止的处理逻辑。</span></li></ol><p>&nbsp;</p><p><span>进入processWorkerExit看一下，如图15</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/66736600_1622551124.png" referrerpolicy="no-referrer" alt="img"></p><p><span>图15</span></p><p><span>可以看到此时这个线程就会从hashSet被删除了，那下面的addWorker方法又有什么作用呢？在讲解这个方法前我们要了解一个知识点：在一个线程池里，正常情况下至少要保证不少于设置的核心线程数的线程是存活的。</span></p><p>&nbsp;</p><p><span>然后继续我们的讲解，如下图（图16）：</span></p><p>&nbsp;</p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/93995200_1622551124.png" referrerpolicy="no-referrer" alt="img"></p><p><span>图16</span></p><p><span>其中if条件满足时，直接返回false。至此通过interrupt方法，终止了线程池里的所有存活线程。</span></p><p><span>【4】接着图7分析 tasks = drainQueue() 方法，如其字面意思，其作用是清空阻塞队列的线程任务，这些任务会作为一个List集合返回回来。</span></p><p><span>【5】tryTerminate() 这个方法多次见到，其作用，是在对每一个worker线程调用interrupt方法后，做一些辅助性的工作，比如状态变更，意义不大，我们快速过一下，如图17</span></p><p>&nbsp;</p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/31004700_1622551125.png" referrerpolicy="no-referrer" alt="img"></p><p><span>图17</span></p><p><span>稍稍有点关键的是上面标示的一段，当你将线程池状态设为stop时，看看有没有线程在运行，有的话就向一个空闲线程发出interrupt指令试一下。我们点进去看一下，如图18：</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/54656000_1622551125.png" referrerpolicy="no-referrer" alt="img"></p><p><span>图18</span></p><p><span>这一段相对来说比较重要，因为runWorker执行task的run方法时会加一把锁，如果获取所成功了，说明没有task的run方法在执行，这个就属于空闲线程了。</span></p><p>&nbsp;</p><h4><a name="4shutdownnow和shutdown的区别" class="md-header-anchor"></a><span>4、shutdownNow和shutdown的区别</span></h4><p><span>shutdown 方法执行后，就会拒绝接收新的任务，但是会等待线程池中正在执行的任务和已经进入阻塞队列的任务都执行完之后，才最终关闭线程池。</span></p><p><span>shutdownNow方法就比较暴力了，线程池，阻塞队列里的任务通通不允许再执行了，不过会返回阻塞队列中没执行完的任务，也算留有余地。</span></p><p>&nbsp;</p><h3><a name="16图文讲解大白话聊聊promise模式的工作原理" class="md-header-anchor"></a><strong><span>16_图文讲解：大白话聊聊Promise模式的工作原理</span></strong></h3><p><strong><span>一、为什么需要Promise模式</span></strong></p><p><span>在本篇文章开始之前，我们提一下华罗庚讲《统筹方法》时提到的烧水喝茶的例子，在烧水的同时做一些其他的泡茶准备工作。这种思想可以让我们合理安排一项任务的工序，从而节约时间。具体如下：</span><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/2271100_1622551822.webp" referrerpolicy="no-referrer" alt="img"></p><p>&nbsp;</p><p>&nbsp;</p><p><span>我们在这里简化一下，借用它来讲解Promise模式。</span></p><p><span>假设为了泡茶，我们需要做两项任务, 分别是：烧水(用时15分钟) 和 准备茶杯, 茶叶(用时3分钟)。</span></p><p>&nbsp;</p><h4><a name="二泡茶任务的两种执行方式" class="md-header-anchor"></a><span>二、泡茶任务的两种执行方式</span></h4><p><span>同步执行：即在开启烧水任务后，等待水沸腾,  发出蜂鸣声后(获取到烧水任务完成的信号)，再开启另一项任务，开始准备茶杯和茶叶(用时3分钟)，则整个泡茶过程需要18分钟。如图一：</span></p><p>&nbsp;</p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/24437300_1622551822.jpeg" referrerpolicy="no-referrer" alt="img"></p><p><span>图一</span></p><p><span>异步执行:  在开启烧水任务后, 并不需要等待烧水任务全部完成,，就可以执行准备茶杯茶叶的任务，完成准备茶杯茶叶任务后,，等待烧水任务执行结束的信号(蜂鸣声)，则完成了泡茶的准备工作，整个过程需要15分钟，比同步执行更快。如图二：</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/47717300_1622551822.jpeg" referrerpolicy="no-referrer" alt="img"></p><p><span>图二</span></p><p><span>以上便是一个Promise模式在日常生活中的一个运用。Promise模式是一种异步编程模式. 其核心的是, 执行任务A(例如烧水)时, 其执行结果可通过一个promise对象来获取。因而并不需要同步等待任务A结束再去执行任务B。任务B可以与任务A同时执行，它需要任务A执行的结果时， 通过这个promise对象获取即可(例如去听蜂鸣声)。</span></p><p>&nbsp;</p><p><span>在烧水喝茶的例子，Promise模式的好处显而易见，泡茶的总时长减少了。在程序中，这意味着程序会运行更快，因为Promise可以避免不必要的等待,  提高对并发的支持。</span></p><p>&nbsp;</p><h4><a name="三-promise模式介绍" class="md-header-anchor"></a><span>三、 Promise模式介绍</span></h4><p><span>Promise模式主要由4部分构成: 1：Promisor、 2：Executor、 3：Promise,  4：Result。</span></p><p><span>下面一幅图说明这个四个部分的构成关系,：</span></p><ol start='' ><li><span>Executor需要在Promisor的create()方法中去执行。</span></li><li><span>create()的返回值就是Promise。</span></li><li><span>Result则是Promise中get()方法的返回值。</span></li></ol><p><span>看到这里, 如果你还是觉得云里雾里的，没关系，下面我们结合例子详细讲解。如图三：</span></p><p>&nbsp;</p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/69930700_1622551822.jpeg" referrerpolicy="no-referrer" alt="img"></p><p><span>图三</span></p><p>&nbsp;</p><p><span>Promisor类: 对外暴露一个方法create(),  一旦执行了这个create()方法, 两件事情就发生了：</span></p><p><span>1、执行器Executor开始异步执行任务。</span></p><p><span>2、Promisor会创建并返回一个Promise。</span></p><p><span>这就好比, 一方面开启了烧水的这个异步任务, 另一个方面开始等待水沸腾的蜂鸣声音。如图四：</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/92721900_1622551822.jpeg" referrerpolicy="no-referrer" alt="img"></p><p><span>图四</span></p><p><span>Executor: 在Promisor中定义好一个任务, Executor异步执行这个任务。换句话来讲, 就是Promisor决定了，接下来要去异步开启烧水,  然后按下Executor的按钮，它就开启行动啦。</span></p><p>&nbsp;</p><p><span>Promise: 是Promisor的create()方法的返回值，这里是立刻返回的，就像买彩票时候拿到的号码。虽然在买彩票的那一刻，不知道结果, 不过你也不需要在彩票站等待, 直接拿着号码就可以回去了。等开奖时间到了,  就可以用这个号码查询自己有没有中奖。 而Promise就好比这个号码，可以立刻返回得到，不会阻塞程序运行.。</span></p><p><span>方法介绍：</span></p><p><span>  1、isDone()方法: 烧水的结果, 可能是沸腾了，也就是烧好了。也可能正在加热中。所以Promise中一般会有方法isDone()方法表示任务是在执行中还是已经结束了，放到彩票的例子中就像会告诉你彩票开奖时间是否到啦, 但是不会告诉你结果。</span></p><p>&nbsp;</p><p><span>  2、get()方法: 获取任务执行的结果, 就好比, 烧水是加热到沸腾, 发出峰鸣声音啦, 还是把水壶给烧漏掉了, 失败啦。此时, 聪明的你们, 可能要问, 这不是要等上一段时间才能知道吗? 刚刚开始烧水, 怎么能知道结果是沸腾了, 还是水壶漏了呢?  这就引出了get()方法的关键：需要阻塞等待, 只有经过了阻塞等待, 才能知道结果哟。放到彩票的例子中, get()方法就像是一直在电视机前等着看开奖结果, 等着等着，直到中奖结果公布。如图五</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/15787700_1622551823.jpeg" referrerpolicy="no-referrer" alt="img"></p><p><span>图五</span></p><p><span>Result: 最简单的一个部分,  其实就是Promise中get()方法的返回值, 放到彩票的例子中, 就是开奖结果。</span></p><p>&nbsp;</p><p><span>上面我们详细分析了这四个部分的结构关系,  下面再从时序的角度来再次看待一下这4个部分.如图六</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/46224600_1622551823.png" referrerpolicy="no-referrer" alt="img"></p><p><span>图六</span></p><h4><a name="四没有promise模式时-泡茶问题的代码如何执行" class="md-header-anchor"></a><span>四、没有Promise模式时, 泡茶问题的代码如何执行?</span></h4><p><span>说了那么多Promise原理, 一定想来看看代码是如何执行的吧。下面我们就开始coding，用java代码来模拟烧水例子的全过程。我们会分别用 非Promise模式 和 Promise模式 来写两套代码进行对比。</span></p><p>&nbsp;</p><p><span>1、非Promise模式泡茶</span></p><p><span>先设定两个类， 一个是BoilWater表示烧水，在代码中new BoilWater()表示开始烧水，其中status等于true表示烧水完成。另一个是TeaAndCup表示准备茶叶茶杯，同样， 在代码中new TeaAndCup表示开始准备茶叶茶杯，其中status等于true表示准备茶叶茶杯完成。如图七：</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/77932000_1622551823.png" referrerpolicy="no-referrer" alt="img"></p><p><span>图七</span></p><p>&nbsp;</p><p><span>做好了铺垫，下面就可以看非Promise模式时的代码啦，如图八：</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/8624000_1622551824.png" referrerpolicy="no-referrer" alt="img"></p><p><span>图八</span></p><p><span>运行结果如下: 如图九</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/41063000_1622551824.png" referrerpolicy="no-referrer" alt="img"></p><p><span>图九</span></p><p><span>可以看到，任务一(烧水) 和 任务二(准备茶叶茶杯) 因为一个join()方法的介入，先把任务一(烧水)结束之后，再开始执行任务二。这时两个任务是串行执行的，多线程也失去了意义。</span></p><p><span>看到这里，好奇的你可能会问，为啥需要执行join()方法呢？ 异步执行不就可以了吗， 为了回答这个问题, 我们把join()注释掉, 再来执行以下程序, 看一看结果。</span></p><p>&nbsp;</p><p><span>没有join()的程序的执行结果，如图十</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/65932500_1622551824.png" referrerpolicy="no-referrer" alt="img"></p><p><span>图十</span></p><p><span>可以看到，任务一结束竟然是在准备工作结束之后。这说明任务一(烧水)还没执行结束。主程序就结束了。 烧水还没结束，主程序就任务准备工作结束啦，这显然是不符合要求的。如图十一</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/97989000_1622551824.jpeg" referrerpolicy="no-referrer" alt="img"></p><p><span>图十一</span></p><p><span>这真是矛盾啊，如果串行执行呢，结果是正确的，可是没有做到异步。效率不高；如果直接开启异步任务呢, 主程序又提前执行结束了， 如何解决这个问题呢？ 那就需要Promise模式了! 这个代码，下回分解!</span></p><p>&nbsp;</p><h4><a name="五总结与展望" class="md-header-anchor"></a><span>五、总结与展望</span></h4><p><span>本篇文章先让大家讲了一个经典的烧水泡茶的例子，说明需要异步多线程执行，效率才更高,。也就是使用Promise模式的原因了。 再结合流程图和时序图, 讲解了Promise模式的原理, 主要是解释了1：Promisor， 2：Executor， 3：Promise，4：Result的作用，我们还特别强调了promise中get()方法是阻塞的。  最后, 把泡茶的例子用java代码实现了一下,  通过观察程序的结果，我们再次验证：Promise模式使得我们的程序兼顾了高效率与正确性。</span></p><p>&nbsp;</p><p><span>下篇文章我们会在Promise模式下使用java代码实现泡茶的例子，并和这篇文章结尾中非promise模式的代码做个对比。彻底理解了Promise模式之后，我们会深入一个更复杂的例子当中，去探讨一下，如何解决个人云盘本地文件同步太慢的问题。敬请期待！</span></p><p>&nbsp;</p><h3><a name="17技术挑战如何解决云盘或网盘从本地文件同步文件太慢的问题" class="md-header-anchor"></a><strong><span>17_技术挑战：如何解决云盘或网盘从本地文件同步文件太慢的问题</span></strong></h3><p><strong><span>一、课程背景</span></strong></p><p><span>个人云盘和网盘之间进行数据同步的时候，需要先去建立网络连接然后在扫描本地文件的内容在上同步文件到云盘中，建立网络连接和扫描文件的操作串行化太慢。上一节, 我们引入生活中烧水泡茶的例子分析了什么是Promise模式, 这一篇文章先看一下如何在烧水泡茶的例子中实现Promise模式， 再引入一个真实的项目案例，为什么个人云盘同步本地文件过慢。</span></p><p>&nbsp;</p><h3><a name="二利用promise模式-泡茶的代码如何执行" class="md-header-anchor"></a><span>二、利用Promise模式, 泡茶的代码如何执行</span></h3><p><span>上一篇文章最后在非Promise模式的代码的实现中存在一个矛盾的问题点：如果串行执行任务一(烧水)和任务二(准备茶叶茶杯), 需要先完成任务一, 再开始执行任务二, 效率不高。两个任务都结束, 在主线程结束前任务一和任务二都完成了, 耗时结果计算正确;</span></p><p><span>如果直接开启异步执行这两个任务呢, 主程序又提前执行结束了, 烧水还在进行中, 可主线程已经结束了, 这结果显然是不正确的。如图一</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/32852400_1622554658.jpeg" referrerpolicy="no-referrer" alt="img"></p><p><span>图一</span></p><p><span>如何改造Promise模式呢, 这就需要我们再复习下上篇文章提出的Promise模式的四个重要组件, 分别是: 1：Promisor、 2：Executor、 3：Promise、 4：Result。</span></p><p><span>为了实现Promise模式，我们需要依次把这四个组件改造好,  如图二</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/58808700_1622554658.jpeg" referrerpolicy="no-referrer" alt="img"></p><p><span>图二</span></p><p><span>先把Promisor的代码写出来，需要在create()方法中，完成两个功能，第一个是需要返回Promise，第二个是在方法中需要用Executor执行任务。</span></p><p><span>下面这个Promisor类中的create方法由三个步骤Step构成，第一步， Step1定义了任务，也就是烧水的过程。 第二步，Step2则是把用Executor执行多线程任务。</span></p><p><span>第三步，是把任务的结果返回，在这里Java定义返回一个Future对象(后面我们会详细刨析Future的源码)，这个Future对象就是Promise模式中需要返回的Promise。如图三和图四</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/85164600_1622554658.jpeg" referrerpolicy="no-referrer" alt="img"></p><p><span>图三</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/15474100_1622554659.png" referrerpolicy="no-referrer" alt="img"></p><p><span>图四</span></p><p><span>完成这三个步骤, 也就完成了Promise模式的前三部分代码：1：Promisor，2：Executor，3：Promise，下面到主线程中，去看看如何获取第四个部分Result。</span></p><p><span>在主线程中，主要分成三个部分来执行，第一个部分（见图中Part1）, 通过上面写好的Promisor的create()方法来获取到promise，这也意味着任务一(烧水)已经开启了异步执行，第二个部分（见图中Part2）, 用主线程开启执行任务二(准备茶杯茶叶)，这样任务一(烧水)和任务二(准备茶杯茶叶)是异步并行的哟，第三个部分（见图中Part3），则是通过Part1中获取到的promise来拿到结果Result(Promise模式的四个部分，Promisor，Executor，Promise和Result全部完成)。</span></p><p><span>特别是Part3中，主线程在获取获取烧水执行结果的时候，可能经过了一段时间的阻塞。如图五：</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/53320400_1622554659.png" referrerpolicy="no-referrer" alt="img"></p><p><span>图五</span></p><p><span>把Promise模式代码执行的示意图也补充到上面，可以看到，Promise集齐了非Promise模式串行和非Promise模式异步两者的优点，既可以异步执行，又可以获取到正确的结果，此时主线程在两个任务都完成后才结束，如图六：</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/88815400_1622554659.jpeg" referrerpolicy="no-referrer" alt="img"></p><p><span>图六</span></p><h4><a name="三为什么个人云盘或网盘同步本地文件过慢" class="md-header-anchor"></a><span>三、为什么个人云盘或网盘同步本地文件过慢?</span></h4><p><span>接下来我们将会用个人云盘同步本地文件作为背景,  分析一下云盘同步过程中所遇到的一个技术挑战。</span></p><p><span>大家可能都用过一些个人云盘的工具, 先要把某个本地目录设定为同步目录。其中同步就是要让本地与云端保持一致，所以云盘工具会做两件事，为接下来的同步做准备：一个是和云盘创建网络连接，需要去把用户名和密码到服务端做匹配验证, 再获取云端的地址, 给接下来的同步做准备. 另一个事情是扫描本地同步目录的文件, 给接下来的对比做准备. 如图七</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/12086300_1622554660.jpeg" referrerpolicy="no-referrer" alt="img"></p><p><span>图七</span></p><p><span>简单的思考这个问题, 可能不会想到有什么技术挑战, 只要分别写这样两个方法, 依次执行他们就好了.</span></p><p><span>可是在真实的环境中, 情况比这个要复杂得多. 因为个人云盘是有大量的用户, 可能是上百万, 甚至上千万用户. 如果在同一个时刻去建立连接, 可能需要排队.。而且个人用户可能用的是不同类型的光纤宽带，或者手机的4G网络，这种情况下网络速度极不稳定。这就导致建立连接的过程可能很缓慢, 甚至会因网络波动而卡顿，, 连接的过程非常缓慢,  可这时如果恰好有大量的本文文件等待被扫描, 两件缓慢的事情串行在一起, 就会导致用户体验很差, 界面卡死, 甚至退出。如图八</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/41205700_1622554660.jpeg" referrerpolicy="no-referrer" alt="img"></p><p><span>图八</span></p><p><span>刚刚开始开发使用的时候, 用户量不大, 用户的文件不多, 可能这样的问题出现比较少, 还可以忍受。但是当用户量增大, 用户同步的文件越来越多的时候, 这就变成了一个严峻的问题了。</span></p><p><span>涉及到用户体验的问题，需要及时的优化。 优化方法中首选的就是将串行任务变成并行任务。 利用java多线程, 两个准备任务异步进行,入下图所示.  具体如何用Promise模式来实现这个优化呢, 下一节继续讨论一下Promise模式在个人网盘同步优化中的具体实现, 如图九</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/68929400_1622554660.jpeg" referrerpolicy="no-referrer" alt="img"></p><p><span>图九</span></p><p><span>对比一下之前讨论的烧水泡茶的例子, 与云端建立连接就好比烧水, 扫描本地文件就好比准备茶杯茶叶。两件任务异步进行能提高程序执行效率, 但是需要收到烧水成功的信号, 才能知道准备工作完毕了,  同样在云盘同步的准备任务中, 与云端建立网络连接需要收到反馈, 才能知道连接建立成功了. 显然, 这也是一个, 既需要异步进行提高效率, 又需要获取执行结果的问题, 那就需要Promise模式出马了, 个人云盘同步准备更加复杂, 但其实现的原理和泡茶的例子是一样的, 具体如何实现看下节具体讨论。</span></p><p>&nbsp;</p><h4><a name="四总结与展望" class="md-header-anchor"></a><span>四、总结与展望</span></h4><p><span>文章开头我们回顾了，在泡茶的例子中如何用代码实现Promise模式, 提到解决之前非promise模式实现代码的问题, 关键是要抓住完成 1：Promisor，2：Executor， 3：Promise，4：Result这四个重要部分,而其中Executor和Promise又包含在Promisor类中。 接下来, 我们探讨了云盘项目中的技术挑战, 网络连接延迟和同步本地文件过慢的问题, 究其根本，提出了建立异步处理云端网络连接和本地文件扫描的完整方法。</span></p><p><span>下一篇文章中，我们会基于这两篇文章的内容, 提出用Promise模式异步处理优化云盘准备同步过程过慢的问题，敬请期待。</span></p><p>&nbsp;</p><h3><a name="18性能优化基于promise模式对云网盘进行改造提升性能" class="md-header-anchor"></a><strong><span>18_性能优化：基于Promise模式对云网盘进行改造，提升性能</span></strong></h3><p><strong><span>一、详细分析如何对云盘进行改造</span></strong></p><p><span>上一篇文章我们讲到本地和云网盘之间做数据文件同步的时候，需要先去建立网络连接然后再扫描本地文件的内容在上传同步文件到云网盘中，建立网络连接和扫描本地文件两个任务串行化太慢，再给大家回顾一下其中的问题所在。</span></p><p>&nbsp;</p><p><span>如果两个任务串行起来执行的话，随着用户量的增加，建立网络连接可能会非常耗时，甚至可能由于网络的不稳定卡住几分钟，出现超时错误，非常影响用户体验，如图一：这篇文章我们讲下如何基于Promise模式来优化升级，提升性能的同时提升用户体验。</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/59180500_1622880898.jpeg" referrerpolicy="no-referrer" alt="img"></p><p><span>图一</span></p><p><span>进行优化设计之前，我们对网盘同步场景中几个要点进行一下的梳理。</span></p><p><span>1、用户并不知道有&quot;建立云端网络连接&quot;这个过程</span></p><p><span>2、&quot;建立云端网络连接&quot;可能很耗时</span></p><p><span>3、&quot;建立云端网络连接&quot;并不需要在&quot;扫描本地文件&quot;之前先完成</span></p><p><span>4、在准备工作结束之前，必须得到&quot;建立云端网络连接&quot;完成的反馈</span></p><p>&nbsp;</p><p>&nbsp;</p><h4><a name="二异步化与云端建立连接" class="md-header-anchor"></a><span>二、异步化与云端建立连接</span></h4><p>&nbsp;</p><p><span>由于用户不知道，也不关心&quot;建立云端网络连接&quot;的过程，那么我们可以把这个建立连接的动作做成异步处理的形式。这样异步化处理之后，建立连接与扫描文件两个任务可以同时进行，提升了系统性能。 如图二所示：</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/95211700_1622880898.jpeg" referrerpolicy="no-referrer" alt="img"></p><p><span>图二</span></p><p>&nbsp;</p><h4><a name="三仔细思考扫描文件完成云端连接还没初始化怎么办" class="md-header-anchor"></a><span>三、仔细思考：扫描文件完成，云端连接还没初始化怎么办？ </span></h4><p><span>但是由于建立云端连接，可能是一个很耗时的工作。特别是遇到网络波动的时候，可能比扫描本地文件的速度还要慢。如果仅仅开启建立连接的异步线程，不去获取连接建立的结果的话， 那就会出现这样的情况，扫描本地文件结束后，认为准备任务已经完毕了，可是其实建立连接还在进行当中。这显然是有问题的，如图三所示：</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/29208600_1622880899.jpeg" referrerpolicy="no-referrer" alt="img"></p><p><span>图三</span></p><p>&nbsp;</p><p><span>为了解决这个问题，就需要用到在前面两篇文章中介绍的Promise模式：通过一个未来对象来获取开启的异步线程的执行结果，在建立连接和扫描文件两个任务都完成后，才表示准备完毕。如图四所示，可以让主线程获取异步线程的结果，这就是Promise模式的魅力所在！</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/66864700_1622880899.jpeg" referrerpolicy="no-referrer" alt="img"></p><p>&nbsp;</p><p><span>图4</span></p><h4><a name="四动手操练对云盘进行改造后的代码实现" class="md-header-anchor"></a><span>四：动手操练：对云盘进行改造后的代码实现</span></h4><p>&nbsp;</p><p><span>改造成Promise模式，这就需要再提一下Promise模式的四个重要部分，分别是:</span></p><p><span>1：Promisor、2：Executor、 3：Promise、 4：Result，如图五所示：</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/94398900_1622880899.jpeg" referrerpolicy="no-referrer" alt="img"></p><p><span>图五</span></p><p>&nbsp;</p><p><span>和上一节改造烧水泡茶过程一样， 把这四个组成部分处理好，Promise模式也就改造完成了，其中的关键则是完成Promisor，当Promisor构建完成了，除了Result之外的Promisor，Executor，Promise也就构建完了，如图六所示：</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/26084300_1622880900.jpeg" referrerpolicy="no-referrer" alt="img"></p><p><span>图六</span></p><p><span>如图七中给出的代码，给出了Promsior的实现， 其中的newCloudUploaderPromise方法就是我们上面所说的create()方法，其返回值是Futrue类型，这是一个未来对象，这相当于返回一个Promise模式中的Promise。</span></p><p><span>在其中new Thread(futureTask).start()的执行，相当于Promise模式中的Executor执行完成了newCloudUploaderPromise方法的构建，构造Promise模式中的Promisor也就完成了，在代码中可以再看看到Promisor的作用，就是给外部提供一个Promise。</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/53673500_1622880900.png" referrerpolicy="no-referrer" alt="img"></p><p><span>图七</span></p><p><span>完成了Promisor之后，Promise模式中的三个部分(Promisor，Executor，Promise)也就构建完了，接下来我们回到主线程，来看看如何获取Result。</span></p><p><span>在图八的代码中，主要由5个部分构成。 分别是</span></p><p><span>Part1: 开启异步线程，与云端建立网络连接</span></p><p><span>Part2: 扫描本地文件</span></p><p><span>Part3: 获取建立连接的结果</span></p><p><span>Part4: 准备工作完毕，开始同步上传</span></p><p><span>Part5: 上传完毕，关闭连接</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/5326400_1622880901.png" referrerpolicy="no-referrer" alt="img"></p><p><span>图八</span></p><p><span>其中，在Part3中，圈红的部分就是从未来对象cloudUploaderFuture中获取&quot;建立云端网络连接&quot;的结果，如果建立连接已经完成了，可以直接进行下一步，就是开始上传文件，如图九所示。  </span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/53246300_1622880901.jpeg" referrerpolicy="no-referrer" alt="img"></p><p><span>图九</span></p><p><span>如果建立网络连接过程耗时比较久 ，可能比扫描本地文件还要更慢，则阻塞在这里，等待建立连接结束了，再开始上传文件，如图十所示。</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/94467000_1622880901.jpeg" referrerpolicy="no-referrer" alt="img"></p><p><span>图十</span></p><p><span>以上就是实现Promise模式中代码的两个关键点，大家理解以上核心的代码，云盘的优化问题也就理解了。</span></p><p>&nbsp;</p><h4><a name="五总结与展望-n1341" class="md-header-anchor"></a><span>五、总结与展望</span></h4><p><span>这篇文章中分析了三点：</span></p><p><span>一：为什么云盘上传文件过慢？</span></p><p><span>二：为什么可以通过异步优化来解决问题？</span></p><p><span>三：为什么需要Promise来获取结果?</span></p><p><span>接下来开始了分析Promise模式代码的具体实现，通过完成对 1：Promisor、2：Executor、3：Promise、4：Result。这四个部分的构建来完成Promise模式的改造。下一篇文章我们会在这几篇文章知识基础上，探究一下promise的实现原理， 即本文中的未来对象Future的源码的实现原理。</span></p><p>&nbsp;</p><h3><a name="19源码分析promise模式在futuretask源码中的应用场景" class="md-header-anchor"></a><strong><span>19_源码分析：Promise模式在FutureTask源码中的应用场景</span></strong></h3><p>&nbsp;</p><h4><a name="一本节内容介绍" class="md-header-anchor"></a><span>一、本节内容介绍</span></h4><p><span>前面几篇文章中我们分析了Promise模式的原理，并在一个实战案例中应用Promise模式去进行性能优化。 这一篇文章，我们将对Promise模式在java并发源码FutureTask中的实现进行分析，探究一下其中的原理。</span></p><p>&nbsp;</p><p>&nbsp;</p><h4><a name="二如何启动运行futuretask线程" class="md-header-anchor"></a><span>二、如何启动运行FutureTask线程</span></h4><p><span>还记得上一篇文章中，是如何创建并返回Promise的吗?  通过创建了一个FutureTask来返回Promise。如图一所示：</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/3934600_1622882977.png" referrerpolicy="no-referrer" alt="img"><span>图一</span></p><p>&nbsp;</p><p><span>在图一中，我们创建了一个FutureTask类型的对象，先将其运行，再并将其作为返回值返回。针对这个过程我们有三个问题?</span></p><p><span>问题一：FutureTask</span><V><span>的构造函数是什么样的内容，如何通过new来创建带返回值的FutureTask对象呢?</span></p><p><span>问题二：FutureTask类型的对象futureTask，为何可以传入到Thread对象构造方法中来执行thread.start()方法呢?</span></p><p><span>问题三：为何FutureTask可以当做Future类型的返回值呢?</span></p><p>&nbsp;</p><p><span>下面就通过分析FutureTask的源码来解开这三个疑问。通过图二的UML图我们可以看到FutureTask的继承实现关系，FutureTask实现了RunnableFuture接口。看到RunnableFuture这个接口名称，就猜到了它的作用，RunnableFuture分别继承了Runnable接口和Future接口。</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/50343000_1622882977.png" referrerpolicy="no-referrer" alt="img"></p><p><span>图二</span></p><p><span>这样问题二和问题三便得到了答案。FutureTask因为实现了Runnable接口，则可以传入到Thread的构造方法中，再调用start()进行运行。又因为FutureTask实现了Future接口，则可以作为方法的返回值(也就是作为Promise模式的Promise)。 如图三所示：</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/75082600_1622882977.jpeg" referrerpolicy="no-referrer" alt="img"></p><p><span>图三</span></p><p><span>而针对问题一，FutureTask的构造方法是如何创建FutureTask对象的呢? 我们一起来分析一下FutureTask的构造方法，如图四所示：</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/3630300_1622882978.png" referrerpolicy="no-referrer" alt="img"><span>图四</span></p><p><span>图四中是FutureTask的两个构造方法，其中一个是直接接收一个Callable对象，另一个虽然是接收一个Runnable对象和一个泛型对象，但仍然要转化为Callable对象。为啥这里一定要引入Callable对象呢，Callable和Runnable的区别在哪里呢?</span></p><p>&nbsp;</p><p><span>一起看看源码中对Callable的英文注释：</span></p><p><span>A task that returns a result and may throw an exception. Implementors define a single method with no arguments called call.</span></p><p><span>The Callable interface is similar to Runnable，in that both are designed for classes whose instances are potentially executed by another thread. A Runnable，however，does not return a result and cannot throw a checked exception.</span></p><p><span>原来其中的区别在于: 虽然Callable与Runnable很相似，但是Callable可以抛出异常。而更重要的区别是，Callable中的call()方法相比Runnable中的run()方法，前者有返回值，而后者没有。</span></p><p>&nbsp;</p><p><span>看到这里，我们了解了，FutureTask的构造方法有一个Callable的成员变量callable，为啥需要Callable类型来获取返回值呢? 这就需要顺藤摸瓜，找一找成员变量callable在FutureTask中用在了什么位置呢? 找到了FutureTask的run()方法，如图五所示：</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/36566500_1622882978.png" referrerpolicy="no-referrer" alt="img"><span>图五</span></p><p><span>在图中，先不考虑异常处理等内容，抓一下代码的主干，则是被圈红的这部分代码， 主要含义是从callable对象的call()方法中获取返回值，再传入set()方法中，这个流程如图六所示：</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/79216000_1622882978.jpeg" referrerpolicy="no-referrer" alt="img"><span>图六</span></p><p><span>下面继续看一看set()方法做了什么，如图七所示：</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/9969400_1622882979.png" referrerpolicy="no-referrer" alt="img"><span>图七</span></p><p><span>可以看到在set()方法中把传入的callable的返回值，在线程安全的前提下，赋值给了FutureTask的成员变量outcome。这就意味着，启动Future会通过Callable来获取一个结果，并把这个结果放到成员变量outcome，等待着获取。整个流程如图八所示：</span></p><p>&nbsp;</p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/50585100_1622882979.jpeg" referrerpolicy="no-referrer" alt="img"><span>图八</span></p><p>&nbsp;</p><p><span>从图八的流程解释中，可以看出，为什么要在构造方法中创建一个Callable对象? 因为Callable对象，可以获取返回值，并且存到变量outcome中。 这就解释了疑问一，FutureTask&lt;&gt;的构造函数是什么样的内容，为什么要在其中构建Callable对象。</span></p><p>&nbsp;</p><p>&nbsp;</p><h4><a name="三如何从futuretask线程获取结果" class="md-header-anchor"></a><span>三、如何从FutureTask线程获取结果?</span></h4><p><span>在前面的内容中，我们详细分析了如何创建并返回Promise，回答了关于FutureTask的三个问题。再接下来，我们再详细分析一下，future在执行get()方法的时候的两个问题。</span></p><p><span>问题四: FutureTask对象执行get()方法的时候，是如何获取返回值的?</span></p><p><span>问题五: FutureTask对象执行get()方法的时候，为什么会阻塞?</span></p><p>&nbsp;</p><p><span>这就要分析一下FutureTask的get()方法，如图九所示：</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/73236900_1622882979.png" referrerpolicy="no-referrer" alt="img"><span>图九</span></p><p>&nbsp;</p><p><span>从代码中，抓大放小，可以看出这样的思路，当state还在计算状态时，调用awaitDone()方法等待，否则，就调用report()方法返回，如图十所示：</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/11715500_1622882980.jpeg" referrerpolicy="no-referrer" alt="img"><span>图十</span></p><p><span>下面问题转化成了：</span></p><p><span>1、分析awaitDone()方法来回答问题五“get()方法如何进行阻塞的”</span></p><p><span>2、分析report()来回答问题四“get()方法如何获取返回值”</span></p><p>&nbsp;</p><p>&nbsp;</p><p><span>先从report()方法开始分析，那就需要分析一下report()的代码，如图十一所示：</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/33346700_1622882980.png" referrerpolicy="no-referrer" alt="img"><span>图十一</span></p><p>&nbsp;</p><p><span>在图十一的report()方法中，我们先忽略异常等细节不看，观察一下，report的返回值，也就是代码中圈红的部分. 这里返回的x，在report()方法刚刚开始执行的时候就被赋值了，x被赋予了变量outcome的值，而这个outcome的内容正是我们前面分析的Callable对象的返回值。 在图十二中，把这两段串联起来，解释了问题四，get()方法是如何获取返回值的。</span></p><p>&nbsp;</p><p>&nbsp;</p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/59910800_1622882980.jpeg" referrerpolicy="no-referrer" alt="img"><span>图十二</span></p><p><span>下面来看另一个问题，get()方法是如何进行阻塞等待的，这就需要看一下awaitDone()方法的代码，如图十三所示：</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/91749800_1622882980.png" referrerpolicy="no-referrer" alt="img"><span>图十二</span></p><p><span>在awaitDone()的代码中，依然抓大放小，先忽略异常啊，超时等等问题，关注主流程，可以看到这样一个思路</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/35156400_1622882982.jpeg" referrerpolicy="no-referrer" alt="img"><span>图十三</span></p><p><span>其中通过创建WaitNode类型的对象，把多个等待的线程构建为对象，通过AQS原理来保证线程安全。由于AQS原理不是本篇文章的重点，就不再详细说明。大家了解到在这里，通过AQS对没有执行完毕的线程进行阻塞等待即可，如图十三所示。</span></p><p>&nbsp;</p><p>&nbsp;</p><h4><a name="四总结-n1420" class="md-header-anchor"></a><span>四、总结</span></h4><p><span>今天的内容在上一篇文章的基础上，探讨了Promise模式在源码当中的具体实现原理。主要分析了FutureTask类型的对象，是如何异步运行启动的，又是如何在线程没有执行完毕的时候进行阻塞等待的，以及如何获取并返回结果的。</span></p><p><span>Promise模式总结:</span></p><p><span>1、Promise模式适用场景： 需要异步启动线程提升性能，又要获取异步线程的返回结果。</span></p><p><span>2、Promise模式的构成：1：Promisor、2：Executor、3：Promise、4：Result。</span></p><p><span>3、Promise模式在Java中实现：通过FutureTask的构建与get()方法的调用。</span></p><p>&nbsp;</p><h3><a name="20图文讲解聊聊生产者和消费者模式的工作原理" class="md-header-anchor"></a><strong><span>20_图文讲解：聊聊生产者和消费者模式的工作原理</span></strong></h3><h4><a name="一开篇词-n1428" class="md-header-anchor"></a><span>一、开篇词 </span></h4><p><span>生产者和消费者模式大家应该都比较熟悉，所以今天的文章就比较简单，主要跟大家简单介绍一下生产者和消费者的工作原理，然后再介绍一下使用这个模式会带来哪些好处。</span></p><p>&nbsp;</p><h4><a name="二生产者和消费者模式的工作原理" class="md-header-anchor"></a><span>二、生产者和消费者模式的工作原理</span></h4><p><span>其实生产者和消费者模式中有三个重要角色，生产者、任务队列、消费者。生产者提交任务到队列，消费者从队列中取出任务进行处理。</span></p><p>&nbsp;</p><p><span>大家可以结合下面的示意图来理解一下。如图1：</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/69809500_1622884709.png" referrerpolicy="no-referrer" alt="img"></p><p><span>图1</span></p><p>&nbsp;</p><p><span>这个图对应到我们程序中的话，那么生产者就是指一个线程，消费者是另外一个线程，而中间的任务队列呢，它是一个数据结构，用来存放任务数据。</span></p><p>&nbsp;</p><p><span>大家再看一下这个图。如图2所示：</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/93064100_1622884709.png" referrerpolicy="no-referrer" alt="img"></p><p><span>图2</span></p><p>&nbsp;</p><p><span>上图中生产者跟消费者都只画了一个线程，但其实它们都是可以是多线程的。如图3所示：</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/20366300_1622884710.png" referrerpolicy="no-referrer" alt="img"></p><p><span>图3</span></p><p>&nbsp;</p><p><span>而且生产者线程数量跟消费者线程的数量是不用对等的，比如上图生产者线程有三个，而消费者线程只有两个。</span></p><p><span>生产者和消费者线程的话，在实际的开发中一般选择JDK自带的线程池来实现，至于中间的任务队列，由于多线程并发操作，需要线程安全问题，还有就是队列一般也会做限制长度，队列满了之后生产者线程需要阻塞，队列空了之后消费者线程需要阻塞，可以直接选择JDK自带的线程安全的有界的阻塞队列。</span></p><p><span>下面贴一段生产者和消费者模式的示例代码，大家可以对着参考一下。</span></p><pre spellcheck="false" class="md-fences md-end-block ty-contain-cm modeLoaded" lang=""><div class="CodeMirror cm-s-inner CodeMirror-wrap" lang=""><div style="overflow: hidden; position: relative; width: 3px; height: 0px; top: 0px; left: 8px;"><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0" style="position: absolute; bottom: -1em; padding: 0px; width: 1000px; height: 1em; outline: none;"></textarea></div><div class="CodeMirror-scrollbar-filler" cm-not-content="true"></div><div class="CodeMirror-gutter-filler" cm-not-content="true"></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer" style="margin-left: 0px; margin-bottom: 0px; border-right-width: 0px; padding-right: 0px; padding-bottom: 0px;"><div style="position: relative; top: 0px;"><div class="CodeMirror-lines" role="presentation"><div role="presentation" style="position: relative; outline: none;"><div class="CodeMirror-measure"><pre><span>xxxxxxxxxx</span></pre></div><div class="CodeMirror-measure"></div><div style="position: relative; z-index: 1;"></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline" style="position: relative;"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter" style="left: 0px; width: 0px;"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">public class Test { &nbsp;  public static void main(String[] args) { &nbsp; &nbsp; &nbsp;  // 生产者线程池 &nbsp; &nbsp; &nbsp;  ExecutorService producerThreads = Executors.newFixedThreadPool(3); &nbsp; &nbsp; &nbsp;  // 消费者线程池 &nbsp; &nbsp; &nbsp;  ExecutorService consumerThreads = Executors.newFixedThreadPool(2); &nbsp; &nbsp; &nbsp;  // 任务队列，长度为10 &nbsp; &nbsp; &nbsp;  ArrayBlockingQueue&lt;Task&gt; taskQueue = new ArrayBlockingQueue&lt;Task&gt;(10); &nbsp; &nbsp; &nbsp;  // 生产者提交任务 &nbsp; &nbsp; &nbsp;  producerThreads.submit(() -&gt; { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  try { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  taskQueue.put(new Task("任务")); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  } catch (InterruptedException e) { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  e.printStackTrace(); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  } &nbsp; &nbsp; &nbsp;  }); &nbsp; &nbsp; &nbsp;  // 消费者处理任务 &nbsp; &nbsp; &nbsp;  consumerThreads.submit(() -&gt; { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  try { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  Task task = taskQueue.take(); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  } catch (InterruptedException e) { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  e.printStackTrace(); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  } &nbsp; &nbsp; &nbsp;  }); &nbsp;  } &nbsp;  static class Task { &nbsp; &nbsp; &nbsp;  // 任务名称 &nbsp; &nbsp; &nbsp;  private String taskName; &nbsp; &nbsp; &nbsp;  public Task(String taskName) { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  this.taskName = taskName; &nbsp; &nbsp; &nbsp;  } &nbsp;  }}</span></pre></div></div></div></div></div></div><div style="position: absolute; height: 0px; width: 1px; border-bottom: 0px solid transparent; top: 276px;"></div><div class="CodeMirror-gutters" style="display: none; height: 276px;"></div></div></div></pre><p>&nbsp;</p><p>&nbsp;</p><h4><a name="三生产者和消费者模式的好处" class="md-header-anchor"></a><span>三、生产者和消费者模式的好处</span></h4><p><span>生产者和消费者模式是并发编程中一个非常经典的设计模式，有很多的使用场景，比如现在流行的微服务系统开发中，经常会用到的MQ中间件也是生产者和消费者模式。</span></p><p><span>下面我们来罗列一下看看采用生产者和消费者模式有哪些优点？</span></p><p><strong><span>1、解耦</span></strong></p><p><span>由于中间任务队列的存在，生产者线程只负责生产任务，并将任务添加到任务队列中，不用关心任务的后续处理。而消费者这边呢，消费者线程只负责从任务队列中获取任务并执行即可。</span></p><p><span>生产者跟消费者之间没有任何依赖，从架构设计的角度来看，这就是解耦。如图4所示：</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/46052900_1622884710.png" referrerpolicy="no-referrer" alt="img"></p><p><span>图4</span></p><p><strong><span>2、支持异步处理</span></strong></p><p><span>与异步相对的是同步，传统的方法之间的调用是同步的。同步调用与异步调用最主要的区别就在于客户端完成一次请求的响应时间不一样。</span></p><p><span>我们画个图，先来看一下传统的方法之间同步调用。如图5所示：</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/68758700_1622884710.png" referrerpolicy="no-referrer" alt="img"></p><p><span>图5</span></p><p><span>图中的线程就表示客户端，由于方法之间的调用是同步的，假设方法A执行完本身的业务逻辑需要100毫秒，方法B执行完本身的业务逻辑需要500毫秒，那么线程完成这次请求总的响应时间就是600毫秒，而且如果方法B还同步调用其它方法的话，那么总的响应时间还会更长。</span></p><p><span>在实际的业务场景中，如果方法A的业务逻辑执行不依赖方法B的返回结果的话，那么方法A对方法B的调用可以改成异步调用。</span></p><p><span>我们再画个图，看一下异步调用的情况。如图6所示：</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/88189300_1622884710.png" referrerpolicy="no-referrer" alt="img"></p><p><span>图6</span></p><p><span>由于方法A对方法B的调用是异步的，线程调用方法A执行完业务逻辑之后就直接返回了，不用等方法B执行完，那么此时线程完成这次请求总的响应时间就只要100毫秒。</span></p><p><span>在生产者和消费者模式中，生产者线程只需要将任务添加到任务队列，而无需等待任务被消费者线程执行完，这也就是说任务的生产和消费是异步的。</span></p><p><strong><span>3、可以消除生产者生产与消费者消费之间速度差异。</span></strong></p><p><span>前面说了异步处理，大家或许会有这样的疑问，异步处理最简单的方式就是创建一个新的线程去处理，那么生产者和消费者模式中增加的“任务队列”是做什么用的呢？</span></p><p><span>因为实际上单个生产者“生产”任务和单个消费者“消费”任务的速率往往是不均衡的，我们假设生产者“生产”任务的速率比较慢，而消费者“消费”任务的速率比较快，比如是1:5。</span></p><p><span>如果生产者有5个线程，那么采用创建新的线程的方式发起异步调用的话，就需要再创建5个新的线程，但是在生产者和消费者模式中，由于中间“任务队列”的存在，消费者线程就只需要1个就可以了，如图7所示：</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/9349400_1622884711.png" referrerpolicy="no-referrer" alt="img"></p><p><span>图7</span></p><p><span>我们都知道在计算机当中，创建的线程越多，CPU进行上下文切换的成本就越大，所以我们在编程的时候创建的线程并不是越多越好，而是适量即可，采用生产者和消费者模式就可以很好的支持我们使用适量的线程来完成任务。</span></p><p><span>如果在某一段业务高峰期的时间里生产者“生产”任务的速率很快，而消费者“消费”任务速率很慢，由于中间的任务队列的存在，也可以起到缓冲的作用，我们在使用MQ中间件的时候，经常说的削峰填谷也就是这个意思。如图8所示：</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/39588500_1622884711.png" referrerpolicy="no-referrer" alt="img"></p><p><span>图8</span></p><p>&nbsp;</p><h4><a name="四总结-n1485" class="md-header-anchor"></a><span>四、总结</span></h4><p><span>好了，今天的文章就到这里了。 下一篇文章我们会引入一个真实的项目案例，分析一下这个案例里面存在的一个性能方面的技术挑战，然后再下一篇文章我们会介绍一下如何基于生产者和消费模式进行改造，完成性能优化。</span></p><p>&nbsp;</p><h3><a name="21技术挑战如何解决互联网房产交易合同管理平台的性能低下问题" class="md-header-anchor"></a><strong><span>21_技术挑战：如何解决互联网房产交易合同管理平台的性能低下问题？</span></strong></h3><p><strong><span>一、案例背景</span></strong></p><p><span>今天的文章我们以一个互联网房产交易的合同管理平台作为背景，来给大家分析一下这个平台存在的一个技术挑战。</span></p><p><span>情况是这样的，现在很多用户会在一些互联网平台上进行房产交易，作为交易凭证都是需要签署一份电子版合同的（一般是word、pdf等格式），用户签名完后，需要点击上传按钮把电子版合同上传到系统中去，平台这边一般会把电子合同存储到专用的文件服务器上去，如图1所示：</span></p><p>&nbsp;</p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/98155400_1622885346.png" referrerpolicy="no-referrer" alt="img"></p><p><span>图1</span></p><p>&nbsp;</p><h4><a name="二案例分析-n1496" class="md-header-anchor"></a><span>二、案例分析</span></h4><p><span>初步来看的话，这似乎就只是一个普通的文件上传功能，类似很多APP中的用户上传头像之类的功能一样，没什么特别的。一般来说只要电子合同文件不大的话，也不会存在什么性能问题。</span></p><p><span>但是真实情况并不是这么简单的，下面给大家分析一下。</span></p><p><span>对于用户来说，只是简单的上传一下电子合同，但是平台后续需要根据一些条件查找这些合同，可能根据合同文件名来查找，也可能需要根据合同里面的某些关键内容来进行全文检索，所以在保存电子合同文件的同时，系统还需要对这些电子合同附件的内容进行分析，然后创建相应的索引文件，以供平台后续对这些电子合同附件进行全文检索时使用。如图2所示：</span></p><p>&nbsp;</p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/39008800_1622885347.png" referrerpolicy="no-referrer" alt="img"></p><p><span>图2</span></p><p><span>对读取电子合同附件的内容生成索引文件的过程包括文件I/O和一些计算（如进行分词），该过程是需要耗费不少时间的，导致的效果就是用户点击上传合同按钮之后，界面就卡死了，一直等待响应，可能数分钟后才会得到操作的反馈，甚至有时候直接反馈请求超时，如图3所示：</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/60268900_1622885347.png" referrerpolicy="no-referrer" alt="img"></p><p><span>图3</span></p><p><span>看到这里，相信大家都能想象此时用户崩溃与愤怒的情绪了。</span></p><p>&nbsp;</p><h4><a name="三总结" class="md-header-anchor"></a><span>三、总结 </span></h4><p><span>对于平台最初的版本来说，为了赶进度，我们简单实现了这个合同上传的功能即可，不需要考虑太多性能问题。而且一开始用户量并不是很大，问题不会很大。但随着公司不断投入广告，对平台进行大力推广，用户量不断增多，这个时候，性能问题也会日渐严峻了。</span></p><p><span>对于互联网产品，用户体验非常重要，因此对这个平台进行性能优化迫在眉睫。</span></p><p><span>那具体要怎么来优化才好呢？下一篇文章继续给大家讲解。</span></p><p>&nbsp;</p><h3><a name="22案例实战基于生产者和消费模式对交易平台进行改造完成性能优化" class="md-header-anchor"></a><strong><span>22_案例实战：基于生产者和消费模式对交易平台进行改造，完成性能优化！</span></strong></h3><p><strong><span>一、前文回顾</span></strong></p><p><span>上一篇文章我们给大家分析了一下房产交易合同管理平台上传电子合同过程存在的性能问题，大家可以再看一下下图回顾一下细节。如图1所示：</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/46064400_1622945557.png" referrerpolicy="no-referrer" alt="img"></p><p><span>图1</span></p><p><span>由于分析合同附件并生成索引的过程是比较耗时的，从而导致用户每次上传电子合同的时候，交互界面都出现长时间卡顿的状况，甚至提示请求超时错误，非常影响用户体验。</span></p><p>&nbsp;</p><p>&nbsp;</p><h4><a name="二如何提升系统性能" class="md-header-anchor"></a><span>二、如何提升系统性能？</span></h4><p><span>我们这篇文章的内容就是给大家讲解一下如何对这个系统基于生产者和消费模式进行改造，来完成性能优化与提升用户体验的。</span></p><p>&nbsp;</p><p><span>在动手改造之前，我们先来再次对房产交易合同管理平台上传电子合同这个业务功能做进一步的分析。</span></p><p><span>1、用户是并不知道，也不关心“分析附件生成索引”这个事情的。</span></p><p><span>2、“分析合同附件生成索引”是一个很耗时的工作。</span></p><p><span>3、“分析合同附件生成索引”这个工作并不是立马就需要完成的，晚一点处理完也没关系。</span></p><p><span>4、业务高峰期，用户提交“上传电子合同”的请求频率可能会比较高。</span></p><p><span>由于用户是不知道，也不关心“分析附件生成索引”这个事情的，所以我们可以把分析附件生成索引这个动作从主线程中剥离出来，做异步处理。这样做了之后，用户提交请求的主线程就可以直接返回了。如图2所示：</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/71231900_1622945557.png" referrerpolicy="no-referrer" alt="img"></p><p><span>图2</span></p><p>&nbsp;</p><p><span>上图中，大家可以看到为了异步对上传的电子合同创建索引，我们单独创建了一个新线程出来专门做这个事情。</span></p><p><span>但是“分析合同附件生成索引”是一个很耗时的工作，如果每次请求都新创建一个线程来处理的话，可能会导致在某一段请求并发高的时间里，大量活跃的线程在运行，占用大量的服务器资源，所以不能每次请求都创建一个新的线程。如图3所示：</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/95449000_1622945557.png" referrerpolicy="no-referrer" alt="img"></p><p><span>图3</span></p><p><span>由于“分析合同附件生成索引”的动作可以不用立马处理完成，那么我们就可以不用创建很多的新线程，只要再增加一个任务队列，让用户的请求主线程把“分析合同附件生成索引”这个任务提交到任务队列中，再开启一个新的线程慢慢从任务队列中提取任务进行处理即可。如图4所示：</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/19800000_1622945558.png" referrerpolicy="no-referrer" alt="img"></p><p><span>图4</span></p><p><span>至于业务高峰期，用户提交“上传电子合同”的请求频率可能会比较高的问题，中间的任务队列也可以起到缓存作用。</span></p><p><span>其实到这里为止，不知道大家发现没有，按图4所示改造完之后的设计其实就是生产者和消费者模式了。</span></p><p><span>我们在《20_图文讲解：聊聊生产者和消费者模式工作原理》中提到过生产者和消费者模式的优点，在这里我们也都用上了。</span></p><p>&nbsp;</p><p><span>生产者和消费者模式能给我们带来哪一些优点呢？我们再来一起回顾一下。</span></p><p><span>1、解耦</span></p><p><span>2、支持异步处理</span></p><p><span>3、可以平衡生产者生产与消费者消费之间速度差异</span></p><p><span>对照着前面的分析，相信大家都很容易理解了。</span></p><p><span>在这里我们是把用户请求的主线程当做生产者，其“产品”就是用户上传的电子合同文件，同时增加一个任务队列，让生产者把自己的“产品”提交到这个任务队列中直接返回结果给用户了。另外，我们还创建了一个新线程异步从任务队列中取数据，进行“分析附件生成索引”的工作，这个新线程就是消费者。</span></p><p>&nbsp;</p><p><span>最后作为补充以及对比，分别贴一下改造前后的伪代码。 先给大家看一下在使用生产者和消费者模式改在之前的代码逻辑，直接使用单线程来处理，整个过程也是串行执行的，大家看一下伪代码：</span></p><pre spellcheck="false" class="md-fences md-end-block ty-contain-cm modeLoaded" lang="java" style="break-inside: unset;"><div class="CodeMirror cm-s-inner CodeMirror-wrap" lang="java"><div style="overflow: hidden; position: relative; width: 3px; height: 0px; top: 0px; left: 8px;"><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0" style="position: absolute; bottom: -1em; padding: 0px; width: 1000px; height: 1em; outline: none;"></textarea></div><div class="CodeMirror-scrollbar-filler" cm-not-content="true"></div><div class="CodeMirror-gutter-filler" cm-not-content="true"></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer" style="margin-left: 0px; margin-bottom: 0px; border-right-width: 0px; padding-right: 0px; padding-bottom: 0px;"><div style="position: relative; top: 0px;"><div class="CodeMirror-lines" role="presentation"><div role="presentation" style="position: relative; outline: none;"><div class="CodeMirror-measure"><pre><span>xxxxxxxxxx</span></pre></div><div class="CodeMirror-measure"></div><div style="position: relative; z-index: 1;"></div><div class="CodeMirror-code" role="presentation" style=""><div class="CodeMirror-activeline" style="position: relative;"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter" style="left: 0px; width: 0px;"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-keyword">public</span> <span class="cm-keyword">class</span> <span class="cm-def">HouseContractAttachmentProcessor</span> {</span></pre></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp;<span class="cm-comment">/**</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; <span class="cm-comment">* 处理用户上传电子合同</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; <span class="cm-comment">* @param houseContractFile 电子合同附件</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; <span class="cm-comment">*/</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp;<span class="cm-keyword">public</span> <span class="cm-variable-3">void</span> <span class="cm-variable">uploadHouseContractAttachment</span>(<span class="cm-variable">HouseContractFile</span> <span class="cm-variable">houseContractFile</span>) {</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp;<span class="cm-comment">// 存储业务数据</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp;<span class="cm-variable">saveBizData</span>(<span class="cm-variable">houseContractFile</span>);</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp;<span class="cm-comment">// 存储电子合同附件</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp;<span class="cm-variable">saveAttachmentFile</span>(<span class="cm-variable">houseContractFile</span>);</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp;<span class="cm-comment">// 分析附件并生成索引</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp;<span class="cm-variable">createIndex</span>(<span class="cm-variable">houseContractFile</span>);</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  }</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp;<span class="cm-keyword">private</span> <span class="cm-variable-3">void</span> <span class="cm-variable">saveBizData</span>(<span class="cm-variable">HouseContractFile</span> <span class="cm-variable">houseContractFile</span>) {</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp;<span class="cm-variable">System</span>.<span class="cm-variable">out</span>.<span class="cm-variable">println</span>(<span class="cm-string">"==== 存储业务数据完成 ===="</span>);</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  }</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp;<span class="cm-keyword">private</span> <span class="cm-variable-3">void</span> <span class="cm-variable">saveAttachmentFile</span>(<span class="cm-variable">HouseContractFile</span> <span class="cm-variable">houseContractFile</span>) {</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp;<span class="cm-variable">System</span>.<span class="cm-variable">out</span>.<span class="cm-variable">println</span>(<span class="cm-string">"==== 存储业务数据完成 ===="</span>);</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  }</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp;<span class="cm-keyword">private</span> <span class="cm-variable-3">void</span> <span class="cm-variable">createIndex</span>(<span class="cm-variable">HouseContractFile</span> <span class="cm-variable">houseContractFile</span>) {</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp;<span class="cm-keyword">try</span> {</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span class="cm-comment">// 耗时2分钟</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span class="cm-variable">Thread</span>.<span class="cm-variable">sleep</span>(<span class="cm-number">20000</span>);</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp;  } <span class="cm-keyword">catch</span> (<span class="cm-variable">InterruptedException</span> <span class="cm-variable">e</span>) {</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span class="cm-variable">e</span>.<span class="cm-variable">printStackTrace</span>();</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp;  }</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp;<span class="cm-variable">System</span>.<span class="cm-variable">out</span>.<span class="cm-variable">println</span>(<span class="cm-string">"==== 分析附件并生成索引完成 ===="</span>);</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  }</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">}</span></pre></div></div></div></div></div><div style="position: absolute; height: 0px; width: 1px; border-bottom: 0px solid transparent; top: 667px;"></div><div class="CodeMirror-gutters" style="display: none; height: 667px;"></div></div></div></pre><p><span>再来看一下在使用生产者和消费者模式改在之后的伪代码逻辑。</span></p><pre spellcheck="false" class="md-fences md-end-block ty-contain-cm modeLoaded" lang="java" style="break-inside: unset;"><div class="CodeMirror cm-s-inner CodeMirror-wrap" lang="java"><div style="overflow: hidden; position: relative; width: 3px; height: 0px; top: 0px; left: 8px;"><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0" style="position: absolute; bottom: -1em; padding: 0px; width: 1000px; height: 1em; outline: none;"></textarea></div><div class="CodeMirror-scrollbar-filler" cm-not-content="true"></div><div class="CodeMirror-gutter-filler" cm-not-content="true"></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer" style="margin-left: 0px; margin-bottom: 0px; border-right-width: 0px; padding-right: 0px; padding-bottom: 0px;"><div style="position: relative; top: 0px;"><div class="CodeMirror-lines" role="presentation"><div role="presentation" style="position: relative; outline: none;"><div class="CodeMirror-measure"><pre><span>xxxxxxxxxx</span></pre></div><div class="CodeMirror-measure"></div><div style="position: relative; z-index: 1;"></div><div class="CodeMirror-code" role="presentation" style=""><div class="CodeMirror-activeline" style="position: relative;"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter" style="left: 0px; width: 0px;"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-keyword">import</span> <span class="cm-variable">java</span>.<span class="cm-variable">util</span>.<span class="cm-variable">concurrent</span>.<span class="cm-variable">ArrayBlockingQueue</span>;</span></pre></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-keyword">public</span> <span class="cm-keyword">class</span> <span class="cm-def">HouseContractAttachmentProcessor</span> {</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp;<span class="cm-comment">// 任务队列</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp;<span class="cm-keyword">private</span> <span class="cm-variable">ArrayBlockingQueue</span><span class="cm-operator">&lt;</span><span class="cm-variable">HouseContractFile</span><span class="cm-operator">&gt;</span> <span class="cm-variable">blockingQueue</span>;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp;<span class="cm-comment">// 消费者线程</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp;<span class="cm-keyword">private</span> <span class="cm-variable">IndexingThread</span> <span class="cm-variable">indexingThread</span>;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp;<span class="cm-keyword">public</span> <span class="cm-variable">HouseContractAttachmentProcessor</span>() {</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp;<span class="cm-comment">// 容量为200的任务队列</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp;<span class="cm-variable">blockingQueue</span> <span class="cm-operator">=</span> <span class="cm-keyword">new</span> <span class="cm-variable">ArrayBlockingQueue</span><span class="cm-operator">&lt;&gt;</span>(<span class="cm-number">200</span>);</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp;<span class="cm-variable">indexingThread</span> <span class="cm-operator">=</span> <span class="cm-keyword">new</span> <span class="cm-variable">IndexingThread</span>(<span class="cm-variable">blockingQueue</span>);</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp;<span class="cm-comment">// 启动消费者线程</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp;<span class="cm-variable">indexingThread</span>.<span class="cm-variable">start</span>();</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  }</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp;<span class="cm-comment">/**</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; <span class="cm-comment">* 处理用户上传电子合同</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; <span class="cm-comment">* @param houseContractFile 电子合同附件</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; <span class="cm-comment">*/</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp;<span class="cm-keyword">public</span> <span class="cm-variable-3">void</span> <span class="cm-variable">uploadHouseContractAttachment</span>(<span class="cm-variable">HouseContractFile</span> <span class="cm-variable">houseContractFile</span>) {</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp;<span class="cm-comment">// 存储业务数据</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp;<span class="cm-variable">saveBizData</span>(<span class="cm-variable">houseContractFile</span>);</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp;<span class="cm-comment">// 存储电子合同附件</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp;<span class="cm-variable">saveAttachmentFile</span>(<span class="cm-variable">houseContractFile</span>);</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp;<span class="cm-comment">// 提交任务到任务队列</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp;<span class="cm-variable">putTask</span>(<span class="cm-variable">houseContractFile</span>);</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp;<span class="cm-comment">// 直接返回</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp;<span class="cm-keyword">return</span>;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  }</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp;<span class="cm-keyword">private</span> <span class="cm-variable-3">void</span> <span class="cm-variable">saveBizData</span>(<span class="cm-variable">HouseContractFile</span> <span class="cm-variable">houseContractFile</span>) {</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp;<span class="cm-variable">System</span>.<span class="cm-variable">out</span>.<span class="cm-variable">println</span>(<span class="cm-string">"==== 存储业务数据完成 ===="</span>);</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  }</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp;<span class="cm-keyword">private</span> <span class="cm-variable-3">void</span> <span class="cm-variable">saveAttachmentFile</span>(<span class="cm-variable">HouseContractFile</span> <span class="cm-variable">houseContractFile</span>) {</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp;<span class="cm-variable">System</span>.<span class="cm-variable">out</span>.<span class="cm-variable">println</span>(<span class="cm-string">"==== 存储合同文件完成 ===="</span>);</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  }</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp;<span class="cm-keyword">private</span> <span class="cm-variable-3">void</span> <span class="cm-variable">putTask</span>(<span class="cm-variable">HouseContractFile</span> <span class="cm-variable">houseContractFile</span>) {</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp;<span class="cm-keyword">try</span> {</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span class="cm-variable">blockingQueue</span>.<span class="cm-variable">put</span>(<span class="cm-variable">houseContractFile</span>);</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp;  } <span class="cm-keyword">catch</span> (<span class="cm-variable">InterruptedException</span> <span class="cm-variable">e</span>) {</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span class="cm-variable">e</span>.<span class="cm-variable">printStackTrace</span>();</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp;  }</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  }</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp;<span class="cm-keyword">static</span> <span class="cm-keyword">class</span> <span class="cm-def">IndexingThread</span> <span class="cm-keyword">extends</span> <span class="cm-variable">Thread</span> {</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp;<span class="cm-keyword">private</span> <span class="cm-variable">ArrayBlockingQueue</span><span class="cm-operator">&lt;</span><span class="cm-variable">HouseContractFile</span><span class="cm-operator">&gt;</span> <span class="cm-variable">blockingQueue</span>;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp;<span class="cm-keyword">public</span> <span class="cm-variable">IndexingThread</span>(<span class="cm-variable">ArrayBlockingQueue</span><span class="cm-operator">&lt;</span><span class="cm-variable">HouseContractFile</span><span class="cm-operator">&gt;</span> <span class="cm-variable">blockingQueue</span>) {</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span class="cm-keyword">this</span>.<span class="cm-variable">blockingQueue</span> <span class="cm-operator">=</span> <span class="cm-variable">blockingQueue</span>;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp;  }</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp;<span class="cm-meta">@Override</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp;<span class="cm-keyword">public</span> <span class="cm-variable-3">void</span> <span class="cm-variable">run</span>() {</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span class="cm-keyword">try</span> {</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span class="cm-comment">// 死循环，从任务队列中取数据进行处理</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span class="cm-keyword">while</span>(<span class="cm-atom">true</span>) {</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span class="cm-variable">HouseContractFile</span> <span class="cm-variable">houseContractFile</span> <span class="cm-operator">=</span> <span class="cm-variable">blockingQueue</span>.<span class="cm-variable">take</span>();</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span class="cm-comment">// 分析附件并生成索引</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span class="cm-variable">createIndex</span>(<span class="cm-variable">houseContractFile</span>);</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  }</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  } <span class="cm-keyword">catch</span> (<span class="cm-variable">Exception</span> <span class="cm-variable">e</span>) {</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span class="cm-variable">e</span>.<span class="cm-variable">printStackTrace</span>();</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  }</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp;  }</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp;<span class="cm-keyword">private</span> <span class="cm-variable-3">void</span> <span class="cm-variable">createIndex</span>(<span class="cm-variable">HouseContractFile</span> <span class="cm-variable">houseContractFile</span>) {</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span class="cm-keyword">try</span> {</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span class="cm-comment">// 耗时2分钟</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span class="cm-variable">Thread</span>.<span class="cm-variable">sleep</span>(<span class="cm-number">20000</span>);</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  } <span class="cm-keyword">catch</span> (<span class="cm-variable">InterruptedException</span> <span class="cm-variable">e</span>) {</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span class="cm-variable">e</span>.<span class="cm-variable">printStackTrace</span>();</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  }</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span class="cm-variable">System</span>.<span class="cm-variable">out</span>.<span class="cm-variable">println</span>(<span class="cm-string">"==== 分析附件并生成索引完成 ===="</span>);</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp;  }</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  }</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">}</span></pre></div></div></div></div></div><div style="position: absolute; height: 0px; width: 1px; border-bottom: 0px solid transparent; top: 1587px;"></div><div class="CodeMirror-gutters" style="display: none; height: 1587px;"></div></div></div></pre><p>&nbsp;</p><h4><a name="-n1556" class="md-header-anchor"></a><span> </span></h4><h4><a name="三总结-n1557" class="md-header-anchor"></a><span>三、总结</span></h4><p><span>上面都是业务功能逻辑实现的伪代码，所以必然会存在一些实现细节上问题，大家能看懂并理解就好。同时这里也抛出一个思考题，就是我们在创建任务队列的时候，直接指定了其容量大小为200，是否存在什么问题呢？任务队列满了之后会发生什么情况呢？在实际项目中到底如何设置任务队列的容量大小才合理呢？大家可以先思考一下这些问题，下一篇文章我们会继续来带着大家来分析一下。</span></p><p>&nbsp;</p><h3><a name="23思维拓展生产者消费者模式是否存在过饱问题" class="md-header-anchor"></a><strong><span>23_思维拓展：生产者/消费者模式是否存在过饱问题</span></strong></h3><p><strong><span>一、前文回顾</span></strong></p><p><span>前面几篇文章我们讲解了生产者-消费者模式的原理和优点，也通过该模式对合同管理平台的真实案例进行项目改造，通过异步化提升了用户上传合同的性能。</span></p><p>&nbsp;</p><p><span>此时看起来似乎并没有什么问题，但在实际生产项目中会有些极端的情况，导致生产者/消费者模式可能出现过饱的问题。</span></p><p><span>我们今天就来分析一下，什么情况下会发生过饱问题，以及发生过饱问题会造成什么影响</span></p><p>&nbsp;</p><p>&nbsp;</p><h4><a name="二什么情况下会发生过饱问题" class="md-header-anchor"></a><span>二、什么情况下会发生过饱问题？ </span></h4><p><span>场景1：生产者速度过快，阻塞队列塞满了，如图1所示：</span></p><p><span>1、阻塞队列大小为1000，生产者每分钟提交300个任务，消费者每分钟消费50个任务</span></p><p><span>2、每分钟队列中净增250个任务</span></p><p><span>3、4分钟，阻塞队列会满</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/8196000_1622946289.png" referrerpolicy="no-referrer" alt="img"></p><p><span>图1</span></p><p>&nbsp;</p><p><span>场景2：生产者速度一般，消费者速度过慢，如图2所示：</span></p><p><span>1、阻塞队列大小为1000，生产者每分钟提交100个任务，消费者每分钟消费5个任务</span></p><p><span>2、每分钟队列净增95个任务</span></p><p><span>3、10分钟左右，队列会满</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/25153900_1622946289.png" referrerpolicy="no-referrer" alt="img"></p><p><span>图2</span></p><p>&nbsp;</p><p><span>场景3：阻塞队列设置太小，但是又不能设置成无界队列 防止内存溢出，然后导致过饱问题，如图3</span></p><p><span>1、阻塞队列大小为100，生产者每分钟提交30个任务，消费者每分钟消费20个任务</span></p><p><span>2、每分钟队列净增10个任务</span></p><p><span>3、10分钟，队列会满</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/43197100_1622946289.png" referrerpolicy="no-referrer" alt="img"></p><p><span>图3</span></p><p>&nbsp;</p><p>&nbsp;</p><h4><a name="三发生过饱问题会造成什么影响" class="md-header-anchor"></a><span>三、发生过饱问题会造成什么影响？</span></h4><p><span>相信大家也能发现，上面几个存在过饱问题的例子有一个共同点。都是单位时间内，生产者生产的速度大于消费者消费的速度，导致任务不断堆积到阻塞队列中，队列堆满只是时间问题。</span></p><p><span>那大家可能会说，只要保证消费者的速度一直比生产者快不就好了，永远都不会堆积过饱。这样的倒是也没毛病，但是会造成严重的资源浪费，一般来说，消费者要处理比较复杂的业务逻辑，而生产者就是往队列里扔数据，消费者是要比生产者慢的。如果要想让消费者的速度一直比生产者快，那只能多部署机器 多起线程，成本是很高的。如图4所示：</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/70167800_1622946289.png" referrerpolicy="no-referrer" alt="img"></p><p><span>图4</span></p><p><span>但是有一点我们要清楚，虽然消费者处理速度慢，可是他可以一直保持住这个速度，只要机器负载正常就不会变。而生产者生产数据，是需要用户参与的，用户不可能一天24小时一直在高速生产的阶段，任何系统都是有访问高峰期和低谷期的，如图5所示：</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/60685300_1622946290.png" referrerpolicy="no-referrer" alt="img"></p><p><span>图5</span></p><p><span>图中的案例就是从12点到15点是系统高峰期，此时的任务会堆积到队列中。但是堆积到队列中的任务会在16点到20点期间被处理掉，因为又到了系统的低谷期。我们可以看黄色的虚线，那个是生产者生成速度的平均值，其实是低于消费者的。所以，我们只要在业务可以容忍的最长响应时间内，把堆积的任务处理完，那就不算过饱。前提是我们要合理的设置队列大小，别在高峰的几个小时把队列塞满了。</span></p><p>&nbsp;</p><h4><a name="四什么是业务容忍的最长响应时间" class="md-header-anchor"></a><span>四、什么是业务容忍的最长响应时间？</span></h4><p><span>顺便解释下什么是业务容忍的最长响应时间，比如埋点数据 统计前一天的数据生成报表，第二天老板要看的，你前一天的数据第二天还没处理完，那就不行，这样的系统我们就要保证，消费者在24小时内的消费能力要比生产者高才行。</span></p><p>&nbsp;</p><h4><a name="五总结-n1604" class="md-header-anchor"></a><span>五、总结</span></h4><p><span>通过上面的案例，大家可以思考一下，我们该如何设置队列的大小？如果条件有限，队列只能设置的较小怎么办？如果上面的例子，业务不允许在20点才处理完积压的任务怎么办？这些问题大家可以先自己思考下解决办法，下篇文章我们再去讲解该如何处理这些问题。</span></p><p>&nbsp;</p><h3><a name="24大开脑洞如何解决生产者消费者模式存在的过饱问题" class="md-header-anchor"></a><strong><span>24_大开脑洞：如何解决生产者/消费者模式存在的过饱问题？</span></strong></h3><p><strong><span>一、上文回顾</span></strong></p><p><span>上篇文章我们讲了生产者-消费者模式存在的一些问题，这篇文章我们来看一下如何解决这些问题，还用上篇文章埋点的例子，我们来看下实际情况下该如何解决这些问题。</span></p><p>&nbsp;</p><h4><a name="二埋点业务介绍" class="md-header-anchor"></a><span>二、埋点业务介绍</span></h4><p><span>1、业务需求</span></p><p><span>  一个埋点功能，统计每天的用户付费情况，第二天老板看报表</span></p><p>&nbsp;</p><p><span>2、要点分析</span></p><ul><li><span>用户每次点击付费功能，我们在业务中添加一个埋点，埋点功能肯定是异步的，也就是生产者-消费者模式</span></li><li><span>最长响应时间是一天，也就是说，在一天内，消费者的能力是比生产者强的</span></li></ul><p>&nbsp;</p><p><span>3、数据准备</span></p><ul><li><span>压测消费者，我们需要知道消费者极限情况下的消费能力，比如：一小时消费一千条数据</span></li><li><span>统计生产者的生成能力，一天大概会有多少消息，可以通过往日的历史数据分析一下</span></li><li><span>统计每天的高峰时段，高峰的几个小时会有多少量如图1所示：</span></li></ul><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/44605300_1622947098.png" referrerpolicy="no-referrer" alt="img"></p><p><span>图1</span></p><p>&nbsp;</p><h4><a name="三场景分析和解决方案" class="md-header-anchor"></a><span>三、场景分析和解决方案</span></h4><p><span>接下来我们分析下都会出现哪些场景</span></p><p><span>场景一：</span></p><p><span>1、消费者每天处理的量比生产者生产的少；如生产者每天1万条，消费者每天只能消费5千条。</span></p><p><span>2、解决办法：消费者加机器</span></p><p><span>3、原因：生产者没法限流，因为要一天内处理完，只能消费者加机器</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/61274400_1622947098.png" referrerpolicy="no-referrer" alt="img"></p><p><span>图2</span></p><p>&nbsp;</p><p><span>场景二：</span></p><p><span>1、消费者每天处理的量比生产者生产的多。</span></p><p><span>2、系统高峰期生产者速度太快，把队列塞爆了</span></p><p><span>3、解决办法：适当的加大队列</span></p><p><span>4、原因：消费者一天的消费能力已经高于生产者，那说明一天之内肯定能处理完，保证高峰期别把队列塞满就好</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/91314100_1622947098.png" referrerpolicy="no-referrer" alt="img"></p><p><span>图3</span></p><p>&nbsp;</p><p><span>场景三：</span></p><p><span>1、消费者每天处理的量比生产者生产的多</span></p><p><span>2、条件有限或其他原因，队列没法设置特别大</span></p><p><span>3、系统高峰期生产者速度太快，把队列塞爆了</span></p><p><span>4、解决办法：生产者限流</span></p><p><span>5、原因：消费者一天的消费能力高于生产者，说明一天内能处理完，队列又太小，那只能限流生产者，让高峰期塞队列的速度慢点</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/6901100_1622947099.png" referrerpolicy="no-referrer" alt="img"></p><p>&nbsp;</p><h3><a name="25源码中的运用来看看生产者和消费者模式在jdk线程池中的应用" class="md-header-anchor"></a><strong><span>25_源码中的运用：来看看生产者和消费者模式在JDK线程池中的应用</span></strong></h3><p><strong><span>一、前文回顾</span></strong></p><p><span>面试中线程池是高频的考点，我们在平时开发经常也会用到，所以掌握线程池的原理对我们来说还是很重要的。在前面的文章《15_源码中的运用：两阶段终止模式在并发线程池中的应用场景》我们讲到两阶段终止模式在线程池中的运用。</span></p><p>&nbsp;</p><h4><a name="二本文内容介绍" class="md-header-anchor"></a><span>二、本文内容介绍</span></h4><p>&nbsp;</p><p><span>其实线程池也运用到了典型的生产者-消费者模式，这篇文章我们将通过源码来分析一下线程池是如何提交任务和消费任务的，又是如何运用到了生产者-消费者模式，到课程后面的线程池模式相关章节，会详细讲解线程池的工作原理和源码。</span></p><p>&nbsp;</p><h4><a name="三图解jdk-线程池的工作原理" class="md-header-anchor"></a><span>三、图解JDK 线程池的工作原理</span></h4><p><span>先通过一幅图看下JDK 线程池的工作原理，学习一个技术时先从整体上了解这个技术的全貌，对我们系统记忆有很大的帮助。看不懂没关系，可以在脑海中有个印象，不懂的地方后续文章会给出答案，如图1所示：</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/16335100_1622948581.png" referrerpolicy="no-referrer" alt="img"></p><p><span>图1</span></p><p><span>关于线程池，有几个比较重要的接口和类，我们先来看下</span></p><ol start='' ><li><span>Executor：代表线程池的接口，有个execute()方法，扔进去一个Runnable类型对象，就可以分配一个线程给你执行</span></li><li><span>ExecutorService：这是Executor的子接口，相当于是一个线程池的接口，有销毁线程池等方法</span></li><li><span>Executors：线程池的辅助工具类，辅助入口类，可以通过Executors来快捷的创建你需要的线程池</span></li><li><span>ThreadPoolExecutor：这是ExecutorService的实现类，这才是正儿八经代表一个线程池的类，一般在Executors里创建线程池的时候，内部都是直接创建一个ThreadPoolExecutor的实例对象返回的，然后同时给设置了各种默认参数</span></li></ol><p>&nbsp;</p><h4><a name="四构造方法" class="md-header-anchor"></a><span>四、构造方法</span></h4><p><span>我们重点来来 ThreadPoolExecutor 这个类 ，先看一下他的构造方法，如下图2所示：</span></p><p>&nbsp;</p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/53748200_1622948581.png" referrerpolicy="no-referrer" alt="img"></p><p><span>图2</span></p><p><span>一共有7个参数，我们来简单介绍下这几个参数的含义，到课程后面的线程池模式相关章节会非常详细的介绍这几个参数的意义</span></p><ul><li><span>corePoolSize：线程池里的核心线程数量</span></li><li><span>maximumPoolSize：线程池里允许有的最大线程数量</span></li><li><span>keepAliveTime：如果线程数量大于corePoolSize的时候，多出来的线程会等待指定的时间之后就被释放掉，这个就是用来设置空闲线程等待时间的</span></li><li><span>unit：这个是上面那个keepAliveTime的单位</span></li><li><span>workQueue：这个是说，通过ThreadPoolExecutor.execute()方法扔进来的Runnable工作任务，如果所有线程都繁忙，会进入一个队列里面去排队，这就是那个队列</span></li><li><span>threadFactory：如果需要创建新的线程放入线程池的时候，就是通过这个线程工厂来创建的</span></li><li><span>handler：假如说上面那个workQueue是有固定大小的，如果往队列里扔的任务数量超过了队列大小，咋办？就用这个handler来处理</span></li></ul><p><span>workQueue这个参数是我们这节课的关键，通过这个队列我们就可想到解耦、削峰，也就是生产者-消费者模式，我们可以把上面的图简化一下，就是下面的模型，如下图3所示：</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/69453500_1622948581.png" referrerpolicy="no-referrer" alt="img"></p><p><span>图3</span></p><p>&nbsp;</p><h4><a name="五任务如何被提交" class="md-header-anchor"></a><span>五、任务如何被提交？</span></h4><p><span>用户线程提交任务，执行的是execute方法，具体代码如下图4所示：</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/91937300_1622948581.png" referrerpolicy="no-referrer" alt="img"></p><p><span>图4</span></p><p><span>源码含义：</span></p><ul><li><span>[1] 如果任务为null，抛出NPE异常</span></li><li><span>[2] 原子变量ctl共同存储 线程状态+线程个数。说白了就是用一个int型变量存储两个数，高3位表示线程状态，后面29位表示线程的个数</span></li><li><span>[3] 判断当前线程数 是否小于 核心线程数， 如果小于，开启新的线程执行任务</span></li><li><span>[4] 如果线程池处于RUNNING状态，添加任务到阻塞队列</span></li><li><span>[5] 重新获取下ctl的值，因为把任务添加到队列时，线程的状态可能已经改变，这里重新获取下</span></li><li><span>[6] 线程状态不是RUNNING状态，从队列里删除</span></li><li><span>[7] 如果当前线程池一个线程也没有，添加一个线程</span></li><li><span>[8] 如果队列满了，则添加新的线程（非核心线程），如果新增失败，执行拒绝策略</span></li></ul><p>&nbsp;</p><h4><a name="六任务是如何被线程池消费的" class="md-header-anchor"></a><span>六、任务是如何被线程池消费的？</span></h4><p><span>这就是用户线程生产一个任务的整个流程，接下来，我们看一下工作线程是如何消费这些任务的，我们先来看下工作线程Worker 类，如下图5所示：</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/14556100_1622948582.png" referrerpolicy="no-referrer" alt="img"></p><p><span>图5</span></p><p>&nbsp;</p><p><span>Worker类实现了Runnable接口，当线程启动后，就会去执行run() 方法。所以，我们重点去看下run() 方法里是如何消费一个任务的，如下图6所示：</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/29397500_1622948582.png" referrerpolicy="no-referrer" alt="img"></p><p><span>图6</span></p><p>&nbsp;</p><p><span>run() 方法的实现是runWorker方法，我们继续点进去看runWorker()方法，如下图7所示：</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/55305600_1622948582.png" referrerpolicy="no-referrer" alt="img"></p><p><span>图7</span></p><p>&nbsp;</p><p><span>重点是 task = getTask() ,getTask() 看这个方法名就知道使我们要找的方法，我们再看下getTask() 方法，如下图8所示：</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/95741800_1622948582.png" referrerpolicy="no-referrer" alt="img"></p><p><span>图8</span></p><p><span>可以看到，这里是去从队列里去取了一个任务出来执行。</span></p><p>&nbsp;</p><p>&nbsp;</p><h4><a name="七总结-n1748" class="md-header-anchor"></a><span>七、总结</span></h4><p><span>这篇文章我们重点讲了线程池的生产者-消费者模式，后面会有专门的文章讲解线程池源码细节和原理。</span></p><p>&nbsp;</p><h3><a name="26图文讲解active-object-模式的工作原理" class="md-header-anchor"></a><strong><span>26_图文讲解：Active Object 模式的工作原理</span></strong></h3><h4><a name="一开篇词-n1752" class="md-header-anchor"></a><span>一、开篇词</span></h4><p><span>Active Object模式，主动对象模式，名字乍一听，可能觉得有点陌生，但其实也是我们日常常用的，一种异步编程模式，就是将方法的调用和方法的执行分开，放在两个线程中执行。</span></p><p>&nbsp;</p><h4><a name="二同步调用" class="md-header-anchor"></a><span>二、同步调用</span></h4><p><span>通常我们的代码中，同步调用居多，方法的调用和执行在同一个线程中完成，如下图1所示，首先客户端发起请求，服务端收到请求后处理，直到处理完成后，才返回响应给客户端。</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/65525500_1623891386.png" referrerpolicy="no-referrer" alt="img"></p><p><span>图1</span></p><p>&nbsp;</p><h4><a name="三异步调用" class="md-header-anchor"></a><span>三、异步调用</span></h4><p><span>异步调用是，客户端发起一个请求，服务端接受后立即返回响应给客户端，然后在合适的时候，由服务端的一个后台线程去处理该请求。图2标识了每一个操作步骤的顺序，服务端接受到请求后，发给工作线程，同时不等工作线程的处理结果，先返回给客户端。</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/90837200_1623891386.png" referrerpolicy="no-referrer" alt="img"></p><p><span>图2</span></p><p><span>然后，再说个大家都很略有了解的经典的垃圾回收场景。通常，我们想自己控制垃圾回收时，可能会调用System.gc()这个方法，但是我们也都不清楚什么时候会进行垃圾回收，调用完之后只是给jvm发了个垃圾回收的请求，并不意味着马上就会进行一轮垃圾回收，具体什么时候执行垃圾回收，要看jvm自己的安排。如下图3所示</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/16414700_1623891387.png" referrerpolicy="no-referrer" alt="img"></p><p><span>图3</span></p><p>&nbsp;</p><p>&nbsp;</p><h4><a name="四active-object模式" class="md-header-anchor"></a><span>四、Active Object模式 </span></h4><p><span>说完了异步我们再说说Active Object模式。为了简化异步调用的复杂性，主动对象模式分离了方法的执行和调用。使用这个模型，无论一个对象中是否有独立的线程进行异步调用，客户端从外部访问它时，感觉是一样的。主动对象模型由六大组件组成：</span></p><p>&nbsp;</p><p><span>1、Proxy</span></p><p><span>这其实可以理解为一个代理对象，主要用于对外暴露异步方法。包含asyncService方法，这是主动对象模型执行的入口。在主动对象模式中，请求都是先发往Proxy的asyncService方法。然后不等具体逻辑执行完成，很快返回一个Futrue对象给客户端。</span></p><p>&nbsp;</p><ol start='' ><li><span>Future</span></li></ol><p><span>主动对象模型是一种异步模式，任务的提交和执行是分离的，而且任务从提交到执行完成可能需要较长时间，甚至是不固定，那客户端发完请求后要怎么才能知道任务的执行结果呢？Futrue实例其实就是用来获取执行结果的。客户端提交任务后，Proxy会立马返回一个Futrue对象。客户端拿到这个对象，需要时就可以通过Futrue对象来获取任务执行结果。任务从提交到返回Futrue的过程如图4所示：</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/44340500_1623891387.png" referrerpolicy="no-referrer" alt="img"></p><p><span>图4</span></p><ol start='' ><li><span>MethodRequest</span></li></ol><p><span>在请求发给Proxy时，Proxy不会直接处理这个请求，而是会将请求参数等上下文信息封装为一个MethodRequest对象。MethodRequest对象中包含了一个核心方法call。为了方便理解，粗略一点来讲，你可以类比为Runnable和其中的run方法。都是为了后面我们的异步调用服务的。</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/71261600_1623891387.png" referrerpolicy="no-referrer" alt="img"></p><p><span>图5</span></p><p><span>4）ActivationQueue</span></p><p><span>ActivationQueue即任务缓冲区，是Active Object模式中的另一个重要组件。通过上面几个组件的介绍，我们知道，客户端请求是首先会发往Proxy，在Proxy中会将请求上下文信息封装成MethodRequest对象，但如果请求太多，超过了工作线程的处理上限，那多出的MethodRequest对象要怎么办呢？即使现在不能处理但也总不能直接扔掉吧，所以这时为了解决这个问题，我们自然就有了这样一个缓冲区来缓存那些来不及处理的MethodRequest对象，等待工作线程有空闲时再从缓冲区中读取出任务来执行。</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/99324000_1623891387.png" referrerpolicy="no-referrer" alt="img"></p><p><span>图6</span></p><p>&nbsp;</p><p><span>ActivationQueue包含两个方法，如下：</span></p><p><span>enqueue：将Proxy传入过来的MethodRequest对象放到缓存区中。</span></p><p><span>dequeue：从缓冲区中取出一个MethodRequest对象。</span></p><p>&nbsp;</p><p><span>5）Scheduler</span></p><p><span>Scheduler即调度器。前面我们说过Active Object模式，是一种异步编程模式，会将方法的调用和执行分开，但是什么时候执行，如何执行，这个其实不是由任务提交者（客户端）来控制的，那这是由什么在控制呢？答案呼之欲出，就是由我们这里的Scheduler调度器去控制。</span></p><p>&nbsp;</p><p><span>前面我们讲了MethodRequest和ActivationQueue，但实际上，MethodRequest在Proxy中创建后并不是直接发到缓冲区，而是先发到Scheduler，由调度器来操作缓冲区。然后Scheduler会按照一定的策略，比如先进先出或后进先出，来进行调度。这两处逻辑主要是通过下面这两个方法来进行的：</span></p><p>&nbsp;</p><p><span>enqueue：接受一个MethodRequest实例，并将其存入缓冲区。</span></p><p><span>dispatch：反复地从缓冲区中取出MethodRequest实例进行执行。</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/23309200_1623891388.png" referrerpolicy="no-referrer" alt="img"></p><p><span>图7</span></p><p><span>6）Servant:</span></p><p><span>Servant实现了Proxy所暴露的异步方法。并且负责执行Proxy所暴露的异步方法对应的任务。学到这里你可能会觉得有点云里雾里，其实可以这么理解，我们的任务是在Proxy处提交，但真正执行是在这里。执行完成之后，会将执行结果绑定到Futrue实例上。前面我们也说过，我们要获取任务执行结果，是通过Futrue实例来的，但前提必须是在这里完成了对结果的设置。</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/47778400_1623891388.png" referrerpolicy="no-referrer" alt="img"></p><p><span>图8</span></p><h4><a name="四总结-n1809" class="md-header-anchor"></a><span>四、总结</span></h4><p><span>今天，我们从异步、同步的区别开始，分析了Active Object模式的一些基本概念，和任务的执行过程。相信你看完后，对主动对象模式还是充满着疑问。没关系，这种模式，本身就是有一定的复杂度的。要更深一步理解，可以跟随我们的脚步，在后面几篇文章中再进行深入分析，敬请期待。</span></p><p>&nbsp;</p><h3><a name="27抛砖引玉如何解决移动互联网短网址转换失败造成数据丢失问题" class="md-header-anchor"></a><strong><span>27_抛砖引玉：如何解决移动互联网短网址转换失败造成数据丢失问题</span></strong></h3><p><span>在很多互联网应用中，一般都会有长网址和短网址之间的转换。比如，用户在某网站发布一篇图文，那么肯定会生成该图文对应的长网址，同时大多数网站还会有一个对应的短网址，如图1</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/45246800_1623892535.png" referrerpolicy="no-referrer" alt="img"></p><p><span>图1</span></p><p><span>用户后续在客户端（比如手机app）浏览时对应的就可以是短网址了，然后就可以用该短网址去访问该图文的具体内容。这有点像我们熟知的手机短号。如图2</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/70966500_1623892535.png" referrerpolicy="no-referrer" alt="img"></p><p><span>图2</span></p><p><span>有个长网址可以理解，为什么还要多此一举搞个短网址呢？主要有以下几个方面的原因：</span></p><ol start='' ><li><span>一些社交媒体比如微博，是有限制字长的，地址长了，会影响用户发出其他正文内容。</span></li><li><span>用短网址进行数量追踪和统计更方便。</span></li><li><span>如果链接地址太长，在用户看来，视觉上不友好。</span></li><li><span>有些长网址中可能会包含#或者@等特殊字符，这些特殊字符会给客户端的字符串处理带来压力。</span></li></ol><p>&nbsp;</p><p><span>如果上面说的这几点你还没有很深体会的话，那我再举个生活中的小例子。长网址就像我们人的身份证号。但是身份证号太长，没人记得住别人的身份证号，在日常交往中直接用身份证号不是很方便，所以我们还需要取个名字。长网址也同理，有些很长，不便使用，所以需要取个别名。比如，如下的一个长网址</span></p><p><a href='http://xxxxx.com/xxxxx.html?xxxx=xxx&amp;' target='_blank' class='url'>http://xxxxx.com/xxxxx.html?xxxx=xxx&</a><span> xxxx=xxx&amp; xxxx=xxx&amp; xxxxx=xxxx&amp; xxxx=xx</span></p><p><span>经过转换生成一个短网址，是如下这样子的：</span></p><p><a href='http://t.cn/XsqaGA9d' target='_blank' class='url'>http://t.cn/XsqaGA9d</a></p><p><span>看到这个短网址，是不是会感觉很清爽。那怎么把一个长网址转换成短网址呢？其实还是挺简单，下面为一段将长网址转换为短网址的简易代码，仅供参考。</span></p><p>&nbsp;</p><pre spellcheck="false" class="md-fences md-end-block ty-contain-cm modeLoaded" lang=""><div class="CodeMirror cm-s-inner CodeMirror-wrap" lang=""><div style="overflow: hidden; position: relative; width: 3px; height: 0px; top: 0px; left: 8px;"><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0" style="position: absolute; bottom: -1em; padding: 0px; width: 1000px; height: 1em; outline: none;"></textarea></div><div class="CodeMirror-scrollbar-filler" cm-not-content="true"></div><div class="CodeMirror-gutter-filler" cm-not-content="true"></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer" style="margin-left: 0px; margin-bottom: 0px; border-right-width: 0px; padding-right: 0px; padding-bottom: 0px;"><div style="position: relative; top: 0px;"><div class="CodeMirror-lines" role="presentation"><div role="presentation" style="position: relative; outline: none;"><div class="CodeMirror-measure"><pre><span>xxxxxxxxxx</span></pre></div><div class="CodeMirror-measure"></div><div style="position: relative; z-index: 1;"></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline" style="position: relative;"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter" style="left: 0px; width: 0px;"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">Private static final String[] X36_ARRAY = "0,1,2,3,4,5,6,7,8,9,A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W,X,Y,Z".split(",");public String getShortUrl(String url) { &nbsp; long shortUrlSeed = jedis.incr("short_url_seed"); &nbsp; StringBuffer buffer = new StringBuffer(); &nbsp; &nbsp; &nbsp;  while(shortUrlSeed &gt; 0) { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  buffer.append(X36_ARRAY[(int)(shortUrlSeed % 36)]); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  shortUrlSeed = shortUrlSeed / 36; &nbsp; &nbsp; &nbsp;  } &nbsp; &nbsp; &nbsp;  //获取到短链接 &nbsp; &nbsp; &nbsp;  String shortUrl = buffer.reverse().toString(); &nbsp; &nbsp; &nbsp;  return shortUrl;}</span></pre></div></div></div></div></div></div><div style="position: absolute; height: 0px; width: 1px; border-bottom: 0px solid transparent; top: 161px;"></div><div class="CodeMirror-gutters" style="display: none; height: 161px;"></div></div></div></pre><p>&nbsp;</p><p><span>可以自己用一个长网址测试一下上面这段代码，看看生成的短网址是不是简单到让你惊讶。网址转换为短网址之后，用户使用更方便，应用内部做数据统计和更新也更方便。但是，我们在应用内部大多数场合还是需要长网址。用户在客户端上访问一个博文时传递过来的是短网址，但是要完成访问功能还是需要先转化为长网址。这就好比，用了姓名，我们很多时候还是需要使用身份证号去办理一些业务。</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/10862400_1623892536.png" referrerpolicy="no-referrer" alt="img"></p><p><span>图3</span></p><p><span>上面的代码了给出了长网址转换为短网址的做法，但是如果要将短网址转化为长网址要怎么实现了？其实很简单，在上面的长短网址转换服务中，将长网址转换为短网址完成后，立马将长短网址的映射关系保存起来，比如保存到数据库中。</span></p><p><span>然后用户访问时传递短网址地址，服务端会先去地址转换服务查询对应的长网址，对于地址转换服务的逻辑处理也很简单，直接去数据库里查询长短网址映射表，根据当前的短连接查询出对应的长网址。</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/37358300_1623892536.png" referrerpolicy="no-referrer" alt="img"></p><p><span>图4</span></p><p><span>对于我们经常开发服务端的程序员都比较清楚，数据库不是任何时候都一定能做到100%的高可用的。所以如果我们在根据短网址查询长网址时发生宕机了。那肯定是无法完成这次转换操作，该请求将无法继续进行下去。进而导致本次请求失败，数据丢失。那失败之后我们也不能直接忽略，通常我们需要针对这种情况记录一下这些失败的消息，比如，将他们记录到数据库中，如图</span></p><p>&nbsp;</p><p>&nbsp;</p><p><span>然后我们可以在应用中再写点代码将刚保存到数据库中的失败请求信息读取出来，根据你所期望的需求，对它做些统计分析，以BI报表的信息显示出来。如图</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/62433200_1623892536.png" referrerpolicy="no-referrer" alt="img"></p><p><span>图5</span></p><p><span>那么这篇文章到这里就结束了。此文我们用大白话，加上一步一图的方式，分析了互联网应用常用的长短网址转换，及因为长短网址转换故障导致的请求失败问题。</span></p><p>&nbsp;</p><h3><a name="28案例实战如何基于主动对象模式完成对移动互联网短网址服务改造" class="md-header-anchor"></a><span>28_案例实战：如何基于主动对象模式，完成对移动互联网短网址服务改造</span></h3><p><span>上一节提到，在很多互联网应用中，都同时存在长网址、短网址这两个概念。以发布一篇图文信息为例，其主要流程是用户编辑好图文信息后，调用服务端接口进行发布，服务端在发布时会生成长网址，然后也会生成一个短网址，并将长短网址的映射关系保存到数据库中。</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/2443400_1623892752.png" referrerpolicy="no-referrer" alt="img"></p><p><span>图1</span></p><p><span>大概流程如图所示，其中生成短网址和将长短网址的映射关系保存到数据库中，这一部分逻辑通常是有个专门的长短网址转换服务。这里可能出现一些故障，比如长短网址转换服务挂了，或者该服务对应的数据库宕机，都可能导致我们发布图文信息时短网址生成失败，最终造成图文发布失败，如果此时提示用户“发布失败，请稍后再试”，用户体验会有点差。</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/19586300_1623892752.png" referrerpolicy="no-referrer" alt="img"></p><p><span>图2</span></p><p><span>最好的方式：在短网址的生成失败的时候，在需要用到短网址的地方，直接降级为长网址去替代。</span></p><p>&nbsp;</p><p><span>但短网址你最终还是需要用到的，所以长短网址转换失败可以暂时跳过，让用户把图文先发布成功，但是后面故障恢复后还是得继续处理该地址转换。那要怎么办呢？我们可以先把这次请求上下文信息缓存起来，缓存到内存或磁盘都可以，具体看需求。这里就以缓存到磁盘为例吧，通过java的一些序列化API可以很方便的将对象序列化到磁盘上。</span></p><p>&nbsp;</p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/40636700_1623892752.png" referrerpolicy="no-referrer" alt="img"></p><p><span>图3</span></p><p><span>然后，等长短网址服务恢复可用后，再从磁盘中读取请求消息，然后将请求消息中的长网址读取出来，并传递给长短网址转换服务，长短网址转换服务收到该请求后，会根据该长网址生成短网址，并将该长短网址一起写入mysql。</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/57827900_1623892752.png" referrerpolicy="no-referrer" alt="img"></p><p><span>图4</span></p><p><span>由长短网址转换服务故障导致的用户发布图文时短网址无法生成的问题就这样得到了较好的解决。但是现在还有一个问题，把请求消息刷到磁盘涉及到I/O，速度很慢。如果每次短网址生产故障都要刷到磁盘上才响应给客户端，这个延迟比较大。而且系统的工作线程是有限的，单个请求处理的时间过长，毫无疑问也会降低系统的吞吐量。</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/72681400_1623892752.png" referrerpolicy="no-referrer" alt="img"></p><p><span>图5</span></p><p><span>这里的性能瓶颈主要就是请求信息进行磁盘IO的过程带来，那如果可以将这个磁盘IO过程交给另外的线程来做，主线程并不参与那岂不是就能解决这个问题了？这时，我们就很自然的能想到用异步刷盘的策略，注意，异步思想可是性能优化降低延时的一大利器。</span></p><p>&nbsp;</p><p><span>那怎么来实现这个异步呢？其实可以基于前面几篇文章介绍过的Active Object模式来实现。对于请求信息刷盘这一耗时任务，可以用Active Object模式来实现其提交和执行的分离。任务是在主线程中提交，而执行则是交给Active Object的工作线程来处理。主要流程参考图：</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/96228100_1623892752.png" referrerpolicy="no-referrer" alt="img"></p><p><span>图6</span></p><p><span>完整的流程如下：</span></p><p><span>1）用户在本地编辑好一篇图文，然后调用接口发给服务端发布。</span></p><p><span>2）服务端主线程调用长短网址转换服务将长网址转换为短网址。</span></p><p><span>3）长短网址转换服务根据请求过来的长网址地址，生成对应的短网址，并将长短网址的映射关系保存到数据库中。</span></p><p><span>4）如果步骤2）和步骤3）执行失败，服务端主线程感知到后立马将请求信息封装并提交给Active Object模式的工作线程，同时快速返回给用户。从用户端来看，本次请求执行完成。</span></p><p><span>5）Active Object模式的工作线程根据自定义的策略在适当的时机将请求缓存刷盘。</span></p><p><span>6）当长短网址转换服务恢复可用后，主线程又可以通知Active Object模式的工作线程按照其策略将请求加载出来，并解析发给长短网址转换服务生成对应的短网址，并将该长短网址的映射关系保存到数据库中。</span></p><p>&nbsp;</p><p><span>到目前为止，我们比较妥善的解决了长短网址转换服务故障问题，也用Active Object模式解决了刷磁盘太慢的性能问题，从而提高了系统响应性能和吞吐量。现在每次根据短网址查询长网址失败后，都会将该请求消息保存为一个磁盘文件，但现在我们可能有个要求，不希望这些磁盘文件保存在同一个目录下，而是希望他们分散存储在多个目录中。比如，我们的需求是，每个目录最多存储1000个请求文件，当某个目录达到这个上限后，就建一个新的目录来做下一请求文件的存储直到该目录也满那就再建一个新的，以此类推。但是目录数也是有上限的，当达到1000个，再往下增加就会删除最老的一个目录。很明显，在并发情况下，需要考虑些线程安全性的问题。</span></p><p>&nbsp;</p><p><span>线程安全方面的控制可以在服务端处理请求的主线程中实现，但是为了简化主线程的处理逻辑，这块并发控制的逻辑也可以完全封装在Active Object模式中。这样，对于请求处理的主线程来说，完全不用关心线程安全的问题，只需要在长短网址转换服务故障时封装请求信息提交给Active Object模式的主线程即可。</span></p><p>&nbsp;</p><h3><a name="29动手演练手把手带你编写基于可复用的主动对象模式的proxy代码" class="md-header-anchor"></a><strong><span>29_动手演练：手把手带你编写基于可复用的主动对象模式的Proxy代码</span></strong></h3><p><span>前面几篇文章，我们用大白话讲解了主动对象模式的一些基本概念和架构，也引入一个互联网领域比较常见的长短网址转换服务的案例，并基于主动对象模式优化了这个服务。</span></p><p>&nbsp;</p><p><span>相信通过前面几篇文章的讲解，你对这主动对象模式也有了一个相对深入的了解，其核心思想，就是通过将调用和执行过程分离，实现异步编程模式。这样做有两个优点，第一提高了系统的并发能力和吞吐量；第二降低了系统的耦合性，如果具体的执行逻辑要修改，不会影响到调用方，维护起来比较方便。</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/41148700_1623893101.jpeg" referrerpolicy="no-referrer" alt="img"></p><p><span>图1</span></p><p><span>除了上面这些优点，当然也存在一些缺陷。如图1所示，该模式共有六个组件：Proxy，Future，MethodRequest，ActivationQueue，Scheduler，Servant。如果你还不太了解这六个组件，可以移步前面的文章（27_图文讲解：Active Object 模式的工作原理）进行复习</span></p><p>&nbsp;</p><p><span>我们要从零开始将这一模式完整的落地，工作量还是比较大的。因为要考虑到各组件之间的交互，比如创建MethodRequest对象，将其对象放入和移出缓冲区，对其调度和执行。但也不要被吓到哦，虽然这个模式组件众多，但大部分组件我们是可以利用JDK现有的类实现。</span></p><p><span>1）Future</span></p><p><span>在主动对象模式中，客户端提交任务后，Proxy会立马返回一个Futrue对象。客户端拿到这个对象，在需要时就可以通过Futrue对象来获取任务执行结果。这个组件所需的功能，可以由jdk的java.util.concurrent包下的Futrue类来实现。</span></p><p><span>2）MethodRequest</span></p><p><span>当请求发给Proxy时，Proxy不会直接处理这个请求，而是会将请求参数等上下文信息封装为一个MethodRequest对象。说白了，MethodRequest就是用于封装异步任务的。这个我们应该很容易想到，可以用jdk的java.lang.Runnale或者concurrent包下的Callable，具体是用Runnale还是Callable，看你是否需要返回值。</span></p><p>&nbsp;</p><p><span>3）ActivationQueue</span></p><p><span>ActivationQueue是主动对象模式中的任务缓冲区。说白了，就是一块内存存储空间，最好是一个有顺序的队列。主要用途就是缓存不能马上被执行的MethodRequest对象，然后等待工作线程空闲时，从其中读取出任务来执行。实现这个任务缓冲区的选择比较多，jdk帮我们实现了一些队列可以直接使用，比如java.util.concurrent包下的LinkedBlockingQueue。</span></p><p>&nbsp;</p><p><span>4）Scheduler</span></p><p><span>Scheduler即调度器。Scheduler之于主动对象模式，就像人的大脑，电脑的CPU。控制着MethodRequest对象的执行时机和过程。这个组件你可以使用ThreadPoolExecutor，对，就是线程池，当然如果你有其他需求，也可以自己实现并发包下的ExecutorService接口。</span></p><p>&nbsp;</p><p><span>通过上面的讲解，是不是松了一口气，似乎我们啥也不用干，直接使用jdk底层的一些工具类就可以实现Active Object模式了。等等，与客户端线程交互的Proxy，还是需要我们自己实现的。</span></p><p>&nbsp;</p><p><span>先回顾下前面讲的内容，Proxy是一个代理对象，主要用于将真实的方法实现逻辑隐藏，同时对外暴露异步方法入口。Java中有两种代理方式：静态代理、动态代理。</span></p><p>&nbsp;</p><p><span>用静态代理的方式来实现Proxy，相对于动态代理，其执行效率会更高一点，但缺点是需要提前编写好静态代理类，而且这个代理类难以扩展，当后面需求有变化时，需要修改甚至新建代理类，从而使得Proxy难以被复用。</span></p><p>&nbsp;</p><p><span>因为我们的要求是“可复用”，所以我们会采用可复用的动态代理的方式实现Proxy。要实现动态代理，首先，第一步就是定义一个类，实现InvocationHandler，如果到这里你发现看不懂了，可以自己找找资料，本文限于篇幅也为了聚焦主题就不展开了。</span></p><p>&nbsp;</p><p><span>每一个动态代理类的调用处理程序都必须实现InvocationHandler接口。</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/63116400_1623893101.png" referrerpolicy="no-referrer" alt="img"></p><p><span>图2</span></p><p><span>如图2所示，通常我们会这样写一个InvocationHandler实现类。其中target是被代理的对象，在重写的invoke方法中，实现了对真正业务方法的调用。这里对业务方法的调用是同步的，但是我们的Active Object需要的是异步，所以需要在CustomInvocationHandler中引入Scheduler组件，并在invoke方法中提交给Scheduler组件。这时，CustomInvocationHandler类是这样的，如图3所示。</span></p><p>&nbsp;</p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/78659100_1623893101.png" referrerpolicy="no-referrer" alt="img"></p><p><span>图3</span></p><p><span>其中，用的Scheduler是jdk并发包下的ExecutorService，返回值组件是前面内容提到的Futrue类。</span></p><p>&nbsp;</p><p><span>上面的代码简单，但把Proxy组件的处理基本展现出来了。然而，我们也可以看到上面代码submit的任务只是一个“xxx”，所以还需要再改造下，怎么改造呢？看了这几天的文章应该就知道了，是将请求信息封装为一个MethodRequest对象。</span></p><p>&nbsp;</p><p><span>上面也提到了MethodRequest组件可以通过Runnale或者Callable来实现。因为我们需要返回值，所以这里选择Callable。这时，CustomInvocationHandler类是这样的，如图4所示。</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/564400_1623893102.png" referrerpolicy="no-referrer" alt="img"></p><p><span>图4</span></p><p><span>InvocationHandler实现类的主要逻辑就是这样的，当然这里省略了部分代码，比如call方法，其实就是封装了对后端真实业务逻辑的调用处理，我们只关注主干流程。其他的开发时按需求和自身喜好完善就好。</span></p><p>&nbsp;</p><p><span>下一步借助于java动态代理机制中的Proxy类(注意：不要和Active Object模式中的Proxy组件概念混淆了)来创建代理就可以了。具体方法如图5所示。</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/19226200_1623893102.png" referrerpolicy="no-referrer" alt="img"></p><p><span>图5</span></p><p><span>其中：</span></p><p><span>第一个参数表示Active Object模式中对外暴露的接口，是一个标准的动态代理需要传递的参数，因为jdk动态创建代理的过程中必须用到委托类实现的接口。</span></p><p><span>第二个参数是传入Scheduler调度器，这里使用jdk并发包下的ExecutorService。</span></p><p><span>第三个参数则是Active Object模式的重要组件Servant。实现了Proxy所暴露的异步方法，并且负责执行Proxy所暴露的异步方法对应的任务。</span></p><p>&nbsp;</p><p><span>好了，目前可复用的Active Object模式的Proxy组件代码已经编写好了。核心思路就是通过jdk动态代理生成委托类Servant的代理对象。然后当客户端请求委托类Servant的方法时，会被InvocationHandler实现类给拦截，并转发给代理对象处理。</span></p><p>&nbsp;</p><h3><a name="30源码分析主动对象模式在线程池源码中的应用" class="md-header-anchor"></a><strong><span>30_源码分析：主动对象模式在线程池源码中的应用</span></strong></h3><p><span>在前几篇文章中我们提到过要实现主动对象模式，有几大组件可以直接使用jdk提供的工具类实现。让我们对照下图（图1），回顾下主动对象模式的几个组件和他们的交互流程。</span></p><p>&nbsp;</p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/17542700_1623893423.jpeg" referrerpolicy="no-referrer" alt="img"></p><p><span>图1</span></p><p>&nbsp;</p><p><span>其中，组件Future可用jdk的concurrent包下的Futrue类来实现；</span></p><p><span>MethodRequest可用jdk的java.lang.Runnale或者concurrent包下的Callable类来实现；</span></p><p><span>ActivationQueue可用concurrent包下的LinkedBlockingQueue来实现；</span></p><p><span>Scheduler组件可用ThreadPoolExecutor来实现调度功能。</span></p><p><span>看到这里，有没有一种熟悉的气息扑面而来，对，他们都是线程池的重要组成部分。</span></p><p>&nbsp;</p><p><span>无论是jdk提供的线程池，还是我们自定的线程池，都是需要基于并发包下的ThreadPoolExecutor类来实现，而ThreadPoolExecutor类其实就是Active Object模式的一种实现方式。具体怎么实现，请听我娓娓道来。</span></p><p>&nbsp;</p><p><span>1、请求上下文封装</span></p><p><span>我们要使用线程池，一般需要将任务封装为Runnale或者Callable对象，那Runnale或者Callable类就是MethodRequest的实现。</span></p><p>&nbsp;</p><p><span>2、任务提交</span></p><p><span>图1中的Proxy组件对外暴露了一个asyncService方法，这个就是用于主动对象模式中客户端提交任务的方法。在线程池中也同样需要有这么一个方法，经过上一步客户端对请求上下文封装好之后，就可以通过该方法提交给线程池。线程池主要有以下几种提交任务的方式：</span></p><p><span>1）void execute(Runnable command);</span></p><p><span>2）</span><T><span> Future</span><T><span> submit(Callable</span><T><span> task);</span></p><p><span>3）</span><T><span> Future</span><T><span> submit(Runnable task, T result);</span></p><p><span>4）Future&lt;?&gt; submit(Runnable task);</span></p><p><span>这几种方式，底层对应的逻辑都是一样。最终都会调用execute(Runnable command)方法，剩下几个方法都是对这个方法的封装。</span></p><p>&nbsp;</p><p><span>3、返回futrue对象</span></p><p><span>在主动对象模式中，如果你需要返回值，那提交之后就可拿到一个Futrue对象。在线程池中如果你需要返回值，就将任务封装为Callable对象提交，然后可以拿到一个Futrue对象。</span></p><p>&nbsp;</p><p><span>4 、ActivationQueue缓冲区</span></p><p><span>在主动对象模式中，有个组件叫缓冲区，用于临时存储提交任务所封装的MethodRequest对象。在线程池中当然也有这一个组件，而且在线程池中这个组件有多种实现方式。在jdk提供的几种常用线程池中：fixedThreadPool和singleThreadExecutor用的是LinkedBlockingQueue；</span></p><p><span>cachedThreadPool用的是SynchronousQueue。</span></p><p><span>如果你需要自定义线程池，那也可以同时实现一个自定义ActivationQueue缓冲区。</span></p><p>&nbsp;</p><p><span>5、提交和执行分离的思想</span></p><p><span>如果你熟悉线程池，那应该清楚线程池也是将“任务的提交”和“任务的执行”分离，执行过程对客户端来说是透明的，客户端也不需要去关注具体的执行过程的细节，只需要关注任务本身，如提交任务、获取结果、取消任务。从这点来看，完全符合Active Object模式。</span></p><p><span>6、线程池是如何调度和执行任务</span></p><p><span>这部分对应于主动对象模式中Scheduler组件。对于客户端来说，在使用线程池时只需要做两步，首先，根据需求将任务封装为Runnable或者Callable对象。然后调用上面几个方法中的一个提交任务就可以返回了。至于该任务怎么在线程池内执行，什么时候执行都是透明的，也无须去关心。在这里，为了满足我们好奇心，不妨探索一番。</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/35656900_1623893423.jpeg" referrerpolicy="no-referrer" alt="img"></p><p><span>图2</span></p><p><span>核心逻辑就在图2中。首先，一个任务提交到线程池后，系统首先会判断当前活跃线程数是否少于设定的核心线程数，如果是，则创建一个核心线程来处理该任务。只要当前线程数少于核心线程数，在这个范围内，就会来一个任务，创建一个线程。</span></p><p>&nbsp;</p><p><span>但当一个任务过来后，发现当前活跃线程数大于设定的核心线程数时就不再创建线程，而是先把该任务放到一个内存队列中。线程空闲了就会去队列中读取新任务执行。这两块总结起来就是这样，任务过来时，核心线程未满就创建核心线程，否则就添加到队列中去排队。核心线程执行完一个任务后会去队列中读取，这样排队的任务都会有被执行的机会。</span></p><p>&nbsp;</p><p><span>当在高峰期时，提交的任务量可能会暴增，这时核心线程数和队列都满了后，怎么办呢？直接走拒绝策略吗？这样显然是不合理，所以线程池中又引入了非核心线程，为了方便理解，我们可以把他们当作工厂的临时工。为了应付短暂的高峰期，而请太多正式员工成本太大，所以就请了临时工来抗瞬时任务高峰，等高峰期一过，再把临时工们解散掉，即销毁非核心线程。我们在构造线程池时，会指定最大线程数和核心线程数，这两者之差就是非核心线程数的大小。</span></p><p>&nbsp;</p><p><span>好了，到这里我们知道了线程池可以基于主动对象模式，实现将请求和执行分离的异步效果，而且对于线程池是如何实现这一功能的内部处理流程也进行了剖析。</span></p><p>&nbsp;</p><p><span>今天是我们讲主动对象模式的最后一篇文章，相信经过几篇文章的学习后，你对主动对象模式的概念、架构、实现、应用场景都有相对深入的了解了。</span></p><p>&nbsp;</p><h3><a name="31基础三问如何避免重复创建线程创建线程池的方式有哪些各自优缺点有哪些" class="md-header-anchor"></a><strong><span>31_基础三问：如何避免重复创建线程？创建线程池的方式有哪些？各自优缺点有哪些？</span></strong></h3><h4><a name="一案例分析-n1993" class="md-header-anchor"></a><span>一、案例分析</span></h4><p><span>我们在使用一些app的时候，应该都收到过消息推送，它们往往依赖消息推送服务实现。事实上，互联网大厂都有自己的消息推送服务（又名Message Push Server），通过消息推送服务实现对App的消息推送，不关注掉技术实现的细节，大致过程如图1。</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/6643900_1623893944.png" referrerpolicy="no-referrer" alt="img"></p><p><span>图1</span></p><p><span>如果让你来实现一个消息推送服务，要求保证消息推送的实时性，你会怎么设计呢？</span></p><p><span>你可能会想到，用多线程技术去做，为每个客户端都创建一个线程，然后启动线程，每来一条需要推送的消息就用创建好的线程发送出去。如图2所示。</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/22432000_1623893944.png" referrerpolicy="no-referrer" alt="img"></p><p><span>图2</span></p><p><span>每当有一个客户端与服务端建立连接，就创建一个线程来执行消息推送服务。</span></p><p><span>这种方案看起来挺不错，但是可行性如何？其实，这种方案是无法在生产环境实战的。原因就在于不断创建线程这个操作本身是不合理的。相信大家在学习完前面的内容，再结合自己的工作经验，多少对线程都有了一定的了解，那就是：创建线程是一个比较重的操作。一方面是因为创建线程需要占用内存资源，这里的内存资源并非是JVM的内存，乍一听是不是觉得挺反常识？</span></p><p>&nbsp;</p><p><span>不慌，我们先看一段代码，在循环中一直创建线程，看看会出现什么情况，如图3所示。</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/38981300_1623893944.png" referrerpolicy="no-referrer" alt="img"></p><p><span>图3</span></p><p><span>运行代码，结果如图4所示</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/54907500_1623893944.png" referrerpolicy="no-referrer" alt="img"></p><p><span>图4</span></p><p><span>可以看到控制台出现了java.lang.OutOfMemoryError报错，即内存已用尽。出现这个错误的原因就在于我们创建了太多的线程，线程对象本身以及线程的调用栈都是要占用内存的，而操作系统的内存是有限的，这决定了我们能创建的线程数也是有限制的，而无限制的创建线程会使内存不断消耗最终超过内存上限从而报错。</span></p><p>&nbsp;</p><p><span>事实上，能创建多少线程数是有一个计算公式的：可创建的线程数 =（进程的最大内存 – JVM分配的内存 – 操作系统保留的内存）/ 线程栈大小。如图所示，粉红色的部分就是可分配线程的内存大小，如果不显式设置-Xss或-XX:ThreadStackSize参数的时候,在Linux x64上ThreadStackSize的默认值就是1024K，也就是1MB大小，如图5所示。</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/70662300_1623893944.png" referrerpolicy="no-referrer" alt="img"></p><p><span>图5</span></p><p><span>这里还要强调的一点是，在Java语言中，当我们每创建一个线程的时候，Java虚拟机就会在JVM内存中创建出一个Thread对象，与此同时创建一个操作系统的线程，最终在系统底层映射的是操作系统的本地线程（Native Thread），在windows系统中是1对1映射（即一个Java线程映射一个操作系统线程），在Linux系统是N对M映射（即多个Java线程映射多个操作系统线程，N与M不完全相等），这里就仅做了解，不详细展开了，感兴趣的同学可以去看一下操作系统的线程部分的知识。需要明确的是，这里说的映射关系是系统自动完成的，不需要用户主手动操作。</span></p><p>&nbsp;</p><p><span>我们还要记住一点，那就是操作系统的线程使用的内存并不是JVM分配的内存，而是系统中剩余的内存，也就是公式中的（进程的最大内存 – JVM分配的内存 – 操作系统保留的内存）。这么一来，你给JVM分配内存越多，那你能创建的线程就越少，也就越容易发生Exception in thread &quot;main&quot; java.lang.OutOfMemoryError: unable to create new native thread这样的异常。</span></p><p>&nbsp;</p><p><span>回到文章开头的那个案例，如果使用app的移动设备非常多，达到数百万甚至上千万台，那么通过为每个客户端创建一个线程的方式执行推送就是不现实的，Java进程会因为占用过多内存而大量报错，代码执行效率很低。那怎么办才能既不会大量创建线程导致java.lang.OutOfMemoryError，又能实现业务需求呢？</span></p><p>&nbsp;</p><p><span>这时候，我们就需要用到线程池这个神器了。通过线程池可以避免重复创建线程，此时发送推送消息的方式如图6所示；</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/92840800_1623893944.png" referrerpolicy="no-referrer" alt="img"></p><p><span>图6</span></p><p><span>我们通过创建了一个消息推送线程池，对线程进行复用，让这些固定数量的线程去执行不断产生的消息推送任务。事实上，线程池就像一个加工厂，加工厂里有一个队列对待处理的任务进行存储，同时加工厂里还装了固定数量的工作线程去队列中获取任务进行执行。</span></p><p><span>原理如图7所示：</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/8085400_1623893945.png" referrerpolicy="no-referrer" alt="img"></p><p><span>图7</span></p><p><span>就是说，应用程序不断的往线程池中提交任务，有的任务就被工作线程直接执行了，如果工作线程都是处于繁忙的执行状态，那么应用程序就先把任务提交到任务队列里缓存起来，然后工作线程会从队列里取任务进行处理。</span></p><p><span>这就好比是说，你去食堂打饭，点了一份水饺，因为你去的比较早，不用排队。可以直接和食堂大妈说，我要一份猪肉大葱馅儿的水饺。大妈就会盛一份做好的水饺给你，你直接结账端去吃就行。</span></p><p>&nbsp;</p><p><span>假如有一天，你因为处理线上问题导致吃饭时间稍微耽误了，到了食堂就会发现，排了几十人的队伍。可是这家水饺实在太好吃，只能自觉排队等着轮到自己。</span></p><p>&nbsp;</p><p><span>在这个案例中，去得早直接让大妈盛一份水饺，就相当于是说直接让工作线程把任务执行了，去的迟了就相当于是说任务需要进队列，然后等待工作线程执行任务。在这个场景里，食堂大妈就相当于工作线程，等待过程排的长队就相当于任务队列。</span></p><p>&nbsp;</p><h4><a name="二创建线程池的方式" class="md-header-anchor"></a><span>二、创建线程池的方式</span></h4><p><span>事实上，Java已经有现成的线程池供我们使用，也就是大名鼎鼎的Executors框架。它提供了多种创建线程池的方法。</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/29075200_1623893945.png" referrerpolicy="no-referrer" alt="img"></p><p><span>图8</span></p><p><span>如图8所示，Executors框架提供了多种类型的线程池，我们依次介绍一下:</span></p><ul><li><span>newSingleThreadExecutor()方法：它返回的线程池实例中只有一个工作线程，如果提交超过一个任务到线程池中，那么任务会被保存在队列中。等工作线程空闲了就从队列中取出其他任务进行执行。获取任务遵循队列的先进先出原则。</span></li></ul><p>&nbsp;</p><ul><li><span>newCachedThreadPool()方法：它返回的线程池中的线程数量是可变的，理论上可以创建Integer.MAX_VALUE个线程。当然，如果有空闲的线程能够被复用，就还是优先使用可被复用的线程。当目前所有的线程都处于工作状态，但是仍然有新任务被提交了，那么就会创建新的线程来调度新任务。</span></li></ul><p>&nbsp;</p><ul><li><span>newFixedThreadPool()方法： 它返回一个带固定数量线程的线程池。这个线程池中的线程数量从线程池一开始创建就固定不变。如果提交一个任务到这个线程池里，线程池中恰好有空闲的线程，那么就会立即执行任务；否则，没有空闲的工作线程，那么新提交的任务就只能被暂存在一个任务队列里面，等待空闲线程去处理任务队列中的任务。</span></li></ul><p>&nbsp;</p><ul><li><span>newSingleThreadScheduledExecutor()：这个方法返回的是ScheduledExecutorService对象实例。学习源码我们会发现，ScheduledExecutorService实际上是继承了接口ExecutorService，并扩展出了周期性调度任务的能力。</span></li></ul><p>&nbsp;</p><ul><li><span>newScheduledThreadPool()：和newSingleThreadScheduledExecutor()类似，它也是返回一个ScheduledExecutorService对象实例，只不过它能够指定线程的数量。</span></li></ul><p>&nbsp;</p><p><span>下面我们简单总结一下Executors框架创建线程池的种类及其功能，如图9所示。</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/43975000_1623893945.png" referrerpolicy="no-referrer" alt="img"></p><p><span>图9</span></p><p><span>这些线程池的使用方法也很简单，我们以newCachedThreadPool()为例，简单展示一下如何向线程池中提交任务，如图10所示。</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/59915300_1623893945.png" referrerpolicy="no-referrer" alt="img"></p><p><span>图10</span></p><p><span>我们模拟向线程池中提交请求，打印请求id和当前线程名称，执行该测试代码，观察一下日志打印，运行结果如图11所示。</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/74568600_1623893945.png" referrerpolicy="no-referrer" alt="img"></p><p><span>图11</span></p><p><span>可以看到，通过submit(Runnable task)方法向 newCachedThreadPool()提交任务，新的任务都是被一个新的线程所执行，如果前面创建的线程空闲了，才会被复用。我们一共提交了10个任务，分配了9个线程进行调度，最后一个任务被执行完任务再度空闲的线程所执行。</span></p><p>&nbsp;</p><p><span>那么我们回到开头的案例，如果要使用线程池来实现发送消息推送的需求，我们应该如何去做呢？</span></p><p>&nbsp;</p><p><span>首先就排除掉newCachedThreadPool()这种方式！原因在于newCachedThreadPool()方式是一个最大线程数为Integer.MAX_VALUE的线程池，这意味我们最多可以一次性创建2147483647个线程！足足21亿4000万个！如果系统面临同时并发发送大量的任务的场景，而且任务本身执行速度不是很快的情况下，系统是有可能会开启大量线程进行处理的，这么多线程会在短时间快速耗尽系统资源，造成系统抛出java.lang.OutOfMemoryError这个恐怖的异常！而且newCachedThreadPool()持有的是一个SynchronousQueue，后面的文章我们会详细讲解这部分内容，现在只需要知道SynchronousQueue是一个缓存值为1的阻塞队列，通俗的说，它根本就没有缓冲任务的能力，具体的原理如图12所示。</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/92303300_1623893945.png" referrerpolicy="no-referrer" alt="img"></p><p><span>图12</span></p><p><span>那么我们就猜想，是不是应该控制一下线程池的数量，不要让系统无休止的创建新线程呢？</span></p><p><span>答案也确实如此。如果我们使用Executors.newFixedThreadPool()指定固定数量的线程池，那么系统至少不会无休止的创建线程了，比方说，我们指定了100个线程，那么就是通过Executors.newFixedThreadPool(100)的方式创建线程池。这么做就可以高枕无忧了吗？</span></p><p>&nbsp;</p><p><span>可别得意的太早，newFixedThreadPool()确实是控制了线程数量，但是线程池里还有一个东西叫做任务队列！这玩意儿也是要占用内存空间的。我们来看看newFixedThreadPool()方法吧，如下图13所示。</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/8022200_1623893946.png" referrerpolicy="no-referrer" alt="img"></p><p><span>图13</span></p><p><span>看到了吧，它用的队列是new LinkedBlockingQueue</span><Runnable><span>()，这是个无界队列。这意味着，就算我们限制了线程数量是固定不能一直创建，当海量并发任务提交过来的时候，会因为线程数不够而将任务入队列，要看到这个队列是无界队列，所以这就是说，任务会一直入队。但是这在现实中是不可能发生的，因为内存是有限的啊，如果一直提交任务，内存肯定是会被耗尽的！</span></p><p>&nbsp;</p><p><span>通过上文的分析，我们发现，线程池的核心是工作线程和任务队列。现在用一张图来总结一下线程池的基本架构，如图14所示。</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/24391400_1623893946.png" referrerpolicy="no-referrer" alt="img"></p><p><span>图14</span></p><p><span>这张图大家可以先自己仔细研究一下，关于这张图的详细分析，我们将在接下来的文章中揭晓。</span></p><p>&nbsp;</p><p><span>回到解决开头的案例的思路中来，让我们继续看看Executors框架还有没有其他合适的方法能够供我们高效的进行消息推送。到目前为止，就剩newSingleThreadExecutor()这个线程池创建方式了。它的方法签名如图15所示：</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/40082800_1623893946.png" referrerpolicy="no-referrer" alt="img"></p><p><span>图15</span></p><p><span>可以看到，它本质上就是newFixedThreadPool(1)，对吧，那其实它也会面临newFixedThreadPool()的问题，那就是无界队列可能会因为海量任务一直提交入队，消耗内存最后导致内存爆满，原理如图16所示。</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/54888700_1623893946.png" referrerpolicy="no-referrer" alt="img"></p><p><span>图16</span></p><p><span>看到这里你可能有点失望了，怎么每一个线程池都有它的问题。别灰心啊，其实技术本身就没有银弹，都是权衡的结果，每个线程池创建方式都有其适用场景，只不过极限情况下，可能会出现问题。作为软件开发者，我们可以做的就是，掌握其原理，博采众长，扬长避短。</span></p><h4><a name="-n2096" class="md-header-anchor"></a><span> </span></h4><h4><a name="三总结-n2097" class="md-header-anchor"></a><span>三、总结 </span></h4><p><span>那有没有一种方法，能够让我们灵活的定制线程池，适配自己的业务场景呢？答案是显而易见的，当然有。之后的文章，我们会带你深入学习线程池的工作原理并定制你的专属线程池，达到在实战中灵活运用线程池的目的。</span></p><p>&nbsp;</p><h3><a name="32初探源码分析线程池的构造过程追踪核心成员变量" class="md-header-anchor"></a><strong><span>32_初探源码：分析线程池的构造过程，追踪核心成员变量</span></strong></h3><h4><a name="一上节回顾-n2101" class="md-header-anchor"></a><span>一、上节回顾</span></h4><p><span>我们在上篇文章中对使用线程池的原因，线程池的常见种类，以及通过Executors框架创建线程池的几种方式，作了讲解。在文章结尾，我们还通过一张图对线程池的核心架构原理进行了展示。</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/79595400_1623894470.png" referrerpolicy="no-referrer" alt="img"></p><p><span>图1</span></p><p><span>事实上，图1是对线程池原理的一个详细的表达，它体现了线程池的几个核心概念，具体是哪些概念呢，让我们一起来探索。</span></p><p>&nbsp;</p><h4><a name="二核心参数" class="md-header-anchor"></a><span>二、核心参数</span></h4><p><span>首先通过对Executors创建线程池的方法签名的分析，我们会发现那几种创建线程池的方法，其实都是对ThreadPoolExecutor类的进行包装，提供定制化的能力，就以newFixedThreadPool(int nThreads)方法为例，如图2所示。</span></p><p>&nbsp;</p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/39598600_1623894471.png" referrerpolicy="no-referrer" alt="img"></p><p><span>图2</span></p><p>&nbsp;</p><p><span>我们再看一下ThreadPoolExecutor的构造方法，如图3所示。</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/10981600_1623894472.png" referrerpolicy="no-referrer" alt="img"></p><p><span>图3</span></p><p><span>我们发现，这个构造方法其实是重载了另外一个构造方法，现在我们接着看他调用的这个重载的构造方法，如图4所示。</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/72439200_1623894472.png" referrerpolicy="no-referrer" alt="img"></p><p><span>图4</span></p><p>&nbsp;</p><p><span>ThreadPoolExecutor核心参数分析</span></p><p><span>通过上图，我们发现，ThreadPoolExecutor有7个入参，这7个参数就是线程池构造以及任务执行的核心参数了。是否了解线程池ThreadPoolExecutor的核心参数及其意义，是面试中的高频问题，也是Java开发工程师是否用过ThreadPoolExecutor的重要依据。现在我们就来理解下这些参数，通过参考图1，结合构造方法的参数进行理解。</span></p><p>&nbsp;</p><p><span>首先是corePoolSize，即核心线程的个数。注意看下图中浅黄色的“核心池CorePool”，里面放的是核心线程。核心线程其实就是预先分配的线程，当线程池创建，就实现分配指定数量的核心线程，一旦有任务提交过来，核心线程立即就能接管开始执行，就好比你去食堂打饭，去了不用排队直接点菜取餐。</span></p><p>&nbsp;</p><p><span>它的意义在于减少了创建线程的开销，做到了“任务一来线程就可用，无需等待”。如下图中的核心池Pool中的线程池的数量，代表的含义就是这里的corePoolSize，如图6所示。</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/19413500_1623894473.png" referrerpolicy="no-referrer" alt="img"></p><p><span>图6</span></p><p><span>然后是maximumPoolSize，即线程池最大的线程数量。也就是上图中的“最大池maximumPool”的容量，它的作用在于，当核心线程数被任务占满，且其中的任务缓冲队列也满了的时候，让新提交的任务仍旧可以执行，不至于立马就被拒绝。保证线程池可以通过创建新工作线程的方式来接受并执行任务。</span></p><p>&nbsp;</p><p><span>讲到这里你可能还有困惑，不是已经有corePoolSize参数了么，为啥还要来一个maximumPoolSize呢？这其实就是线程池设计的精妙之处了，这是一种“弹性设计”，可以让线程池在应对突发流量时稳稳当当。</span></p><p>&nbsp;</p><p><span>如果没有设置maximumPoolSize，只设置了一个corePoolSize，在系统平时的任务不多，比如每秒执行10个以内的任务的低并发场景中，是没啥大问题的。然而，如果每个月初月末流量突增，达到每秒100以上的并发时。我们总不能把corePoolSize设置成原先的10倍吧！如果只是为了应对短暂的高峰流量，就把常规状态下的线程翻了10倍。那么在平常没有那么多的任务可以执行的情况下，创建大量的工作线程并保持常态，就是典型的资源浪费。</span></p><p>&nbsp;</p><p><span>于是就有了maximumPoolSize，它本质上也是一种“伸缩思想”在线程池中的体现，原理如图7所示。</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/92088600_1623894473.png" referrerpolicy="no-referrer" alt="img"></p><p><span>图7</span></p><p><span>从图7中我们可以看到，正是因为maximumPoolSize参数，让线程池具备了可以根据任务量灵活调节自身的资源分配的能力。上图中最大可以创建16个线程，已经创建了8个（实线圆形），还剩8个可以创建（虚线圆形）。</span></p><p>&nbsp;</p><p><span>再看keepAliveTime参数，顾名思义，就是存活时间。那具体是谁的存活时间呢？其实就是超过核心线程池（线程总数小于等于maximumPoolSize）并且处于空闲状态的那些线程的存活时间。这部分线程给他们分配了一个keepAliveTime参数，意义在于，当没有可处理的任务时，让它们别急着回收，而是先等会儿，看有没有任务来了，如果有就去执行任务，否则就等达到了keepAliveTime之后，对工作线程进行回收。如下图8所示。</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/8287900_1623894475.png" referrerpolicy="no-referrer" alt="img"></p><p><span>图8</span></p><p><span>我们举个理想情况下的例子，假设corePoolSize是10，maximumPoolSize是20，此时线程池中共有15个线程，并且keepAliveTime设置为60s。结果最近60s内都没一个任务被提交到线程池，那超出来的5个线程就会被回收。</span></p><p>&nbsp;</p><p><span>和keepAliveTime有关联的参数是unit，它代表了keepAliveTime的时间单位（TimeUnit类型），可以是天、时、分、秒、毫秒、微妙、纳秒。一般而言，我们给线程池的keepAliveTime指定的时间单位是秒或者分，原因在于从经验判断，对于任务执行而言，毫秒、微秒、纳秒单位过小，小时又过大了。</span></p><p>&nbsp;</p><p><span>接着看workQueue参数，它表示用于保存提交的待执行状态的任务的阻塞队列。队列种类有很多种，包括基于数据的有界队列ArrayBlockingQueue、基于链表的无界队列LinkedBlockingQueue、有且只有一个元素的同步队列SynchronousQueue以及优先级队列PriorityBlockingQueue等等。它本质上就是说通过一个队列，让等待执行的任务先进行排队，给线程池提供了一个缓冲的空间，能够让线程池在一定的程度内接受任务，而不是直接就拒绝任务的提交。</span></p><h4><a name="-n2147" class="md-header-anchor"></a><span> </span></h4><h4><a name="三这样设计的好处" class="md-header-anchor"></a><span>三、这样设计的好处</span></h4><p><span>这样的设计，提高了线程池的任务容纳能力，而且队列天然有解耦的作用，它把任务提交和执行进行了解耦，这是什么？这不就是我们前面文章讲到的生产者-消费者模型啊。原理如图9所示。</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/28476100_1623894475.png" referrerpolicy="no-referrer" alt="img"></p><p><span>图9</span></p><p><span>我们接着看一下后续的参数。首先是ThreadFactory参数，即创建线程的工厂，它的作用是当需要增加工作线程时，不需要通过new Thread的方式创建，而是通过ThreadFactory接口的实现类的newThread方法来创建。接口声明如图10所示：</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/73910500_1623894475.png" referrerpolicy="no-referrer" alt="img"></p><p><span>图10</span></p><p><span>最后看一下RejectedExecutionHandler这个参数，它也是一个接口，翻译过来就是拒绝策略。方法签名如图11所示：</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/91611000_1623894475.png" referrerpolicy="no-referrer" alt="img"></p><p><span>图11</span></p><p><span>它的作用是当任务队列满了，并且工作线程数量也达到了最大线程数，且都在处理任务时，如果继续往线程池提交任务，那么就会触发拒绝策略。如图12所示：</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/10030500_1623894476.png" referrerpolicy="no-referrer" alt="img"></p><p><span>图12</span></p><p><span>图12中，队列已经满了，并且工作线程数也达到了maximumPoolSize，此时就只能执行拒绝策略了。由于RejectedExecutionHandler是一个接口，因此允许我们自定义具体的拒绝策略。Java作为一款十分成熟的工业级开发语言，也提供了四种默认的拒绝策略，我们可以根据实际需要去选择对应场景的拒绝策略。我们用一个脑图简单说明一下这四种拒绝策略的特点，如图13所示。</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/74674200_1623894476.png" referrerpolicy="no-referrer" alt="img"></p><p><span>图13</span></p><h4><a name="四总结-n2164" class="md-header-anchor"></a><span>四、总结</span></h4><p><span>到这里，我们就对线程池的核心参数进行了细致的讲解，希望你能够反复研读，消化直至吸收。接下来我们将对线程池提交任务的源码进行讲解。</span></p><p>&nbsp;</p><h3><a name="33再品源码探秘提交任务到线程池后源码的执行流程" class="md-header-anchor"></a><strong><span>33_再品源码：探秘提交任务到线程池后源码的执行流程</span></strong></h3><p><span>再品源码：探秘提交任务到线程池后源码的执行流程</span></p><p>&nbsp;</p><p><span>在上一篇文章中，我们对构造线程池的核心参数进行了细致的讲解。本篇文章我们就继续深入分析其源码和原理。现在一起来探索源码，分析一下任务提交到线程池之后的执行流程。</span></p><p>&nbsp;</p><p><span>按照惯例，我们先看一张任务执行的完整流程如图1所示。再根据这张图中的主要节点，一步一步结合源码来分析一下。</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/94876100_1623894797.png" referrerpolicy="no-referrer" alt="img"></p><p><span>图1</span></p><p>&nbsp;</p><h4><a name="1任务提交" class="md-header-anchor"></a><span>1.任务提交</span></h4><p><span>线程池任务提交有两种方式，execute()和submit()。首先看一下execute方法的源码。我们发现它接收的入参是一个Runnable类型。我们按照代码截图中的序号依次分析，具体分析内容如图2所示。</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/25993900_1623894798.png" referrerpolicy="no-referrer" alt="img"></p><p><span>图2</span></p><p><span>[1]首先，一进方法就先对command进行校验，如果command为空就直接抛出NPE异常；</span></p><p>&nbsp;</p><p><span>[2,3]然后判断一下线程池中的线程个数是否小于corePoolSize，如果满足条件就调用addWorker(command, true)方法区执行任务。这个方法实际上最终就是开启了新的线程去执行任务。</span></p><p>&nbsp;</p><p><span>[4]如果说线程池处于RUNNING状态，也就是isRunning(c)返回true，那么就将任务添加到阻塞队列。也就是执行workQueue.offer(command)。</span></p><p>&nbsp;</p><p><span>[5,6]为了确保能够准确的将任务添加成功，线程池在这里做了二次校验。这里是因为，如果将任务添加到线程池之后，有可能线程池状态已经变化了，所以要校验一下，看看当前的线程池状态还是不是RUNNING。</span></p><p><span>如果线程池状态不是RUNNING了，就把任务从任务队列中删除，也就是remove(command)，然后就执行拒绝策略，也就是调用reject(command)方法。</span></p><p>&nbsp;</p><p><span>[7]如果说线程池状态确实是RUNNING，也就是二次校验通过，那么就判断一下线程池里是否还有线程，通过WorkerCountOf(recheck) == 0来判断，如果返回true了，就说明当前线程池中是空的，没有线程。怎么办呢？其实很好理解，既然没有就添加一个就完事儿了，调用一下addWorker往线程集合里增加一个线程，如图3所示。</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/50766400_1623894798.png" referrerpolicy="no-referrer" alt="img"></p><p><span>图3</span></p><p>&nbsp;</p><p><span>    看到了吧，实际上所谓的Workers就是一个HashSet，而Worker则本质上是一个Runnable，但是它实现了AQS，代码比较复杂，也很精巧。</span></p><p>&nbsp;</p><p><span>[8]在执行[4]的时候对任务进行添加，如果添加失败就说明任务队列已经满了，那么只要线程池中的线程数小于maximumPoolSize就继续新开线程来执行任务。</span></p><p><span>如果线程数要超过maximumPoolSize了，就需要执行拒绝策略了。</span></p><p>&nbsp;</p><p><span>到这里我们对提交任务的代码就分析结束，这些步骤其实就是本文一开始的图1，我们再复习一下加深下印象。</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/67951700_1623894798.png" referrerpolicy="no-referrer" alt="img"></p><p><span>图4</span></p><h4><a name="2worker线程获取任务执行流程" class="md-header-anchor"></a><span>2.Worker线程获取任务执行流程</span></h4><p><span>通过前面内容的学习，大家应该都知道了任务是被线程池中的工作线程（也就是Worker线程）执行的了。那我们就来看看，Worker线程是如何获取任务然后执行的。</span></p><p>&nbsp;</p><p><span>上面的流程中，我们已经知道了线程池是通过执行addWorker方法来增加Worker线程的，实际上Worker线程就是在这个阶段被启动的，具体我们来看看代码，如图4所示。</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/87229600_1623894798.png" referrerpolicy="no-referrer" alt="img"></p><p><span>图5</span></p><p><span>这段代码是截取的addWorker方法，注意我们用红框圈住的三个地方，是需要重点关注的。</span></p><p><span>首先第一个位置，我们声明了一个Worker线程，并把它持有的thread成员变量的引用，赋值给final修饰的Thread t临时变量，然后判断t是否是alive状态。如果是，那么就抛出一个IllegalThreadStateException异常，因为已经启动了，就再无需启动了。</span></p><p>&nbsp;</p><p><span>第二个位置，将这个新的Worker线程添加到工作线程集合中，通过上文的分析我们知道它是一个HashSet。并设置WorkerAdded状态变量为true。</span></p><p>&nbsp;</p><p><span>第三个位置，校验WorkerAdded状态变量为true成立，就通过start()方法启动工作线程，其实最终启动的是Worker内部持有的Thread成员变量。通过Worker的构造方法就能知晓其中的奥义，如图5所示。</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/12976700_1623894799.png" referrerpolicy="no-referrer" alt="img"></p><p><span>图6</span></p><p><span>到这里，我们其实已经知道了，最终调度任务的Worker工作线程，通过构造方法我们已经知道Worker本质上实现了Runnable接口，那么就能够被Thread启动。</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/30547100_1623894799.png" referrerpolicy="no-referrer" alt="img"></p><p><span>图7</span></p><p><span>现在我们回过头去研究一下Worker的run方法。</span></p><p><span>为什么要研究run方法呢？因为Worker是Runnable的实现，那最终线程启动之后，调用的就是它的run方法，也就是说，Worker肯定是实现了run方法了。如图7所示。</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/49960000_1623894799.png" referrerpolicy="no-referrer" alt="img"></p><p><span>图8</span></p><p><span>怎么样，Worker线程的确是实现了run方法了，核心逻辑都在runWorker方法里，那我们就继续深入。</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/76824600_1623894799.png" referrerpolicy="no-referrer" alt="img"></p><p><span>图9</span></p><p><span>看到这么一大段代码，想必有的同学又开始心里发慌了。不慌，这里分享一个读源码的小技巧，“抓大放小，分析重点”。我们看源码重在找到重点，至于其他的细节，你不去深究也无伤大雅，如果钻牛角尖，非得弄清每行代码，一方面时间上不现实，一方面肯定会很辛苦，得不偿失啊。</span></p><p>&nbsp;</p><p><span>从这个“抓大放小，分析重点”的原则出发，我们就关注红框圈住的两行重点代码：</span></p><p><span>第一个位置，我们把Worker的task引用赋值给了Runnable局部变量；</span></p><p><span>第二个位置要额外关注，有的同学不知道为什么队列中的任务会被工作线程执行，其实就是这句代码在起作用。通过调用task = getTask()方法，下面截取了getTask方法的核心代码，我们能够直观的看到最终是调用的workQueue.take()方法取出了队列中的任务，本质上就是生产者-消费者模型。</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/93755700_1623894799.png" referrerpolicy="no-referrer" alt="img"></p><p><span>图10</span></p><p><span>第三个位置，执行task的run方法，也就是用户提交的真正的业务逻辑。你可能想问了，明明这里执行的是Runnable的run方法，那工作线程到哪里去了？同学，这个问题问的有水平！</span></p><p>&nbsp;</p><p><span>我们在上面的分析中，提到了addWorker这个方法，里面就对工作线程进行了start调用，其实这里就启动了工作线程，如图10所示。</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/12478500_1623894800.png" referrerpolicy="no-referrer" alt="img"></p><p><span>图11</span></p><p><span>现在Worker线程获取任务并执行的流程全貌就展现在我们眼前了。我们可以通过图11来加深下理解。</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/33572000_1623894800.png" referrerpolicy="no-referrer" alt="img"></p><p><span>图12</span></p><p><span>通过图11展现的流程，我们需要记住一个结论：当我们需要向线程池提交任务的时候，通过调用execute()传进去的任务（Runnable或者Callable实现），最终会通过Worker的构造方法传递到Worker内部，这样当start启动的以后真正执行的就是Worker中的Runnable，也就是用户提交的Runnable。</span></p><p>&nbsp;</p><p><span>也许你会觉得听起来有些复杂。因为代码有一定的复杂度，阅读起来确实不简单，但是我们可以先尝试把原理搞懂。比如先理解这张图，然后再回去看源码，相信你就能把握住主脉络了。俗话说，捡了芝麻，丢了西瓜。我们搞技术的切忌深陷细节的泥沼，抓大放小才能出奇制胜。</span></p><p>&nbsp;</p><h4><a name="3worker线程的退出时机" class="md-header-anchor"></a><span>3.Worker线程的退出时机</span></h4><p><span>分析完Worker线程的执行，我们再趁热打铁看看Worker线程是什么时候退出的。</span></p><p><span>事实上，线程池中的线程销毁，是要依赖JVM来实现自动回收的。而线程池自身，会根据当前线程池的状态来维持一定数量的线程引用，防止该部分的线程被JVM回收掉。如果线程池决定了哪些线程要被回收，那么就将他们的引用消除即可。</span></p><p>&nbsp;</p><p><span>我们在之前的学习中知道，Worker线程一旦被创建好了，就会持续的轮询获取任务去执行。</span></p><p><span>对于核心线程来说，他们可以无限制的等待着任务被获取并执行，而非核心的线程则是在有限的时间内获取任务，一旦Worker无法获取到任务，也就是要获取的任务为空，循环就会结束，Worker自己就会主动的去除掉在线程池中的应用，进而被回收掉并退出。</span></p><p>&nbsp;</p><p><span>从代码角度看一下这个过程是在什么时候发生的吧，如图12所示。</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/49529500_1623894800.png" referrerpolicy="no-referrer" alt="img"></p><p><span>图13</span></p><p><span>我们还是回到runWorker方法，发现在try块中有个while循环，循环停止的条件就是要获取的任务为空以及通过getTask获取不到任务了，最终会进到finally块执行收尾逻辑，如图13所示。</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/74878800_1623894800.png" referrerpolicy="no-referrer" alt="img"></p><p><span>图14</span></p><p><span>首先[1]部分的代码是说，在执行线程退出之前，线程池会先统计池子里完成任务的数量，然后通过workers.remove(w)把Worker移除掉。要注意的是在统计之前加了全局锁，保证统计的准确性。</span></p><p><span>[2]部分的代码是说，如果当前线程池状态是SHUTDOWN状态并且工作队列已经为空，或者当前线程池已经是STOP状态，或者说当前线程池中没有活动的线程，则尝试对线程池状态设置为TERMINATED。</span></p><p><span>[3]部分是说，最后还是得判断一下线程池里面的实际线程数是否小于核心的线程个数，如果是的话，就得增加线程。这里的目的是保证线程池中的核心线程数量不变。</span></p><p>&nbsp;</p><p><span>怎么样，是不是觉得线程池的源码没有那么可怕了？我们继续趁热打铁，通过一张图来总结一下Worker线程退出的逻辑，如图14所示。</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/2289100_1623894801.png" referrerpolicy="no-referrer" alt="img"></p><p><span>图15</span></p><p><span>面试中如果遇到这个问题，那么就把这张图的过程说出来，并且补充道，我是在阅读并理解了源码的基础上总结出来的。相信你一定能够得到面试官的青睐。</span></p><p>&nbsp;</p><p><span>这篇文章相对比较硬核，因为我们是通过阅读源码的方式去理解。通过此次学习，相信你对线程池提交任务的过程、Worker线程获取任务并执行的过程以及Worker线程退出过程都有了源码级的深入了解。同时笔者阅读的源码“抓大放小，分析重点”的方法，相信你也get到精髓了，希望你能够利用这种思路，征服源码，收获更多。</span></p><p>&nbsp;</p><p><span>到这里，本文章就告一段落了，感谢你一直看到现在。在之后的文章中，我们将从实战角度出发，研究如何自定义线程池满足不同的业务场景，敬请期待。</span></p><p>&nbsp;</p><h3><a name="34实战经验如何根据系统的业务场景需求定制自己的线程池" class="md-header-anchor"></a><strong><span>34_实战经验：如何根据系统的业务场景需求定制自己的线程池？</span></strong></h3><p><span>通过前面几篇文章的学习，我们已经对线程池的作用、优点、原理有了一定了解。但这里还有个疑问，线程池有那么多的参数和类型，在实际的开发中，我们应该如何设置呢？是直接使用Executors提供的线程池实现，还是自定义线程池？这都是我们本篇文章要回答的问题，那么就请跟随笔者一起分析一下在实战中如何根据系统的业务场景需求来定制自己的线程池吧。</span></p><p>&nbsp;</p><p><span>一般情况下，其实Executors提供的几种实现已经足够我们使用了，比如：newCachedThreadPool()、newFixedThreadPool()以及newSingleThreadExecutor()。</span></p><p><span>如图1流程图所示，我将不同的业务场景适合的线程池类型画了出来。</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/69235800_1623895899.png" referrerpolicy="no-referrer" alt="img"></p><p><span>图1</span></p><p><span>如果在业务场景中使用一个线程就足够了，那么直接选择拥有一个核心工作线程的newSingleThreadExecutor()就能满足要求；</span></p><p>&nbsp;</p><p><span>如果一个线程不够，但是能够判断线程数量是有限的，那么只需要指定工作线程数量N，通过newFixedThreadPool(N)就能够满足要求；</span></p><p>&nbsp;</p><p><span>如果需要通过创建线程来应对一定的突发流量，保证任务处理的即时性，那么使用newCachedThreadPool()也是比较合理的。需要注意的是，如果突发流量很大，比如每秒上万的突增流量，那么使用newCachedThreadPool()就需要慎重，因为很可能会导致出现java.lang.OutOfMemoryError异常。</span></p><p>&nbsp;</p><p><span>需要注意的是，我们这里提到的newSingleThreadExecutor()以及newFixedThreadPool(N)线程池，使用的都是LinkedBlockingQueue无界队列。如果业务场景不适合使用无界队列，比如：任务携带的数据过多，且任务并发量大，那么使用基于LinkedBlockingQueue无界队列的线程池就需要慎重。</span></p><p>&nbsp;</p><p><span>也就是说，Executors提供的默认线程池也是特定场景下才适用，并不是万能药。</span></p><p>&nbsp;</p><p><span>那么问题来了，生产中应当如何使用线程池才比较合理呢？答案很简单，就是自定义线程池。</span></p><p><span>自定义线程池，其实就是根据自己业务场景，使用不同的参数去对线程池进行定制，从而满足具体的业务场景。</span></p><p>&nbsp;</p><p><span>定制线程池的要点，其实就是ThreadPoolExecutor的核心构造参数的指定，主要在于指定合理的核心线程数、最大线程数、选择合适的工作队列、自定义线程工厂以及选择合适的拒绝策略。我们针对每个参数具体讨论一下。</span></p><p>&nbsp;</p><p>&nbsp;</p><p><span>指定线程数量</span></p><p><span>线程数量并没有一个标准答案，它主要依赖机器的CPU个数以及JVM虚拟机堆的大小，一般情况下，CPU个数是更加主要的影响因素。</span></p><p>&nbsp;</p><p><span>实际生产中，我们根据任务关注点的不同，将任务划分为：CPU密集型（或者叫计算密集型）、I/O密集型两大类，如图2所示。也有一种叫做混合类型的任务，也就是既包含计算又包含I/O操作，这种我们不必关注。</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/93424800_1623895899.png" referrerpolicy="no-referrer" alt="img"></p><p><span>图2</span></p><p><span>一般来说，对于CPU密集型的任务，由于CPU计算速度很快，任务在短时间内就能够通过CPU超强的计算能力执行完成，因此我们可以设置核心线程数corePoolSize为N（CPU个数）+1，之所以要设置为CPU个数加1，主要原因在于为了防止某些情况下出现等待情况导致没有线程可用，比如说发生了缺页中断时，就会出现等待的情况。因此设置一个额外的线程，可以保证继续使用CPU时间片。</span></p><p>&nbsp;</p><p><span>而对于I/O密集型的任务，可以为最大线程数多设置一些线程。原因在于相比CPU密集型任务，I/O密集型任务在执行过程中由于等待I/O结果花费的时间要明显大于CPU计算所花费的时间，而且处于I/O等待状态的线程并不会消耗CPU资源，因此可以多设置一些线程。一般情况下，我们将其设置为CPU个数的倍数，常见的玩儿法是设置为N（CPU个数）*2。</span></p><p>&nbsp;</p><p><span>对于I/O密集型任务，还要注意核心线程数不用设置的很大，原因在于I/O操作本身会导致上下文切换的发生，尤其是阻塞式I/O。因此建议将I/O密集型的核心线程数corePoolSize限制为1，最大线程数maximumPoolSize设置为N（CPU个数）*2。当线程池中只要一个线程的时候，能够从容应对提交的任务，此时的上下文切换相当少。然后随着任务逐渐增加，再慢慢的增加线程数量至最大线程数。这样做既不浪费资源，还很灵活的支持了任务增加的场景。</span></p><p>&nbsp;</p><p><span>需注意的是这里给出的是一种理论的参考配置，实际开发中，由于对性能的要求以及机器配置的不同，我们不能照搬文中的配置，还需要根据具体的情况进行调整，比如考虑CPU的利用率，任务执行过程中的等待时间等。但是一般来说，使用我们提到的配置是一种比较稳妥合适的方式。关于如何计算合理的线程池大小其实是有一个公式的，这里贴一下公式的内容，公式背后的深层次的原理就留给大家去探索学习，公式内容如图3所示。</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/11922500_1623895900.png" referrerpolicy="no-referrer" alt="img"></p><p><span>图3</span></p><p><span>在Java中，通过Runtime.getRuntime().availableProcessors()就可以很方便的获取到JVM所在机器的CPU个数，从而方便我们指定具体的线程个数。</span></p><p>&nbsp;</p><p><span>选择合适的工作队列</span></p><p><span>我们接着来看一下如何选择合适的工作队列。</span></p><p>&nbsp;</p><p><span>工作队列通常有无界队列、有界队列、同步队列三种类型。每个队列都有它自己的特点和用途，按照惯例还是用一张图来说明，如图4所示。</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/42292100_1623895900.png" referrerpolicy="no-referrer" alt="img"></p><p><span>图4</span></p><p><span>在图4中，我们将每种工作队列的特点，代表的实现，以及使用的注意点都做了详细说明，大家可以认真阅读图中的内容，我们就不再赘述了。</span></p><p>&nbsp;</p><p><span>自定义线程工厂</span></p><p><span>一般来说，我们还需要定义线程工厂，给自定义的线程池起一个个性化的名字，这有助于我们在查找日志的时候精确的定位到具体的某个线程池。</span></p><p>&nbsp;</p><p><span>自定义线程工厂，需要实现ThreadFactory接口，此处提供一个参考实现，如图5所示，大家可以根据这个代码样例进行扩展，实现自己的线程工厂，当然也建议大家多去阅读优秀的开源框架，比如Netty、Tomcat，它们都提供了优秀的自定义的线程工厂的实现。</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/63883300_1623895900.png" referrerpolicy="no-referrer" alt="img"></p><p><span>图5</span></p><p><span>选择合适的拒绝策略</span></p><p><span>我们接着聊聊如何选择合适的拒绝策略，关于ThreadPoolExecutor默认的拒绝策略及其特点，我们可以参考图6。</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/88989700_1623895900.png" referrerpolicy="no-referrer" alt="img"></p><p><span>图6</span></p><p>&nbsp;</p><p><span>一般来说，直接使用AbortPolicy抛出异常即可，但是如果说我们要求即便触发了拒绝策略，任务也得执行完成不能丢弃，那么选择CallerRunsPolicy拒绝策略即可。如果说这几种拒绝策略都满足不了我们的需求的话，就可以自定义拒绝策略，只需要实现RejectedExecutionHandler接口即可实现自定义的拒绝策略。</span></p><p>&nbsp;</p><p><span>自定义线程池代码案例</span></p><p><span>上文中，我们对自定义线程池中需要注意的要点都进行了详细的图文并茂的讲解，相信你已经有所收获。这个部分我们就趁热打铁，编写一个完整的自定义线程池的案例。</span></p><p>&nbsp;</p><p><span>我们以I/O密集型任务为例，实现一个自定义线程池的案例，具体代码如图7所示。</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/26874700_1623895901.png" referrerpolicy="no-referrer" alt="img"></p><p><span>图7</span></p><p><span>我们定义了一个订单同步线程池，指定核心线程数为CPU数量+1，最大线程数为CPU数量*2，并指定非核心线程数的存活时间为60s。</span></p><p>&nbsp;</p><p><span>我们使用了有界的LinkedBlockingQueue作为工作队列，指定大小为500，这个参数可以根据实际情况自定义，比如通过配置文件动态指定。</span></p><p>&nbsp;</p><p><span>同时还定义了自定义的线程工厂，为线程池设置了名称“sync-order-info-thread-pool”，便于方便查询日志。最后指定了拒绝策略为CallerRunsPolicy()，保证只要JVM进程正常运行，任务一定能够被执行到。</span></p><p>&nbsp;</p><p><span>我们只需要编写一个方法，将该自定义的线程池的引用返回，就可以让业务逻辑在需要的场景随时使用该自定义线程池了。实际开发中，我们更多的会用到Spring框架进行代码编写，我们只需要定义一个ThreadPoolExecutor的bean，即可在需要使用的地方进行注入，进而使用其进行异步任务提交等操作了，如图8所示。</span></p><p>&nbsp;</p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/51029800_1623895901.png" referrerpolicy="no-referrer" alt="img"></p><p><span>图8</span></p><p><span>本节，我们重点讨论了如何根据系统的实际业务是需求自定义线程池，在接下来的文章中，我们将通过线程池来实现互联网场景下的验证码保护服务，敬请期待。</span></p><p>&nbsp;</p><h3><a name="35案例实战如何利用线程池实现互联网验证码保护服务" class="md-header-anchor"></a><strong><span>35_案例实战：如何利用线程池实现互联网验证码保护服务</span></strong></h3><h4><a name="一开篇词-n2350" class="md-header-anchor"></a><span>一、开篇词</span></h4><p><span>通过对线程池理论知识的学习，想必你对线程池已经建立了深入全面的认识，并且准备好在实战中应用所学的知识，解决实际问题了。本篇文章就让我们利用线程池实现互联网验证码保护服务。</span></p><p>&nbsp;</p><h4><a name="二业务背景与实现思路" class="md-header-anchor"></a><span>二、业务背景与实现思路</span></h4><p><span>首先介绍一下业务背景，假设我们的系统是一个短视频播放网站，每个新加入的用户都需要注册账号并绑定手机号。为了验证用户手机的正确性，我们的系统会发送一条验证码到用户注册时填写的手机上，用户在有效期内填写验证码进行认证，通过认证之后即绑定该手机号到用户注册的账号上。完整的业务流程如图1所示。</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/54303500_1623896189.png" referrerpolicy="no-referrer" alt="img"></p><p><span>图1</span></p><h4><a name="三代码实操" class="md-header-anchor"></a><span>三、代码实操</span></h4><p><span>当用户注册账户成功之后，需要发送短信验证码，因此账户注册流程中会调用验证码发送模块提供的验证码发送服务。因此我们实现一个名为AsyncSmsVerificationCodePusher的服务，对外提供验证码生成和响应的短信下发能力。最终调用第三方的短信推送服务，触达用户。</span></p><p>&nbsp;</p><p><span>这里要注意的是，对接第三方短信推送服务，需要提供接收短信的用户手机号、验证码内容等信息，如图2所示。</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/72642500_1623896189.png" referrerpolicy="no-referrer" alt="img"></p><p><span>图2</span></p><p><span>由于用户注册流程中，不止发送短信，还可能执行其他的业务流程。并且发送短信本身属于跨网络服务调用，本质上是一种网络I/O操作，因此如果直接在业务主线程上直接同步阻塞式的调用验证码发送模块的发送短信接口，会影响到整个业务流程的处理效率，如果单位时间内大量用户涌入，会造成注册接口响应缓慢。这种情况肯定是会引起大量客诉的，这对于一个处于用户拉新阶段的视频网站来说是一个比较严重的事件，需要极力去避免。同步方式发送短信验证码的业务流程如图3所示。</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/94336400_1623896189.png" referrerpolicy="no-referrer" alt="img"></p><p><span>图3</span></p><p><span>因此我们考虑通过异步方式去进行验证码发送，在AsyncSmsVerificationCodePusher类中通过定义一个专门的验证码发送线程池来实现验证码短信的发送。为了提高效率，我们定义一个专门的验证码发送任务SmsVerificationCodeTask来实现验证码生成、以及发送业务。代码调用过程如图4所示。</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/14760500_1623896190.png" referrerpolicy="no-referrer" alt="img"></p><p><span>图4</span></p><p><span>对流程熟悉了之后，我们就开始编写代码实现这个业务流程吧。首先定义验证码短信发送线程池，命名为SMS_SEND_THREAD_POOL，如图5所示。</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/34640700_1623896190.png" referrerpolicy="no-referrer" alt="img"></p><p><span>图5</span></p><p><span>上图5中，我们定义了一个自定义线程池，设置核心线程数为CPU个数，最大线程数为50，这么设置的原因在于发送短信是一个I/O密集型的业务。</span></p><p>&nbsp;</p><p><span>我们还定义了方法sendSmsVerificationCode，通过线程池提交短信验证码发送任务SmsVerificationCodeTask。接着看一下SmsVerificationCodeTask的代码实现。</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/55294100_1623896190.png" referrerpolicy="no-referrer" alt="img"></p><p><span>图6</span></p><p><span>图6中SmsVerificationCodeTask实现了Runnable接口，在run方法中，我们实现了验证码发送业务逻辑：</span></p><p><span>首先通过ThreadLocalRandom线程安全方式生成6位随机数，然后格式化为字符串；然后通过sendMessage方法将短信发送至对应的手机号，并进行日志打印。</span></p><p>&nbsp;</p><p><span>我们接着编写业务代码调用短信发送服务模拟发送短信验证码，代码如图7所示。</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/80074100_1623896190.png" referrerpolicy="no-referrer" alt="img"></p><p><span>图7</span></p><p><span>我们先创建了一个AsyncSmsVerificationCodePusher实例对象，然后生成了3个SmsVerificationCodeTask验证码发送任务，最后通过调用asyncSmsVerificationCodePusher对象的sendSmsVerificationCode方法通过自定义线程池提交了短信验证码发送任务。日志打印如图8所示。</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/2474600_1623896191.png" referrerpolicy="no-referrer" alt="img"></p><p><span>图8</span></p><p><span>到此为止，我们就通过线程池实现了发送互联网短信验证码保护服务。核心就是通过自定义线程池，异步提交验证码发送任务，实现了业务流程与验证码发送流程的解耦，这种开发方式在实战中极为常用，希望你能够掌握并灵活运用。</span></p><h4><a name="-n2387" class="md-header-anchor"></a><span> </span></h4><h4><a name="四总结-n2388" class="md-header-anchor"></a><span>四、总结</span></h4><p><span>本篇文章的内容到这里就结束，感谢阅读。下篇文章我们将引入一个新的知识点：线程本地化存储如何保证线程安全。敬请期待！</span></p><p>&nbsp;</p><h3><a name="36抛砖引玉线程本地化存储如何保证线程安全" class="md-header-anchor"></a><strong><span>36_抛砖引玉：线程本地化存储如何保证线程安全</span></strong></h3><p><span>在并发编程中，可能最害怕听到一个词就是线程不安全。因为它意味着程序运行的时候，可能出现数据的读取或写入不准确等情况发生，但是各位同学，你们有想过线程不安全产生的根本原因是什么？其实就是多线程下的变量共享，我们举一个平时工作的中的例子先来说明一下</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/11555600_1623896416.png" referrerpolicy="no-referrer" alt="img"></p><p><span>        图1</span></p><p><span>上述图1，可能对于每个工程师来说都不陌生，就是我们工作中常见的一个环节，我们都会对代码在git上代码进行拉取、提交，进行需求或功能的开发，但是我们经常会遇到一些突如其来的问题，如下图所示</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/34031800_1623896416.png" referrerpolicy="no-referrer" alt="img"></p><p><span>图2</span></p><p><span>上述图2中，几乎每个开发工程师都遇到过，也很郁闷，那就是代码冲突。提交代码的时候，莫名其妙发现不能提交，这是因为git上的代码已经被人修改了，需要先合并代码。</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/58527700_1623896416.png" referrerpolicy="no-referrer" alt="img"></p><p><span>图3</span></p><p><span>从上述图3中，不难看出，出现代码冲突的原因，是每个工程师本地都有一份代码的副本，在提交代码的时候，代码可能已经被其他工程师给修改了。其实核心问题是多个工程师共享了一份代码，每个人本地都有自己代码副本，其他人修改git上的代码，我们没有感知，就导致了代码错乱。其实对于java来说也是一样的，如果一个变量对于多个线程是共享的，就会出现线程不安全的情况发生，我们来看下图示例</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/77553200_1623896416.png" referrerpolicy="no-referrer" alt="img"></p><p><span>图4</span></p><p><span>上述图4中，其实就是多个线程对同一个数据进行读取和修改的流程，每个线程自己都有本地的数据副本，其他线程对数据的修改，自己感知不到，就会导致数据被各种覆盖，最后导致数据错乱。其实核心问题还是数据的共享，这个时候可能有同学会说，如果变量不共享是不是就不会出现线程不安全的问题呢？先别急，这就进入我们今天的主题，如何保证线程安全？</span></p><p>&nbsp;</p><p><span>现在我们知道如果变量共享会存在线程不安全的问题，反之，如果变量不共享，则会不会出现线程不安全问题呢？如果变量不共享，则是线程安全的，那有请问那些变量是不共享的呢？</span></p><p>&nbsp;</p><p><span>Java中有哪些变量是不共享的？先来看看java虚拟机的内存模型，因为java运行时候的内存模型决定了哪些变量是共享的，哪些变量是非共享的</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/92534500_1623896416.png" referrerpolicy="no-referrer" alt="img"></p><p><span>           图5</span></p><p><span>上述图5，就是java虚拟机运行时的数据区，其中分为线程共享区和线程隔离区，线程共享区所有的变量对于java虚拟机的所有线程都是共享的，反之，线程隔离区是java虚拟机每个线程独有的且是隔离的，图5这个java虚拟运行是数据区，在面试中被问到的几率还是很大的。下面我们用一张图表示一下线程和虚拟机栈空间的关系。</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/10404000_1623896417.png" referrerpolicy="no-referrer" alt="img"></p><p><span>         图6</span></p><p><span>上述图6，在java虚拟机栈空间，每个线程都有自己栈空间，且相互独立的，每次可以用不同的参数调用相同的方法，且线程之间相互不影响，每次执行方法的时候，变量都是存储在自己的栈空间里，没有了共享，则就不会出现线程安全问题。图6中，画出了每个线程的栈空间中都含有栈帧，那同学们，如果我们知道了栈帧能存储哪些变量，是不是我们就知道了哪些变量是线程安全的？那我们接下来就一起看看栈帧到底有哪些东西？</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/35869400_1623896417.png" referrerpolicy="no-referrer" alt="img"></p><p><span>图7</span></p><p><span>这里，我们先来说一下栈帧是什么：是用于虚拟机执行时方法调用和方法执行时的数据结构，每一个方法从调用到方法返回都对应着一个栈帧入栈出栈的过程。最顶部的栈帧称为当前栈帧，每一个栈帧包含的内容有局部变量表、操作数栈、动态链接、方法返回地址等信息。</span></p><p>&nbsp;</p><p><span>从图7中，我们能清楚的看到方法1-&gt;方法2-&gt;方法3整个执行过程。当方法返回的时候，方法对应的栈帧，也会在栈空间被弹出，同时，执行的方法和对应的栈帧是同生共死的关系。那栈帧里存储变量在哪里？答案就是在局部变量表里。</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/57634700_1623896417.png" referrerpolicy="no-referrer" alt="img"></p><p><span>图8</span></p><p><span>局部变量表，就是存储一些局部变量的地方，我们可以从图8中看到，局部变量表存放了方法参数和方法内部定义的一些局部变量等信息，但是局部变量分为基本数据类型和对象引用类型，我们来看一下代码示例</span></p><p>&nbsp;</p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/77023100_1623896417.png" referrerpolicy="no-referrer" alt="img"><span>        图9</span></p><p><span>从图9中，我们可以看到该方法中的局部变量有基本类型和对象引用类型，这个时候同学们可能有疑惑了，之前不是说存储在栈空间的变量都是线程独有的吗？你这个new Object()代码是创建一个对象，是在java虚拟机的堆空间里，而堆空间是整个虚拟机所有线程共享的区域，这到底是怎么回事呀？我们继续往下看。</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/9246800_1623896418.png" referrerpolicy="no-referrer" alt="img"></p><p><span>图10</span></p><p>&nbsp;</p><p><span>我们把代码还原到图10中，int c = a + b，基本类型的局部变量是存在栈空间，而new Object()代码创建的的对象实例的确是存在虚拟机的堆空间里，但是Object object只是引用(reference)堆空间里的对象，重要的事情说三遍，是引用，是引用，是引用，而new Object()这个对象只有被当前线程的自己所引用，我们再来看下面这张图</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/26459600_1623896418.png" referrerpolicy="no-referrer" alt="img"></p><p><span>图11</span></p><p><span>从图11中，我们能到看到，每个线程创建的对象，只有自己能引用，而其他线程是引用不到的，这样就不存在了变量共享的问题，同时也不会出现数据被其他修改，导致数据错乱的情况了。局部变量为什么是线程安全的呢？因为变量不共享，就不存在线程安全问题。</span></p><p>&nbsp;</p><p><span>既然变量不共享就可以避免线程安全问题，那是不是可以把需要访问的变量作为每个线程的私有变量，每个线程访问各自的变量，相互间不共享，这样就不存在线程安全问题了吗？我们接下来看下面的代码</span></p><p>&nbsp;</p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/54477700_1623896418.png" referrerpolicy="no-referrer" alt="img"></p><p><span>              图12</span></p><p><span>图12中，就是按照同学们的想法，把需要访问的变量设置到自己的私有变量里，如果多个线程都需要使用Object object对象，为了避免线程安全问题，我们不希望把Object object变量共享，我们可以让每个线程都有一个Object object对象，如下图所示</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/69064100_1623896418.png" referrerpolicy="no-referrer" alt="img"></p><p><span>             图13</span></p><p><span>如上图13，对于一个Object 对象，我们可以在每个线程都去创建一个Object 对象，相当于每个线程都有一个Object 对象副本，这样就没有共享了，这个做法思路是正确的，但是通用性不是很好，如果想获取Object对象来使用，总不能每次都去获取当前线程，然后去获取线程的私有变量吧。这时我们可以引入一个代理对象，把获取每个线程所持有的Object object对象的细节隐藏掉。</span></p><p>&nbsp;</p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/84771100_1623896418.png" referrerpolicy="no-referrer" alt="img"></p><p><span>            图14</span></p><p><span>到目前为止，我们知道线程不安全的核心问题在于，变量的共享，如果避免变量的共享，则能解决线程安全问题。与此我们也学习了局部变量为什么是线程安全的，同时我们还有一个好的想法来解决变量共享问题，就是对每个线程都有且仅有一个Object object对象，不存在多线程变量的共享问题，如图14中所表现出来的，用一个代理对象把获取每个线程的Object object对象细节屏蔽调。</span></p><p>&nbsp;</p><p><span>既然我们能想到这个解决方式，那JDK是否有类似ObjectProxy的解决方式呢？我们会在后面的文章中为同学们揭开面纱。</span></p><p>&nbsp;</p><h3><a name="37源码分析threadlocal如何实现线程本地化存储的" class="md-header-anchor"></a><strong><span>37_源码分析：ThreadLocal如何实现线程本地化存储的？</span></strong></h3><p><span>上篇文章我们提出了线程不安全的问题，产生这个问题的原因在于变量的共享，为了解决线程不安全的问题，我们想到了让每个线程都拥有自己的对象副本，也就不存在多线程变量的共享问题，我们再看图1，回忆一下</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/26591200_1623897198.png" referrerpolicy="no-referrer" alt="img"></p><p><span>     图1</span></p><p><span>从图1中，我们知道，每个线程都拥有自己的对象副本，但是，如果我们每次想获取每个线程的私有对象的时候，都通过一堆复杂的代码逻辑去获取这个对象就有点麻烦了，从而我们想到了，用一个代理类把获取线程所持有的对象细节隐藏掉，请看下图2</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/49967400_1623897198.png" referrerpolicy="no-referrer" alt="img"><span> 图2</span></p><p><span>上篇文章结尾我们留下了一个问题，JDK是否有类似ObjectProxy解决方式呢？答案是有。如果有，JDK是怎么实现的呢？如果你来设计类似ObjectProxy，你会怎么考虑呢？那我们就带着上面的问题开始今天的学习。</span></p><p>&nbsp;</p><p><span>在java里提供了可支持线程本地化存储的ThreadLocal类，后面我们会讲解ThreadLocal的实现，这里先来聊聊，如果让我们自己设计线程本地化存储，该如何设计呢？</span></p><p>&nbsp;</p><p><span>其实对于线程本地化存储，我们的目标就是让不同的线程拥有不同变量，那我们第一个能想到的就是Key-Value键值对的存储，Key表示的就是线程，Value对应的就是每个线程所拥有的变量，我们来看示意图图3和代码示例图4      </span><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/66472900_1623897198.png" referrerpolicy="no-referrer" alt="img"></p><p><span>    图3  </span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/92590600_1623897198.png" referrerpolicy="no-referrer" alt="img"><span>  图4    </span></p><p>&nbsp;</p><p><span>从上述图3和图4中，我们能清晰的看到，我们自己所设计的线程本地化存储，核心数据结构就是一个Map，key对应的就是线程，value对应的线程持有的对象，我们可以调用对应get和set方法可以获取和设置线程所拥有的对象，哇哦，看起来很完美，那这么设计是否有问题呢？是的，这样设计容易发生内存泄露，我们来看图5</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/55276500_1623897199.png" referrerpolicy="no-referrer" alt="img"></p><p><span>  图5</span></p><p><span>从上述图5中，我们能清晰的看到，我们自己实现的线程本地化存储MyThreadLocal里的map是持有线程Thread对象的，只要MyThreadLocal对象存活在jvm中，那么map中的线程Thread对象是不会被jvm垃圾回收的，所以容易出现内存泄露。那有没有别的方法避免这种情况呢？那我们就一起来看看JDK的ThreadLocal是怎么实现的吧</span></p><p><span>  </span><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/75455000_1623897199.png" referrerpolicy="no-referrer" alt="img"></p><p><span> 图6</span></p><p><span>从图6中，我们能看到jdk中的ThreadLocal所拥有的的对象属性，奇怪的发现，好像这些变量都没有能存储线程本地化对象的地方，同学们，先别急，如果ThreadLocal实现了线程本地化的功能，就一定会提供给我们获取和设置本地化对象的方法，那我们这接下来看看ThreadLocal有没有类似get和set方法呢?</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/8498800_1623897200.png" referrerpolicy="no-referrer" alt="img"></p><p><span>  图7</span></p><p><span>从图7中，我们很高兴的看到了ThreadLocal的get方法，那同学们我们倒过来想想，get方法一定是从底层存储层获取数据的，那我们是不是可以顺着get方法的逻辑，就能找到ThreadLocal的底层存储呢？按照这个逻辑，请看下图8</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/48686900_1623897200.png" referrerpolicy="no-referrer" alt="img"></p><p><span>  图8</span></p><p><span>在图8中，红线1，我们能看到有个叫ThreadLocalMap的东西，然后在红线2中，再从获取到的ThreadLocalMap中获取Entry，最后从取到的Entry中获取线程的value，好，那我们就按照这个逻辑一步一步来看看这些都是什么妖魔鬼怪。</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/74788100_1623897200.png" referrerpolicy="no-referrer" alt="img"></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/4997200_1623897201.png" referrerpolicy="no-referrer" alt="img"></p><p><span>  图9</span></p><p><span>从图9中，我们能清晰的看到ThreadLocalMap是Thread对象里的属性，换句话说，每个Thread对象都拥有一个ThreadLocalMap对象属性，到了这里，同学们可能有点蒙了，我们知道线程本地化对象就是存储在这个ThreadLocalMap里，但这ThreadLocalMap不是ThreadLocal持有的属性，和我们自己想象的不太一样，我们通过一张图来描述一下，请看图10</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/31760500_1623897201.png" referrerpolicy="no-referrer" alt="img"></p><p><span>  图10</span></p><p><span>到此为止，同学们应该感觉到了，我们自己设计的方案和JDK的实现是不一样的，我们设计的里的Map是ThreadLocal所持有的，但是JDK里，这个ThreadLocalMap是Thread自己的属性，显然这个JDK的设计更为合理一点，因为ThreadLocal只是一个我们所说的ObjectProxy代理工具类，内部不应该持有任何与线程有关的属性，所以我们设置的线程本地化对象，在自己Thread类里所持有也更为容易理解些，也就是说ThreadLocalMap由Thread持有更为合理些。</span></p><p>&nbsp;</p><p><span>到了这里，同学们，还记得图8吗？我们再来回忆一下图8，如果我们想获取线程对应的value，首先就要先获取线程对应的ThreadLocalMap，然后再从ThreadLocalMap里获取Entry，最后从Entry获取对应的value，那么我们接下来就看看ThreadLocalMap里有什么，请看图11</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/52976900_1623897201.png" referrerpolicy="no-referrer" alt="img"></p><p><span> 图11</span></p><p><span>从图10中，我们能看到，原来ThreadLocalMap是ThreadLocal一个内部类，在红线2处每个ThreadLocalMap持有一个Entry数组，且在红线1处每个Entry持有一个value对象，这个时候，同学们可能已经豁然开朗了，这个value不就是我们想找的嘛，原来整个获取value的顺序就是：线程Thread-&gt;ThreadLocalMap-&gt;Entry-&gt;value，但是我们在红线2处发现这个Entry的数组，同学们有没有这个疑问？我们是怎么样从Entry的数组中获取某一个的Entry的呢？请看图12</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/82047700_1623897201.png" referrerpolicy="no-referrer" alt="img"></p><p><span>  图12</span></p><p><span>从图8中红线2处，在获取到ThreadLocalMap之后，会执行TheadLocalMap的getEntry方法，方法如图12所示，在图12红线1处，我们清晰看到方法的参数是Threadlocal类型，红线2处，再根据传入的这个ThreadLocal的threadLocalHashCode计算坐标值，然后根据坐标值再从Entry数据里获取对应的Entry对象，从而获取到Entry里的value值，老规矩，我们再用一张图来描述一下，请看下图13</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/9165100_1623897202.png" referrerpolicy="no-referrer" alt="img"></p><p><span>   图13</span></p><p><span>从图13中，我们能清晰看到，整个线程Thread本地化存储结构，每个线程Thead里的ThreadLocalMap里可以存储多个ThreadLocal本地化对象，且每一个ThreadLocal本地化对象是通过自己的threadLocalHashCode来计算数组下标，分配到下标对应Entry数组中，从而可以进行本地化对象获取和设置操作，但是同学们这时候会说，我们自己设计的方案容易产生内存泄露，那JDK实现就没有这个情况吗？那我们就来看看JDK是如何巧妙设计的</span></p><p><span>请看下图14</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/36164800_1623897202.png" referrerpolicy="no-referrer" alt="img"></p><p><span> 图14</span></p><p><span>在图14中，我们能看到Entry的定义，想必同学们看到了Entry继承了WeakReference类，他就是弱引用，这说明了ThreadLocalMap里的对Threadlocal的引用是弱引用，请看下图15</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/63245000_1623897202.png" referrerpolicy="no-referrer" alt="img"></p><p><span> 图15</span></p><p><span>同学们，只要Thread对象被垃圾回收，那么ThreadLocalMap就能被回收，所以就不会出现内存泄漏的情况，虽然JDK线程本地化的实现的复杂了一些，但是它更加安全，所以说JDK的方案还是很优秀的，最后，我们来对比一下我们自己设计的方案和JDK的方案，请看下图16</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/94442200_1623897202.png" referrerpolicy="no-referrer" alt="img"></p><p><span> 图16</span></p><p><span>最后，通过图16对比来看，我相信同学们都有这种感觉，就是没有对比就没有伤害，从数据亲缘性来看，JDK把线程本地化存储放在Thread的ThreadLocalMap持有，且可以设置多个ThreadLocal，而我们的设计是把线程本地化存储放在自己设计的ObjectProxy代理工具类里，且容易产生泄露，而JDK通过精巧的设计却避免了内存泄露的情况，希望同学们已经get到了JDK的精良设计。</span></p><p>&nbsp;</p><p><span> 后面的文章，我们会有实战案例环节，敬请期待！</span></p><p>&nbsp;</p><h3><a name="38案例实战动手实现一个可发送短信随机密码的高安全性用户密码系统" class="md-header-anchor"></a><strong><span>38_案例实战：动手实现一个可发送短信随机密码的高安全性用户密码系统</span></strong></h3><p><span>我们在上一篇文章中讲解了：为了避免共享变量引发的线程不安全问题，从而想到了每个线程本地化副本的思想来解决变量的共享问题，同时我们自己也设计了线程本地化方案，发现存在内存泄露的问题，与此我们也讲解了JDK的ThreadLocal的精良的实现方案，是如何避免我们所设计方案存在的问题，相信同学们已经对ThreadLocal有了全面的认识，我们来看下图1，做一下简单的回忆。</span></p><p>&nbsp;</p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/60224700_1623897729.png" referrerpolicy="no-referrer" alt="img"></p><p><span>  图1</span></p><p><span>本篇文章我们就来学习如何运用ThreadLocal，通过ThreadLocal来实现高安全性用户密码系统发送随机密码案例。</span></p><p>&nbsp;</p><p><span>现假设我们是某个社交网站，对于每个新来的用户，我们可能都需要注册之后，才能进行使用网站的功能，但是对于注册流程，可能每个网站的流程都不一样，假设我们社交网站的注册流程为，先填写用户名和手机号，点击注册之后，系统注册成功之后，会创建一个随机密码，通过短信发送给用户，以后用户可以用该密码进行登录，也可以自己修改密码，我们来看一下整体的业务流程图2</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/85129800_1623897729.png" referrerpolicy="no-referrer" alt="img"></p><p><span> 图2</span></p><p><span>从图2中，我们可以清晰看到，我们的社交系统的注册流程，在这里我们在用户服务里，定义了一个UserPasswordSystemManager组件，专门负责用户的注册新用户业务的流程，包括保存注册用户信息和生成随机密码发送到用户手机上等，请看下图图3</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/14896400_1623897730.png" referrerpolicy="no-referrer" alt="img"></p><p><span> 图3</span></p><p><span>由于在用户注册流程中，逻辑还是比较复杂，可能需要和其他服务交互等等，但是我们为了提升性能，不希望生成随机密码和发送随机短信给用户等操作阻塞主业务流程，我们可能需要采取异步处理，正如我们图2中所示，用一个异步方式去处理随机密码的生成和随机密码短信的下发的任务，请看下图图4</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/56870900_1623897730.png" referrerpolicy="no-referrer" alt="img"></p><p><span> 图4</span></p><p><span>到了这里，为了提高整个注册的流程的性能，我们有了异步任务的线程池，后面可能就到了给每个用户生成随机密码，但是为了提高安全性，我们决定采用JDK自带的java.security.SecureRandom强随机数生成器，而不是java.math.Random这中伪随机生成器，请看下图图5</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/78703700_1623897730.png" referrerpolicy="no-referrer" alt="img"></p><p><span> 图5</span></p><p><span>由于SecureRandom的内部实现的问题，SecureRandom在初始化随机种子的时候比较耗时，因此我们希望可以复用一个SecureRandom对象，如图5所示，如果如图5所示，线程池可以复用一个SecureRandom对象，也就是说SecureRandom的对象对于线程池是共享变量，可能就会出现我们之前说过的线程不安全问题，为了解决这种线程不安全问题，我们可以在操作SecureRandom对象的方法的时候加上一把锁，保证只能一个线程来调用，而其他线程只能等待，但是，我们不希望看到这种等待情况的出现，所以我们可能就想到了线程本地化的方案，让每个线程都有拥有一个ThreadLocal</span><SecureRandom><span>对象，请看下图图6</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/97508900_1623897730.png" referrerpolicy="no-referrer" alt="img"></p><p><span> 图6</span></p><p><span>从图6中，我们能清晰看到，我们定义了一个ThreadSpecificSecureRandom组件，且持有了线程池里的每个线程Thread的ThreadLocal</span><SecureRandom><span>对象，每次都可以通过ThreadSpecificSecureRandom组件直接获取每个线程对应SecureRandom的随机数生成器，也就是说对于每个新注册的用户都拥有自己的随机密码生成器。</span></p><p>&nbsp;</p><p><span>到了现在，相信同学们对整个注册业务流程所有了解啦，同时我们也定义了每个组件的职责，那我们就来看一下每个组件代码的实现吧，首先先看一下ThreadSpecificSecureRandom组件代码实现，如图7所示</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/27622000_1623897731.png" referrerpolicy="no-referrer" alt="img"><span> 图7</span></p><p><span>上图图7中，我们能看到ThreadSpecificSecureRandom组件的定义，红线1处含有ThreadLocal</span><SecureRandom><span>对象的持有，红线2处表明可以通过调用nextInt方法，获取每个线程所持有的本地化对象SecureRandom来进行随机数的生成，那我们接下来就来看看调用nextInt的UserPasswordSystemManager组件的代码实现，请看下图图8</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/62049200_1623897731.png" referrerpolicy="no-referrer" alt="img"></p><p><span> 图8</span></p><p><span>我们从图8中，能看到UserPasswordSystemManager组件所持有的线程池，这个线程池就是用来异步处理注册流程中的生成随机密码和给用户下发短信，那我们接下来看看UserPasswordSystemManager组件所提供的方法，请看下图图9</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/98177800_1623897731.png" referrerpolicy="no-referrer" alt="img"></p><p><span>  图9</span></p><p><span>从图9中，我们能看到UserPasswordSystemManager组件红线1处提供了register方法，需传入注册的登录名和手机号，register方法的处理逻辑则是创建了一个Runnable的任务，且在红线2处，每个线程任务都会从ThreadSpecificSecureRandom组件获取Thread自己的SecureRandom随机数生成器来生成随机密码，然后是保存注册用户信息，最后通过短信下发给用户随机密码，整个任务定义完成，然后提交到异步线程池去执行。</span></p><p>&nbsp;</p><p><span>  我们在来编写一段代码，来模拟整个注册用户的流程，让同学们来感受一下，请看下图图10</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/30809800_1623897732.png" referrerpolicy="no-referrer" alt="img"></p><p><span> 图10</span></p><p><span>从图10中，我们创建了一个UserPasswordSystemManager对象实例，模拟了4个注册用户的登录名和手机号，然后调用了register方法来进行整个四个用户的模拟注册流程，日志打印如下图图11</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/61097500_1623897732.png" referrerpolicy="no-referrer" alt="img"><span>图11</span></p><p><span>这篇文章我们通过了线程池异步化和线程本地化ThreadLocal</span><SecureRandom><span>实现了高性能和高安全性的实现了用户密码系统发送随机密码案例，线程本地化ThreadLocal在日常开发使用还是比较常见的，希望同学们能够掌握它的底层原理且可以在工作中灵活使用。</span></p><p>&nbsp;</p><h3><a name="39深度思考threadlocal是否存在内存泄漏问题如何防止内存泄漏" class="md-header-anchor"></a><strong><span>39_深度思考：ThreadLocal是否存在内存泄漏问题，如何防止内存泄漏？</span></strong></h3><p><span>我们在之前的文章中讲解了为了解决共享变量带来的线程不安全问题，我们想到了通过线程本地化的方式来避免，同时通过用大白话加上画图的方式，对JDK的ThreadLocal的底层原理进行详细的讲解，且用ThreadLocal动手实现高安全性用户密码系统发送短信随机密码案例，想必同学们对ThreadLocal已经有了崭新的认识。</span></p><p>&nbsp;</p><p><span>对于Java的ThreadLocal实现方案已经是相当精良了，不过即便如此，ThreadLocal还是不能百分百地让程序员避免内存泄露，如果程序员不谨慎就很可能导致内存泄露？那么今天我们就来聊聊什么样的情况ThreadLocal不会出现内存泄露？什么样的情况会出现内存泄露？我们如何防止内存泄露的情况发生呢？我们这节就会为同学们一一详细解答，那我们先来简单回忆一下ThreadLocal的底层实现，请看下图图1</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/29229500_1623898357.png" referrerpolicy="no-referrer" alt="img"><span>                </span></p><p><span>图1</span></p><p><span>通过图1我们能清晰的看到JDK的线程本地化ThreadLocal是存储在每个线程Thread内部的ThreadLocalMap里的，且ThreadLocalMap包含了一个Entry数组，每个Entry存储着一个ThreadLocal和对应的value值，也就是说Thread可以存储多个ThreadLocal对象，既然我们对ThreadLocal的底层实现有所了解，那么问题来了，如何使用ThreadLocal不会出现内存泄露情况呢？请看下图图2</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/51161200_1623898357.png" referrerpolicy="no-referrer" alt="img"></p><p><span>图2</span></p><p><span>从图图2中，我们能看出，假如我们使用一个线程thread来执行任务，当thread线程执行完任务退出之后，该线程里所持有的ThreadLocalMap的对象也就没有了强引用，那么由于ThreadLocalMap没有强引用，所以就可以被JDK垃圾回收器回收了，那么ThreadLocalMap里面所包含ThreadLocal也就回收掉了。详细的整个流程，请看下图图3</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/79935700_1623898357.png" referrerpolicy="no-referrer" alt="img"></p><p><span> 图3  </span></p><p><span>到了这里想必同学们应该知道之前如何使用ThreadLocal不会出现内存泄露情况问题的答案了吧，对，它就是创建Thread或者Thread子类来执行任务处理，随着对应的线程Thread生命周期结束，那么线程Thread所持有的ThreadLocal也会被垃圾回收，不会出现内存泄露情况发生。</span></p><p>&nbsp;</p><p><span>但是每执行一个任务都要创建一个Thread来处理，对于机器来说开销还是不小的，我们之前文章中讲到，可以用到线程池的技术来解决频繁的创建和销毁Thread。那么在使用线程池的场景下使用ThreadLocal是否会有内存泄露的情况发生呢？那我们先来看一下图图4</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/4832500_1623898358.png" referrerpolicy="no-referrer" alt="img"></p><p><span> 图4</span></p><p><span>在之前的学习中，我们知道线程池里的核心线程Thread执行完任务之后，是不会退出的，可以循环使用的，那就说明线程池里每个核心线程Thread对应的ThreadLocalMap一直是强引用关系，所以线程Thread对应的ThreadLocal是不会自动回收的，那同学们可能会说，之前章节不是说了ThreadLocal是WeakReference弱引用，JDK触发垃圾回收的时候可以自动回收吗？同学们说的都没有问题，我们先来看一下图图5</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/35164600_1623898358.png" referrerpolicy="no-referrer" alt="img"></p><p><span> 图5</span></p><p><span>在上述图5中，我们用新的一张图来表示Thread和ThreadLocal对应关系，其中ThreadLocalMap中的Entry中的key是属于WeakReference弱引用，随着JDK的垃圾回收ThreadLocal可以自动被回收，那么我们看一下触发JDK垃圾回收之后的示意图，请看下图图6</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/51130700_1623898358.png" referrerpolicy="no-referrer" alt="img"></p><p><span> 图6</span></p><p><span>在JDK触发垃圾回收之后，对应的ThreadLocal确实可以被垃圾回收掉，变为null值，但是同学们，被自动回收的ThreadLocal所对应value值是不能被自动回收的，请看下图图7</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/70935700_1623898358.png" referrerpolicy="no-referrer" alt="img"></p><p><span> 图7</span></p><p><span>在上述图7，我们能清晰看到ThreadLocal的key是可以被自动回收变成为null，但是对应的value还是被Entry引用着呢，所以value是不能被垃圾回收器自动回收的，到了这里，想必同学们应该知道了，如果在线程池场景中使用ThreadLocal是有内存泄露情况的可能性，原因就是线程池的核心线程Thread是循环利用的，每个线程Thread所对应的ThreadLoalMap被强引用着，所以每个线程Thread的ThreadLoalMap不能被回收，但是ThreadLoalMap里含有多个ThreadLocal-value的Entry，虽然ThreadLocal-key是弱引用可以被垃圾回收器自动回收，但是ThreadLocal对应的value是不能被回收的，所以说有内存泄露的情况可能性。那同学们可能会问，这种情况，不能避免吗？那我们先看一下JDK是否解决方案呢？请看下图图8</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/95567200_1623898358.png" referrerpolicy="no-referrer" alt="img"></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/19707800_1623898359.png" referrerpolicy="no-referrer" alt="img"></p><p><span> 图8</span></p><p><span>上述图8，同学们应该还有印象吧，它就是我们之前讲解的ThreadLocal的get方法，先是在红线1处就是获取ThreadLocal对应的Entry，然后再从Entry获取对应value，那么在红线2处，我们能看到这个if条件，同学们，如果Entry所对应的ThreadLocal被自动回收变成null啦，那这个if判断条件是不成立的，就会走到getEntryAfterMiss这个方法里对吧，那么就来看看getEntryAfterMiss这个方法的实现，请看下图图9</span></p><p>&nbsp;</p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/41486400_1623898359.png" referrerpolicy="no-referrer" alt="img"></p><p><span> 图9</span></p><p><span>从图9我们能够看到getEntryAfterMiss的逻辑，我们传进来的Entry e其实所对应的key，也就是ThreadLocal是为null的，所以一定会走到上图红线处这个条件里，会走到expungeStaleEntry这个方法里，我们再来看看expungeStaleEntry这个方法的逻辑，请看下图图10</span></p><p>&nbsp;</p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/67918300_1623898359.png" referrerpolicy="no-referrer" alt="img"></p><p><span> 图10</span></p><p><span>从上图图10红线1处，我们能清晰的看到，会把ThreadLocal为null所对应的value设置为null，同时把对应的Entry也设置为null，同时在红线2处，会遍历所有的为ThreadLocal为null的value和对应的Entry都设置为null，这样就去除了强引用，有助于被垃圾回收，我们再来看一下所对于的示意图图11</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/88116900_1623898359.png" referrerpolicy="no-referrer" alt="img"></p><p><span>图11</span></p><p><span>到了这里，同学们可能会说，JDK的expungeStaleEntry的方法不是会把ThreadLocal为null所对应value和Entry对象设置为null嘛，这样就可以被垃圾回收啦，那在线程池的使用场景下就不会出现内存泄露的情况了啊？同学们，只有在调用ThreadLocal的get、set、remove方法的时候才会触发expungeStaleEntry方法的执行，才会把被自动垃圾回收的ThreadLocal为null所对应的value和Entry才会设置为null。换句话说，正常的情况是不会出现内存泄露的，但是如果我们没有调用ThreadLocal对应的set、get、remove方法就不会把对应的value和Entry设置为null，这样就可能会出现内存泄露情况。对吧，那如何避免内存泄露的情况呢？那就是我们在不使用的时候就调用一下ThreadLoca的remove方法，来加快垃圾回收，避免内存泄露。</span></p><p>&nbsp;</p><p><span> 最后简单总结一下，由于ThreadLocalMap包含了ThreadLocal，且线程Thread中包含变量ThreadLocalMap，因此ThreadLocalMap与Thread的生命周期是相同的，所以在线程池场景中使用ThreadLocal的时候，我们还是要养成好习惯，ThreadLocal不在使用的时候调用remove方法，避免内存泄漏情况发生。</span></p><p>&nbsp;</p><h3><a name="40源码分析线程特有存储模式在网关zuul和spring事务管理源码中的应用" class="md-header-anchor"></a><strong><span>40_源码分析：线程特有存储模式在网关zuul和Spring事务管理源码中的应用</span></strong></h3><p><span>我们在之前的文章中详细对JDK的ThreadLocal的底层原理进行详细的讲解，且动手实现高安全性用户密码系统发送短信随机密码案例，同时我们也讲解了ThreadLocal在线程池中使用可能存在内存泄露问题，以及如何避免内存泄露情况的发生，相信同学们对ThreadLocal有了全面了解和认识。</span></p><p>&nbsp;</p><p><span>那我我们就长话短说，今天就来说说知名java开源项目里是如何使用ThreadLocal的？使用的场景是什么？</span></p><p><span>作为一个Java后端工程师，可能提到网关都不会陌生吧，那我们今天就一下大名鼎鼎Spring Cloud Netflix版本的Zuul网关组件是如何使用ThreadLocal的，那我们就来先看一下网关zuul整个流程图，请看下图图1</span></p><p>&nbsp;</p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/43888600_1623899370.png" referrerpolicy="no-referrer" alt="img"><span> 图1</span></p><p><span>通过上述图1，我们能清晰的看到zuul处理一个http请求的完整流程，从接受请求，获取对应url的配置规则，然后找到对应后端服务，把请求发送出去，最后返回给前端页面，那同学们有疑问了，到底哪里有ThreadLocal的使用场景啊，先别急，我们先来看看zuul的源码的实现，请看下图图2</span></p><p>&nbsp;</p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/98876600_1623899370.png" referrerpolicy="no-referrer" alt="img"></p><p><span> 图2</span></p><p><span>从上述图2红线处，我们能看到，zuul的源码的实现和我们上面的流程图是一样的，先是执行preRoute，再执行route，最后执行postRoute，那同学们，问题来了，我们在流程图里可以看到，每个route都是有上下文信息层层传递的，但是对应route方法是没有入参的，他们之间是如何传递的呢，请看下图图3</span></p><p>&nbsp;</p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/42112200_1623899371.png" referrerpolicy="no-referrer" alt="img"><span> 图3</span></p><p>&nbsp;</p><p><span>从上述图3中红线处，我们清晰的看到，zuul接受请求的时候会先执行一个init方法，传入对应请求的servletRequest和response，那我们再看看init的方法细节，请看图图4</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/92313400_1623899371.png" referrerpolicy="no-referrer" alt="img"></p><p>&nbsp;</p><p><span> 图4</span></p><p><span>从上述图4中，我们能清晰的看到，就是把每个请求的Request和Response封装到一个RequestContext里，那么这个RequestContext里有什么呢？请看下图图5</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/16311200_1623899372.png" referrerpolicy="no-referrer" alt="img"><span>图5</span></p><p><span>从上述图5红线处，我们清晰的看到RequestContext里底层结构，对的，没错就是ThreadLocal，这就说明zuul每个请求都是一个单独的线程的来处理，通过ThreadLocal来实现上下文信息的传递，请看下面的流程图图6</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/41172800_1623899372.png" referrerpolicy="no-referrer" alt="img"></p><p><span> 图6</span></p><p><span>从上述图6中，我们能看到，zuul在接受到请求的时候，先是执行init方法初始化，把对应请求Request和Response设置对自己对应的线程ThreadLocal</span><RequestContext><span>里，然后执行不同route逻辑，可以设置对应Request和Response的值，那么这里同学们可能会想，这样使用是否有内存泄露的情况发生呢，请同学们看下图图6</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/76877200_1623899372.png" referrerpolicy="no-referrer" alt="img"></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/10619300_1623899373.png" referrerpolicy="no-referrer" alt="img"></p><p><span>图7</span></p><p><span>通过上述图7红线处，想必同学们应该知道是否会出现内存泄露的问题啦，没错，答案就是不会出现，在finally里的执行对应线程的Threadlocal的remove方法，请看完整流程图图8</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/38112000_1623899373.png" referrerpolicy="no-referrer" alt="img"><span>图8</span></p><p><span>从上述图图8中，我们能清晰看到zuul的ThreadLocal</span><RequestContext><span>的是如何使用的，相信能对同学们对ThreadLocal有更深的理解。</span></p><p>&nbsp;</p><p><span>  看完zuul源码ThreadLocal的使用，下面我们再来看一下Spring框架，同学们应该都知道或者使用过，另外大家也都应该接触过数据库mysql，那么对事务的概念就应该都不陌生了吧，那我们接下来就来聊聊，Spring的事物管理器中是如何使用ThreadLocal的？首先我们先看一下整个SQL提交的流程图图9</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/60291600_1623899373.png" referrerpolicy="no-referrer" alt="img"><span>图9</span></p><p><span>对于上图图9整个SQL执行的整个流程相信同学们应该是熟悉的，那么对于java开发SQL执行代码来说，就是在我们写好执行SQL的方法代码上加上一个Transactional注解，那么Spring框架就会自动帮我们管理这个SQL从提交到执行再到SQL执行结束整个流程，这个同学们应该是了解的，那么接下来就来看看Spring的代码实现，请看下图图10</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/94265000_1623899373.png" referrerpolicy="no-referrer" alt="img"></p><p><span> 图10</span></p><p><span>这里提前说明一下，由于本文不是专门讲解的Spring的源码，下面的讲解可能不会讲解的那么详细，主要是讲解ThreadLocal在Spring源码框架的使用场景，希望同学们见谅。那我们言归正传，由于我们java代码里加了Transactional注解，其实会被TranctionInterceptor拦截执行对应的invoke方法，然后执行对应invokeWithInTransaction方法，那我就接着往下看看这个方法的实现，请看下图图11</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/34231800_1623899374.png" referrerpolicy="no-referrer" alt="img"></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/80579800_1623899374.png" referrerpolicy="no-referrer" alt="img"></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/24627200_1623899375.png" referrerpolicy="no-referrer" alt="img"><span> 图11</span></p><p><span>这里为了让同学们看的更清晰一些，所以上面把这个方法的执行层次都罗列上了，那我们重点看一下图11的蓝色线1处，总的来说就是获取一个数据库连接，然后开始一个事务，封装了一些事务信息等组成了一个TransactionInfo对象，那么在蓝色线2处的方法又是什么样的逻辑呢？请看下图图12</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/47374100_1623899375.png" referrerpolicy="no-referrer" alt="img"></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/66251000_1623899375.png" referrerpolicy="no-referrer" alt="img"></p><p><span> 图12</span></p><p><span>到了这里其实，我们从图12中能清晰的看到，把事务信息组成一个TransactionInfo对象之后，然后把这些信息都保存到了当前线程里的ThreadLocal里，这样再执行后面事务的提交和回滚的时候，都是从当前线程里获取的事务信息的，这也说明了spring的事务管理是不能跨线程执行的，否则找不到对应的事务信息啦，最后Spring的事务管理器在处理完一个事务之后，也会把当前的线程所持有的事务信息清理掉，请看下图图13</span></p><p>&nbsp;</p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/97842500_1623899375.png" referrerpolicy="no-referrer" alt="img"><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/18955600_1623899376.png" referrerpolicy="no-referrer" alt="img"><span> 图13</span></p><p><span>想必到了这里，同学们对spring的事务管理器是如何使用ThreadLocal的应该有所了解了吧，那我们再来看一下整个Spring的执行流程图图14</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/40512200_1623899376.png" referrerpolicy="no-referrer" alt="img"></p><p><span>图14</span></p><p><span>最后总结一下，通过上面两个开源项目Zuul和Spring的源码中ThreadLocal的使用讲解，希望对同学们能对ThreadLocal的学习有所新的收获。</span></p><p>&nbsp;</p><h3><a name="41抛砖引玉大白话聊聊串行化线程封闭模式工作原理" class="md-header-anchor"></a><strong><span>41_抛砖引玉：大白话聊聊串行化线程封闭模式工作原理</span></strong></h3><p><span>在java的并发编程里，一个变量如果被多个线程所使用，很可能会引入同步问题。为解决同步问题，java引入了包括wait、notify，AQS、同步关键字等在内的多种解决方案，不过这类编程方式，肉眼可见会增加程序的复杂性，考虑不周容易产生bug。那有没优雅解决同步问题的方式呢？当然有！让我们进入今天的正题-线程封闭。</span></p><p>&nbsp;</p><p><span>线程封闭就是仅在同一个线程内访问对象，不与其他线程共享。实现了这种效果的技术，统一称为线程封闭（thread confinement），是一种常见的线程安全设计策略。</span></p><p>&nbsp;</p><p><span>下文用线程池举例。当向线程提交任务时，流转图如下所示：</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/51267200_1623899971.png" referrerpolicy="no-referrer" alt="img"></p><p><span>图1</span></p><p>&nbsp;</p><p>&nbsp;</p><p><span>多个任务并行执行，任务队列中均为单独的任务，此时使用线程池执行对结果无影响。但在某些业务场景中，任务队列中的任务会被划分成若干子任务，每个任务内部子任务需要严格按照顺序执行，但是不同的任务可以并行执行。如不做限制，执行结果可能如图2所示：</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/87071000_1623899971.png" referrerpolicy="no-referrer" alt="img"></p><p><span>图2</span></p><p>&nbsp;</p><p><span>在执行过程中线程2抢了1-1，线程3抢了1-2，此时破坏了业务语义，结果异常。而我们要求的是同一个线程执行完1-1 后 顺序执行1-2、1-3。如图3所示：                </span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/7639000_1623899972.png" referrerpolicy="no-referrer" alt="img"></p><p><span> 图3</span></p><p>&nbsp;</p><p><span>看到这里，就是我们这篇文章的正题了，图3就是我们要实现的串行线程封闭原理。下篇文章我们将用生产代码结合时序图来讲解，相信学习之后你会有更深入的理解，敬请期待。</span></p><p>&nbsp;</p><h3><a name="42案例实战如何实现一个用于分析excel报表文件商业智能bi系统" class="md-header-anchor"></a><strong><span>42_案例实战：如何实现一个用于分析excel报表文件商业智能BI系统</span></strong></h3><p><span>上一篇文章我们讲解了串行线程封闭的基本原理，本篇文章我们基于线程封闭原理，在商业智能BI系统中导出excel报表。在实践之前，我们对串行线程封闭原理做个简单回顾，即通过将多个并发任务存入队列实现任务的串行化，并为这些串行化任务创建唯一的工作者线程进行处理。注意是唯一，也就是说一个工作线程。如图1所示：</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/82586200_1623900147.png" referrerpolicy="no-referrer" alt="img"></p><p><span> 图1</span></p><p><span>从图1可以看出，任务依次放入队列中，从而将无序的任务串行化了。本质就是使用一个开销更小的锁（队列锁）去替代另一个可能开销更大的锁（非线程安全对象引用的锁）</span></p><p>&nbsp;</p><p><span>现在进入正题，导出excel的需求绝大多数同学都做过，但使用方法相信各不相同，这里不讨论方案优劣，只给出串行线程封闭方案。按照惯例，首先来张示意图。</span></p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/1370900_1623900148.png" referrerpolicy="no-referrer" alt="img"></p><p><span> 图2</span></p><p>&nbsp;</p><p><span>我们在写代码时，一般都会提供一个对外的包装类，该类包含了外部所需的功能方法，并对外屏蔽实现细节。使用包装类时，一般流程是这样，首先初始化功能对象，其次调用对象提供方法，当调用完成时，会提供终止或销毁方法，调用方可以显式调用，也可不理会，由包装类自行处理。对照该流程我们一步步分析：</span></p><p>&nbsp;</p><p><span>包装类初始化的同时会初始化工作线程并启动，工作线程默认构造方法中初始化了队列和下载客户端。前文我们提到了只有一个工作线程，那这种构造意味着什么呢？意味着该工作线程和任务队列及下载客户端绑定在一起，作为一个整体参与流程，这样就实现了任务队列中任务按顺序依次下载的目的。这段话有点烧脑，建议多看几遍。</span></p><p>&nbsp;</p><p><span>第一步中下载任务，会不停的把任务放到初始化构造的队列中。当工作线程把任务都处理完毕后，设置标志，工作线程终止，提一句，这里使用volatile修饰变量，线程监听这个变量的状态变化。</span></p><p>&nbsp;</p><p><span>代码用怎么样的呈现形式呢? 如果大段的粘贴代码，感觉不太靠谱，麻烦老师给个建议吧~~</span></p><p>&nbsp;</p><p><span>到这里今天的文章就接近尾声了，那这样是否就是完美的解决方案？当然不是，那接下来要做什么呢？先卖个关子，咱们还是下节说~</span></p><p>&nbsp;</p><h3><a name="43动手演练实现基于串行线程封闭模式的通用代码" class="md-header-anchor"></a><strong><span>43_动手演练：实现基于串行线程封闭模式的通用代码</span></strong></h3><p><span>上节我们用商业智能BI系统导出excel报表的场景深入实践了串行线程封闭并展示了部分核心接口代码，实现了预期功能。大多数情况下，实现了产品需求也就完事了，不会过多关注代码的优雅，扩展性，性能等。理由也很充分，工期紧，倒排期等等。客观原因确实存在，但代码是程序员的门面，既然从事了这个行业，就克服困难，追求完美。</span></p><p>&nbsp;</p><p><span>以导出excel报表的功能为例，该类需求是共性的，我们可以考虑将其封装成标准化组件，对使用方透明。业务方通过外部传参的即可实现excel导出，提升工作效率。</span></p><p>&nbsp;</p><p><span>笔者尝试给出自己的代码架构图，如图1所示：</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/74215500_1623900855.png" referrerpolicy="no-referrer" alt="img"></p><p>&nbsp;</p><p><span>                             图1</span></p><p><span>我们站在开发者角度，拿到一个工具组件，考量点是什么呢？至少应包含以下几点吧-易用性，可扩展，性能高等等，以下结合这些点进行讲解。</span></p><p>&nbsp;</p><p><span>首先从易用性说起，简而言之就是上手简单，从main函数看，创建一个对象，初始化，调用方法，获取结果，符合我们常见的程序执行流。相信使用没有障碍。如果实现类似导出功能，简单几行代码就搞定了，是不是很简单。</span></p><p>&nbsp;</p><p><span>再说扩展性，同样导出任务，有可能张三导出的是excel，李四导出的是txt。解析出数据。张三存储到mysql中，李四丢到es等各类场景，所以不能对此做限制。在设计上，可以实现接口，亦可以继承抽象类，图中SomeService继承抽象类AbstractSerializer，重写了makeTask方法。</span></p><p>&nbsp;</p><p><span>最后说说性能，程序员最熟悉且实现最多的是业务接口，从上往下顺序执行并返回结果。但执行耗时长的功能，比如文中导出文件类功能一般使用线程池异步执行，使用者丢任务到线程池中并注册钩子函数，线程池执行完毕通知调用者。图1中使用了线程池并使用future.get()获取结果。</span></p><p>&nbsp;</p><p><span>当然这里只是简单列举了通用代码的设计方法，后续读者可阅读下发的专栏代码进一步学习。对代码设计能力的学习是无止境的，笔者所知也仅皮毛。本节抛砖引玉，愿与大家一起学习，共同进步。咱们下节见~</span></p><p>&nbsp;</p><h3><a name="44案例实战如何解决电商平台中的商品分析系统分析热点商品过慢问题" class="md-header-anchor"></a><strong><span>44_案例实战：如何解决电商平台中的商品分析系统分析热点商品过慢问题？</span></strong></h3><p><span>我们先来分析一个在电商业务中比较常见的需求：某电商平台需要一个流量统计工具，分析平台的热点商品。该工具的统计依据是系统接口运行时产生的请求日志文件，它记录了收到请求的类型、商品的ID、请求时间戳等。其格式如图一：</span></p><p>&nbsp;</p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/90116300_1623901054.png" referrerpolicy="no-referrer" alt="img"></p><p><span>                                图1</span></p><p>&nbsp;</p><p><span>其中日志文件每小时生成一个。统计工具要支持统计指定时间段内的系统流量。因此我们需要找到指定的时间段的接口日志文件，并且读取它进行流量统计。整个过程如图二：</span></p><p>&nbsp;</p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/20428000_1623901055.png" referrerpolicy="no-referrer" alt="img"></p><p><span>                                  图2</span></p><p>&nbsp;</p><p><span>文件的读取和分析是串行的，也就是说，只有当一个日志文件处理完成之后，才会对下一个日志文件进行处理。直到读取完所有的日志文件，并汇总统计出最终的热门商品列表。一般情况下，如统计范围为一个小时内，就只需要读取一个文件进行统计，不会存在什么性能问题。但是真实情况其实不是这么简单，下面来给大家分析一下。</span></p><p>&nbsp;</p><p><span>对于运营人员来说，需要统计的时间范围是灵活多变的，也许是统计某天，或者某几天内的热门商品列表。用目前的方式来实现的话，那么整个处理流程完全串行，那么统计的过程会非常慢。如果能更快地进行统计，根据其结果调整商品的展示策略，以及提前准备充足的库存，将会使收益最大化。但是由于我们统计的实在是太慢了，统计结果将无法及时呈现，也错过了最佳投放时间和备货时间，造成商品库存供应不及时。最终就会造成收益下降。这种结果，肯定不是我们想看到的。</span></p><p>&nbsp;</p><p><span>何况随着系统用户量不断攀升，以及商品数量不断增加，每小时内的日志量将会呈指数增长。到那时，光是统计一个小时内的数据，都非常耗时。如果不能及时统计结果，调整商品展示策略，将会造成公司的损失。</span></p><p>&nbsp;</p><p><span>那么具体要怎么来优化才好呢？后续的章节，我们会继续给大家讲解。敬请期待！</span></p><p>&nbsp;</p><h3><a name="45图文讲解大白话聊聊主仆模式的工作原理" class="md-header-anchor"></a><strong><span>45_图文讲解：大白话聊聊主仆模式的工作原理</span></strong></h3><p><span>上一篇文章在对日志文件进行分析统计时，我们遇到文件过多过大的情况下，无法快速的统计热门商品的问题。那么现在我们看一个现实生活中的小案例，然后来看一下对应的解决方案。</span></p><p>&nbsp;</p><p><span>某天临近下班前，公司突然接到上级部门通知，要求在下班前统计出整个公司已经注射了疫苗的人员名单，公司集团HR收到消息后，心想一个人肯定在规定时间内完成不了，于是马上将任务进行了拆分。</span></p><p>&nbsp;</p><p><span>首先，需要让各个部门的HR在半小时内统计打完疫苗的人员名单。其次，由他来进行汇总，并报告上级部门。按照这个思路，集团HR马上通知各个部门的HR，要求半个小时内统计出各自部门打完疫苗的人员名单。部门HR接到消息后，马上回复“好的，收到，会按时完成任务。”于是集团HR就进入到等待中。然后部门HR就将消息同步到部门内各个小组负责人，要求15分钟内统计出各组内打完疫苗的人员名单。小组Leader在收到通知后，也是回复“好的，收到”，于是部门HR也进入了等待中。现在整个流程如图一：</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/6511500_1623901393.png" referrerpolicy="no-referrer" alt="img"></p><p><span>图一</span></p><p><span>虚线表示收到任务后，回复的“好的，收到”。当各个小组Leader收到消息后，不能再往下分了，于是要马上开始干活了。所以询问组内成员的疫苗接种情况，并对信息进行汇总统计。然后在规定的时间内，将组内的数据上报到部门HR处。部门HR对各组Leader上报的消息再进行汇总统计。然后上报给集团的HR。整个流程如图二：</span></p><p>&nbsp;</p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/42940700_1623901393.png" referrerpolicy="no-referrer" alt="img"></p><p><span>图二</span></p><p><span>集团HR在收到各部门汇报的人员名单后，再进行汇总统计，最终得到全公司所有接种人员的名单。于是马上将最终结果汇报给了上级部门。终于赶在下班前，完成了上级部门交待的任务。</span></p><p>&nbsp;</p><p><span>我们回顾一下，在整个处理过程中集团HR更像是一个中间协调的负责人的身份。当他收到上级部门的通知后，先是对任务进行拆分，然后再通知部门HR让他们分别去统计。他只需要在规定的时间内收到部门HR的统计结果即可。同时对于上级部门来说，他并不需要知道具体的处理细节。只关心最终的数据。如图三：</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/68817000_1623901393.png" referrerpolicy="no-referrer" alt="img"></p><p><span>图三</span></p><p><span>其核心就是一个基于分而治之思想的设计模式。将一个任务（统计所有打完疫苗的人员名单）分解为若干等同的子任务（统计各部门内所有打完疫苗的人员名单），并由专门的工作者线程（各部门的HR）来并行的执行这些子任务。而上级部门交待给集团HR的任务结果，是通过整合各个子任务的处理结果而形成的。而且这些拆分、汇总相关的处理细节，对于上级部门来说是不可见的。这种工作模式即提高了效率，又实现了细节的隐藏。</span></p><p>&nbsp;</p><p><span>那么这种工作模式，我们就称之为主仆模式（Master-Slave）。对于整个模式的处理流程，我们可以通过一张图片来概括，如图四：</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/99310300_1623901393.png" referrerpolicy="no-referrer" alt="img"></p><p><span>图四</span></p><p><span>Master：负责原始任务的拆分、并对子任务进行分发和对子任务的结果进行汇总统计。主要方法如下：</span></p><p>&nbsp;</p><ul><li><span>analysis：这是Master对外暴露的方法，用于接收原始的任务，并返回处理结果</span></li></ul><p>&nbsp;</p><ul><li><span>createAndStartWorkers：创建并启动Slave，等待Master分配任务</span></li></ul><p>&nbsp;</p><ul><li><span>dispatchTask：将任务进行拆分，并分配给各个Slave去执行</span></li></ul><p>&nbsp;</p><ul><li><span>gatherer：将各个子任务的处理结果进行采集合并，形成原始任务的处理结果。</span></li></ul><p>&nbsp;</p><p><span>Slave则主要负责对子任务进行处理。</span></p><p>&nbsp;</p><p><span>其中还有几个细节的点需要注意：</span></p><p>&nbsp;</p><p><span>一：对于部门HR的角色，相对于集团HR来说，他是一个执行者（Slave），但是相对小组Leader来说，他也是一个负责人（Master）。</span></p><p>&nbsp;</p><p><span>二：在我们的案例中，HR（Master）分配任务后，都会获得执行者（Slave）的一个响应或者称之为承诺（Promise，是不是想起了我们前面讲过的烧开水泡茶的案例了？）那么有了这个Promise之后，Master只需要在约定好的时间内，就能够获取到Slave的统计结果。本质就是子任务的处理结果如何收集的问题。</span></p><p>&nbsp;</p><p><span>三：在这个执行的过程当中，可能还会有小组Leader（Slave）由于临时有事，导致没来得及开始执行HR分配的任务，于是其他已经完成任务的小组Leader（Slave）这时候自告奋勇的过来帮他统计了组内打完疫苗的人员名单。其实就是一个工作量的负载均衡和工作窃取的问题。由于原先小组Leader的工作太多，导致任务积压，这时候空闲的小组Leader来获取了积压的任务，并进行了处理。</span></p><p>&nbsp;</p><p><span>四：还有可能小组Leader在执行任务的过程中，他的直系Leader要求他汇报工作，打断了他现在正在执行的任务。但是由于他之前给过HR一个Promise，于是到约定的时间后，HR能够马上发现某个小组Leader没有在约定时间内汇报结果。那么为了能够顺利完成任务，HR直接自己去对该小组内打完疫苗的人员进行了统计。最终顺利的完成了任务。对应的就是可靠性保障和对异常的处理。能够通过Promise去感知到某个子任务执行异常，并通过自身去重新执行处理失败的子任务，提高了统计的可靠性。</span></p><p>&nbsp;</p><p><span>好了，到这里相信大家也已经明白了主仆模式的原理，以及应对各种突发问题的解决方案。接下来的章节，我们会基于主仆模式对热门商品分析慢的问题来进行优化。敬请期待！</span></p><p>&nbsp;</p><h3><a name="46性能优化基于主仆模式优化电商平台热点商品分析系统" class="md-header-anchor"></a><strong><span>46_性能优化：基于主仆模式优化电商平台热点商品分析系统</span></strong></h3><p><span>上一篇文章讲解了主从模式的工作原理以及该模式的架构设计，本篇文章通过一个小案例来给大家讲讲主从设计模式的运用。</span></p><p>&nbsp;</p><p><span>一个电商台用户量已达到数亿级别，此时如果想要统计出所有商品的销售数量，从而知晓有哪些热点商品。如果直接从关系型数据库里直接查询并排序，性能之差可见一般，此时就一定有一个存放海量数据的日志平台来辅助商家完成对热点数据统计。如图1:</span><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/76801400_1623901566.jpeg" referrerpolicy="no-referrer" alt="img"></p><p><span>                                     图1</span></p><p><span>从图1中我们可以看到，当服务端接收到用户获取每个商品的销售量时，意味着只有一个线程从海量的日志文件里读取每一条商品销售数据进行统计，那么此时这个系统的吞吐量也是十分堪忧的,并且1秒内返回给用户数据的精确性十分有限，那么如果我们启用多线程来处理情况大致如图2：</span><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/96475600_1623901566.jpeg" referrerpolicy="no-referrer" alt="img"></p><p><span>                                      图2</span></p><p><span>很明显，此时虽然有多个线程可以用于统计热点数据，但是客户端只能将请求只能交给一个线程去处理请求，无法并行执行，此时就需要一个管控线程，来负责接收用户请求，并进行任务分配，从而达到多个线程并行处理热点数据统计的效果，如图3：</span><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/15227800_1623901567.jpeg" referrerpolicy="no-referrer" alt="img"></p><p><span>                                    图3</span></p><p><span>此时客户端就可以通过连接master线程由它来进行请求的分发，但是呢，由于master线程和slave线程高度耦合，吞吐量问题始终未能解决，此时就只能引入内存队列让两个线程进行解耦，彼此的执行效率互不干扰，如图4：</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/32034100_1623901567.jpeg" referrerpolicy="no-referrer" alt="img"></p><p><span>                                如图4</span></p><p><span>案例源码走读</span></p><p><span>现在大家都对这个案例背景有些了解了，再来看看项目案例的源码加深理解，如图5：</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/53001600_1623901567.png" referrerpolicy="no-referrer" alt="img"></p><p><span> 图5</span></p><p>&nbsp;</p><p><span>重点关注框出来的方法，进去看一下它的逻辑 ，如图6：</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/70201100_1623901567.png" referrerpolicy="no-referrer" alt="img"></p><p><span> 图6</span></p><p>&nbsp;</p><p><span>从图中我们明显能看出Worker是一个实现了两阶段终止的线程，核心处理逻辑是由doRun方法实现的。不过我们还是先关注任务的分发逻辑。也就是dispatchTask方法的逻辑，如图7：</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/94102300_1623901567.png" referrerpolicy="no-referrer" alt="img"></p><p><span>图7</span></p><p>&nbsp;</p><p><span>大家可以跟着代码注释理解，值得一提的是makeReaderFrom方法，用到了流合并技术，也就是一个输入流包含多个文件内容，好了，这些都介绍完毕之后，我们来看看 Worker的doRun方法，如图8：</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/22732700_1623901568.png" referrerpolicy="no-referrer" alt="img"></p><p><span>图8</span></p><p>&nbsp;</p><p><span>说白了，就是对输入流中读取出来的json串中的商品id进行统计。</span></p><p><span>下一讲我将给大家带来Fork/Join源码的解析</span></p><p>&nbsp;</p><h3><a name="47源码分析学习一下jdk源码中fork-join的主仆模式的实现" class="md-header-anchor"></a><strong><span>47_源码分析：学习一下JDK源码中fork join的主仆模式的实现</span></strong></h3><p><span>上一篇文章，我们用一个分批处理日志文件的小案例，让大家初步了解了一下主从模式的运用，但是那个案例还是不够完美，因为不能很好的展现主从模式解决问题的核心思想——分治，而Java大师Doug Lea 已经为我们提供了一个解决分治问题的框架——ForkJoinPool，此次就以它为切入点，讲解主从模式运用。</span></p><p>&nbsp;</p><p><span>为什么要分治</span></p><p><span>在进入正题之前，我们先理解一下分治的作用，就以一个运用分治不当的反例来讲解。清太祖努尔哈赤，大清帝国的奠基人，同时也是明王朝的掘墓人，可以说是身经百战，其中萨尔浒之战最为人津津乐道。这场战争的胜利很大程度上得益于抓住了敌方不会分治的弱点，如图1：</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/80692900_1623902551.png" referrerpolicy="no-referrer" alt="img"></p><p><span>                                   图1</span></p><p><span>虽然表面上明军包围了后金军，但是其人多的优势也被大大削弱了，所以后金军有机会以少胜多。如果明军四路人马同时出发上战场，足足十二万大军，六倍于后金军队，后金军的胜利机会就极其渺茫了。所以分治所能解决的问题，就是把要处理的单个庞大资源，进行分解和弱化。在程序里将这些分解后的资源，分配给多个线程并行处理，处理完成之后再将结果进行聚合，场景类似图2：</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/15302900_1623902552.jpeg" referrerpolicy="no-referrer" alt="img"></p><p><span>                                    图2</span></p><p><span>在上图的案例中，当接收到不多于两份文件时，接收任务的人员可以直接处理。否则就将文件进行分解，平均分配给两个人。其中整个过程都是在重复相同的步骤，只要数据小到一定的规模，无法再分解，整流程算结束，否则这个重复的流程将会一直重复下去，说白了就是一个递归场景，当所有的分支任务结束之后，将他们的执行结果进行聚合就OK了。</span></p><p>&nbsp;</p><p><span>好了，从上面的分支场景我们可以看出，一个典型的分治场景往往具备四个步骤：</span></p><ol start='' ><li><span>任务分解</span></li><li><span>并行执行</span></li><li><span>逻辑递归</span></li><li><span>结果聚合</span></li></ol><p>&nbsp;</p><p><span>ForkJoinPool的代码Demo</span></p><p>&nbsp;</p><p><span>在开始讲解ForkJoinPool的源代码之前，我们先做一下热身运动，让大家体验一下ForkJoinPool的使用：</span></p><pre spellcheck="false" class="md-fences md-end-block ty-contain-cm modeLoaded" lang=""><div class="CodeMirror cm-s-inner CodeMirror-wrap" lang=""><div style="overflow: hidden; position: relative; width: 3px; height: 0px; top: 0px; left: 8px;"><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0" style="position: absolute; bottom: -1em; padding: 0px; width: 1000px; height: 1em; outline: none;"></textarea></div><div class="CodeMirror-scrollbar-filler" cm-not-content="true"></div><div class="CodeMirror-gutter-filler" cm-not-content="true"></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer" style="margin-left: 0px; margin-bottom: 0px; border-right-width: 0px; padding-right: 0px; padding-bottom: 0px;"><div style="position: relative; top: 0px;"><div class="CodeMirror-lines" role="presentation"><div role="presentation" style="position: relative; outline: none;"><div class="CodeMirror-measure"><pre><span>xxxxxxxxxx</span></pre></div><div class="CodeMirror-measure"></div><div style="position: relative; z-index: 1;"></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline" style="position: relative;"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter" style="left: 0px; width: 0px;"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">public class ForkJoinRecursiveTaskTest { &nbsp;  /** &nbsp; &nbsp; * 可进行处理的数字差，超过了就要进行任务分解 &nbsp; &nbsp; */ &nbsp; private  static int threshold = 100; &nbsp;  public static void main(String[] args) { &nbsp; &nbsp; &nbsp;  final ForkJoinPool forkJoinPool = new ForkJoinPool(); &nbsp; &nbsp; &nbsp;  ForkJoinTask&lt;Integer&gt; future = forkJoinPool.submit(new MyRecursiveTask(0, 1000)); &nbsp; &nbsp; &nbsp;  try { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  Integer result = future.get(); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  System.out.println(result); &nbsp; &nbsp; &nbsp;  } catch (InterruptedException e) { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  e.printStackTrace(); &nbsp; &nbsp; &nbsp;  } catch (ExecutionException e) { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  e.printStackTrace(); &nbsp; &nbsp; &nbsp;  } &nbsp;  } &nbsp;  private static class MyRecursiveTask extends RecursiveTask&lt;Integer&gt; { &nbsp; &nbsp; &nbsp;  /** &nbsp; &nbsp; &nbsp; &nbsp; * 起始数字 &nbsp; &nbsp; &nbsp; &nbsp; */ &nbsp; &nbsp; &nbsp;  private final int start; &nbsp; &nbsp; &nbsp;  /** &nbsp; &nbsp; &nbsp; &nbsp; * 终止数字 &nbsp; &nbsp; &nbsp; &nbsp; */ &nbsp; &nbsp; &nbsp;  private final int end; &nbsp; &nbsp; &nbsp;  MyRecursiveTask(int start, int end) { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  this.start = start; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  this.end = end; &nbsp; &nbsp; &nbsp;  } &nbsp; &nbsp; &nbsp;  @Override &nbsp; &nbsp; &nbsp;  protected Integer compute() { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  if (end - start &lt;= threshold) { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  // 此范围的数字进行累加,并返回结果 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  return IntStream.rangeClosed(start, end).sum(); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  } else { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  // 将数据规模进行分解 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  int middle = (start + end) / 2; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  // 将分解后的数据分发给子线程 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  MyRecursiveTask firstTask = new MyRecursiveTask(start, middle); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  MyRecursiveTask secondTask = new MyRecursiveTask(middle + 1, end); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  // 将子任务，放入执行队列等待执行 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  secondTask.fork(); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  firstTask.fork(); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  // 等待子线程任务执行完毕并获取聚合执行结果， &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  return firstTask.join() + secondTask.join(); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  } &nbsp; &nbsp; &nbsp;  } &nbsp;  }}</span></pre></div></div></div></div></div></div><div style="position: absolute; height: 0px; width: 1px; border-bottom: 0px solid transparent; top: 460px;"></div><div class="CodeMirror-gutters" style="display: none; height: 460px;"></div></div></div></pre><p>&nbsp;</p><p><span>这个案例十分的简单，就是求0-1000的累加之和，并且一个线程能进行累加的数字范围之差不能大于100，否则就要将数据规模分解后在执行，所以一旦数字范围差值大于100就得拆分出两个新的任务对象，通过fork方法将子任务，放入任务队列之中,被后续异步执行，然后通过join方法等待任务执行完毕，并获取结果，这也就意味着join方法一旦调用就会使当前线程阻塞。</span></p><p>&nbsp;</p><p><span>不知道大家注意到一个有点不自然的地方，如图3：</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/46577300_1623902552.jpeg" referrerpolicy="no-referrer" alt="img"></p><p><span>                                     图3</span></p><p><span>从图中我们可以看到，虽然接收数据的规模已经超过了一个人能处理的范围，但经过这个人进行数据分解后，部分数据已经达到他可以处理的能力范围内，但他还是将任务，分配给了别人，这无疑增加了用人成本，所以我们要达到图4的效果：</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/76342500_1623902552.jpeg" referrerpolicy="no-referrer" alt="img"></p><p><span>                                   图4</span></p><p>&nbsp;</p><p>&nbsp;</p><p><span>那么要想实现图5的效果，我的demo就要做一个小小的改动了，如图6：</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/16927500_1623902553.png" referrerpolicy="no-referrer" alt="img"></p><p><span>图6</span></p><p>&nbsp;</p><p>&nbsp;</p><p><span>那么，我们不妨看一下invokeAll方法的实现，验证一下结果是不是如我们所愿，如图7：</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/49411900_1623902553.png" referrerpolicy="no-referrer" alt="img"></p><p><span>                                  图7</span></p><p><span>从图7中我们可以看到传入的t2还和原来一样被放入队列之中，之后的t2.doJoin()完全可以理解成执行了join()方法，而t1.doInvoke()就是同步方法执行，并获取结果。</span></p><p>&nbsp;</p><p><span>主菜来咯——ForkJoinPool的源码分析</span></p><p><span>话不多说，先看一下ForkJoinPool的构造方法</span></p><pre spellcheck="false" class="md-fences md-end-block ty-contain-cm modeLoaded" lang=""><div class="CodeMirror cm-s-inner CodeMirror-wrap" lang=""><div style="overflow: hidden; position: relative; width: 3px; height: 0px; top: 0px; left: 8px;"><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0" style="position: absolute; bottom: -1em; padding: 0px; width: 1000px; height: 1em; outline: none;"></textarea></div><div class="CodeMirror-scrollbar-filler" cm-not-content="true"></div><div class="CodeMirror-gutter-filler" cm-not-content="true"></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer" style="margin-left: 0px; margin-bottom: 0px; border-right-width: 0px; padding-right: 0px; padding-bottom: 0px;"><div style="position: relative; top: 0px;"><div class="CodeMirror-lines" role="presentation"><div role="presentation" style="position: relative; outline: none;"><div class="CodeMirror-measure"><pre><span>xxxxxxxxxx</span></pre></div><div class="CodeMirror-measure"></div><div style="position: relative; z-index: 1;"></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline" style="position: relative;"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter" style="left: 0px; width: 0px;"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> private ForkJoinPool(int parallelism, &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ForkJoinWorkerThreadFactory factory, &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; UncaughtExceptionHandler handler, &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; int mode, &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; String workerNamePrefix) { &nbsp; &nbsp; &nbsp;  this.workerNamePrefix = workerNamePrefix; &nbsp; &nbsp; &nbsp;  this.factory = factory; &nbsp; &nbsp; &nbsp;  this.ueh = handler; &nbsp; &nbsp; &nbsp;  this.config = (parallelism &amp; SMASK) | mode; &nbsp; &nbsp; &nbsp;  long np = (long)(-parallelism); // offset ctl counts &nbsp; &nbsp; &nbsp;  this.ctl = ((np &lt;&lt; AC_SHIFT) &amp; AC_MASK) | ((np &lt;&lt; TC_SHIFT) &amp; TC_MASK); &nbsp;  }</span></pre></div></div></div></div></div></div><div style="position: absolute; height: 0px; width: 1px; border-bottom: 0px solid transparent; top: 161px;"></div><div class="CodeMirror-gutters" style="display: none; height: 161px;"></div></div></div></pre><p>&nbsp;</p><p><span>其中有两个参数需要注意：</span></p><ol start='' ><li><span>parallelism：并行数，决定同时允许多少线程同时执行，默认是CPU的核数</span></li><li><span>mode:任务队列的工作模式，有FIFO，LIFO两种，默认LIFO</span></li></ol><p>&nbsp;</p><p><span>接着就是把我们的task进行提交，为节约篇幅，我们直接告诉大家当调用submit发方法会执行哪个核心方法，如图8：</span></p><p>&nbsp;</p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/76331400_1623902553.png" referrerpolicy="no-referrer" alt="img"></p><p><span>图8</span></p><p>&nbsp;</p><p><span>这个方法看着挺吓人其实就做了怎么几件事：</span></p><ul><li><span>实例化workQueues</span></li><li><span>创建一个无附属线程的workQueque，与workQueues中的指针关联，并将task入队，workQueque的top指针递增1</span></li><li><span>创建一个ForkJoinWorkerThread实例并为其绑定一个新的workQueque进行绑定（此workQueque没数据），并调用其start方法。</span></li></ul><p>&nbsp;</p><p><span>讲到这里我们梳理一下ForkJoinPool的结构图，大致如图9：</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/92548300_1623902553.jpeg" referrerpolicy="no-referrer" alt="img"></p><p><span>                                   图9</span></p><p><span>至于那个top指针有啥用，当讲到workQueue源码时，再和大家详细讲。</span></p><p>&nbsp;</p><p><span>既然ForkJoinWorkerThread是一个线程，自然要关注它的run方法啦，同样我们直接定位到核心方法上去，如图10：</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/31994900_1623902554.png" referrerpolicy="no-referrer" alt="img"></p><p><span>图10</span></p><p>&nbsp;</p><p><span>从图9我们可以知道，此时ForkJoinWorkerThread附属的workQueue里面并没有数据，真正要开始执行任务必须要利用ForkJoinWorkerThread来完成任务的执行，这就涉及到ForkJoinPool里面最为亮眼设计——任务窃取，what? 还有这种操作？实现原理大致如图11：</span></p><p>&nbsp;</p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/53649600_1623902554.jpeg" referrerpolicy="no-referrer" alt="img"></p><p><span>                                    图11</span></p><p><span>从图中可以看出当worker线程处于空闲状态，它就会去随机找一个有任务的队列以FIFO的方式去抓取任务用来执行。当然在执行这个窃取来的任务的时候，如果分解出子任务，这些子任务也就要入队了。如图12：</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/71754400_1623902554.jpeg" referrerpolicy="no-referrer" alt="img"></p><p><span>                                    图12</span></p><p>&nbsp;</p><p><span>可以看出workQueue就是一个双端队列，通过top,base两个指针来进行维护的，不过要提醒大家一点就是top指针只有队列拥有者才能进行操控，进行入队和 LIFO的出队操作，指针位置可以双向移动，数值可增大可减小，并且top指针永远指向的是下一个元素的存放位置，而base指针指向的是被外部线程下一次即将取的位置，所以只能单向移动数值只能增大，这也就意味着base指针如果没有volatile进行修饰的话，数值的变更就会产生并发问题。</span></p><p>&nbsp;</p><p><span>而top只有队列的持有者才能访问，所以并不会产生并发问题。很明显此刻由于ForkJoinWorkerThread持有的队列里没有任何待执行任务，所以只能通过窃取，去获取可执行任务，也就是说scan方法，就是一个窃取操作。</span></p><p>&nbsp;</p><p><span>这个命名还是会产生一定误区的，我们接着看runTask方法的执行逻辑，如图13：</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/5681900_1623902555.png" referrerpolicy="no-referrer" alt="img"></p><p><span>图13</span></p><p>&nbsp;</p><p><span>从图中我们可以看到，窃取到任务之后，会优先执行窃取来的任务，紧接着继续执行自己队列里的任务，这个doExec就是我们定义的Task里compute()方法逻辑，我们着重看一下execLocalTasks方法，究竟有啥不同之处，代码如下：</span></p><pre spellcheck="false" class="md-fences md-end-block ty-contain-cm modeLoaded" lang=""><div class="CodeMirror cm-s-inner CodeMirror-wrap" lang=""><div style="overflow: hidden; position: relative; width: 3px; height: 0px; top: 0px; left: 8px;"><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0" style="position: absolute; bottom: -1em; padding: 0px; width: 1000px; height: 1em; outline: none;"></textarea></div><div class="CodeMirror-scrollbar-filler" cm-not-content="true"></div><div class="CodeMirror-gutter-filler" cm-not-content="true"></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer" style="margin-left: 0px; margin-bottom: 0px; border-right-width: 0px; padding-right: 0px; padding-bottom: 0px;"><div style="position: relative; top: 0px;"><div class="CodeMirror-lines" role="presentation"><div role="presentation" style="position: relative; outline: none;"><div class="CodeMirror-measure"><pre><span>xxxxxxxxxx</span></pre></div><div class="CodeMirror-measure"></div><div style="position: relative; z-index: 1;"></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline" style="position: relative;"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter" style="left: 0px; width: 0px;"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">final void execLocalTasks() { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  int b = base, m, s; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  // 本地队列赋值 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ForkJoinTask&lt;?&gt;[] a = array; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  // 队列里有未执行完的任务 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  if (b - (s = top - 1) &lt;= 0 &amp;&amp; a != null &amp;&amp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  (m = a.length - 1) &gt;= 0) { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; //判断是否以后进先出的方式进行出队操作 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  if ((config &amp; FIFO_QUEUE) == 0) { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  死循环 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  for (ForkJoinTask&lt;?&gt; t;;) { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  // 如果队列里已经没有任务，则跳出循环 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  if ((t = (ForkJoinTask&lt;?&gt;)U.getAndSetObject(a, ((m &amp; s) &lt;&lt; ASHIFT) + ABASE, null)) == null) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  break; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  // top进行递减（s=top-1） &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  U.putOrderedInt(this, QTOP, s); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  //执行任务 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  t.doExec(); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  // 根据指针差值判断是否有数据，没有数据则跳出循环 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  if (base - (s = top - 1) &gt; 0) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  break; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  } &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  } &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  else &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  // 以FIFO的出队方式进行出队操作 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  pollAndExecAll(); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  } &nbsp; &nbsp; &nbsp;  }</span></pre></div></div></div></div></div></div><div style="position: absolute; height: 0px; width: 1px; border-bottom: 0px solid transparent; top: 299px;"></div><div class="CodeMirror-gutters" style="display: none; height: 299px;"></div></div></div></pre><p>&nbsp;</p><p><span>好了现在我们重新把注意力放到我们的demo上，首先来看看fork方法是个啥逻辑，如图14：</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/44044100_1623902555.png" referrerpolicy="no-referrer" alt="img"></p><p><span>图14</span></p><p><span>其实及没啥其实就是将任务放入线程持有的队列里，算是一个异步化操作。</span></p><p><span>最后在看一下join方法的执行逻辑，还是一步定位到核心方法上，也就是我们开头看到的doJoin方法，如图15：</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/85410500_1623902555.png" referrerpolicy="no-referrer" alt="img"></p><p><span>图15</span></p><p>&nbsp;</p><p><span>status&lt;0 是方法执行结束的状态码，如果没有结束意味着，我们要尝试进行LFIO的出队操作（tryUnPush），如果出队的操作不是我们期望的那个任务，则要进行等待，也就是发生线程阻塞，我们来看看,代码如下：</span></p><pre spellcheck="false" class="md-fences md-end-block ty-contain-cm modeLoaded" lang=""><div class="CodeMirror cm-s-inner CodeMirror-wrap" lang=""><div style="overflow: hidden; position: relative; width: 3px; height: 0px; top: 0px; left: 8px;"><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0" style="position: absolute; bottom: -1em; padding: 0px; width: 1000px; height: 1em; outline: none;"></textarea></div><div class="CodeMirror-scrollbar-filler" cm-not-content="true"></div><div class="CodeMirror-gutter-filler" cm-not-content="true"></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer" style="margin-left: 0px; margin-bottom: 0px; border-right-width: 0px; padding-right: 0px; padding-bottom: 0px;"><div style="position: relative; top: 0px;"><div class="CodeMirror-lines" role="presentation"><div role="presentation" style="position: relative; outline: none;"><div class="CodeMirror-measure"><pre><span>xxxxxxxxxx</span></pre></div><div class="CodeMirror-measure"></div><div style="position: relative; z-index: 1;"></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline" style="position: relative;"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter" style="left: 0px; width: 0px;"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">final int awaitJoin(WorkQueue w, ForkJoinTask&lt;?&gt; task, long deadline) { &nbsp; &nbsp; &nbsp;  int s = 0; &nbsp; &nbsp; &nbsp;  if (task != null &amp;&amp; w != null) { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ForkJoinTask&lt;?&gt; prevJoin = w.currentJoin; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  U.putOrderedObject(w, QCURRENTJOIN, task); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  CountedCompleter&lt;?&gt; cc = (task instanceof CountedCompleter) ? &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  (CountedCompleter&lt;?&gt;)task : null; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  for (;;) { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  if ((s = task.status) &lt; 0) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  break; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  if (cc != null) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  helpComplete(w, cc, 0); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  else if (w.base == w.top || w.tryRemoveAndExec(task)) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  helpStealer(w, task); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  if ((s = task.status) &lt; 0) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  break; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  long ms, ns; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  if (deadline == 0L) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ms = 0L; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  else if ((ns = deadline - System.nanoTime()) &lt;= 0L) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  break; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  else if ((ms = TimeUnit.NANOSECONDS.toMillis(ns)) &lt;= 0L) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ms = 1L; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  if (tryCompensate(w)) { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  task.internalWait(ms); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  U.getAndAddLong(this, CTL, AC_UNIT); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  } &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  } &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  U.putOrderedObject(w, QCURRENTJOIN, prevJoin); &nbsp; &nbsp; &nbsp;  } &nbsp; &nbsp; &nbsp;  return s; &nbsp;  }</span></pre></div></div></div></div></div></div><div style="position: absolute; height: 0px; width: 1px; border-bottom: 0px solid transparent; top: 345px;"></div><div class="CodeMirror-gutters" style="display: none; height: 345px;"></div></div></div></pre><p>&nbsp;</p><p>&nbsp;</p><p><span>其实上面一大坨方法逻辑，实际上核心的以下几个逻辑 我说明一下</span></p><pre spellcheck="false" class="md-fences md-end-block ty-contain-cm modeLoaded" lang=""><div class="CodeMirror cm-s-inner CodeMirror-wrap" lang=""><div style="overflow: hidden; position: relative; width: 3px; height: 0px; top: 0px; left: 8px;"><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0" style="position: absolute; bottom: -1em; padding: 0px; width: 1000px; height: 1em; outline: none;"></textarea></div><div class="CodeMirror-scrollbar-filler" cm-not-content="true"></div><div class="CodeMirror-gutter-filler" cm-not-content="true"></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer" style="margin-left: 0px; margin-bottom: 0px; border-right-width: 0px; padding-right: 0px; padding-bottom: 0px;"><div style="position: relative; top: 0px;"><div class="CodeMirror-lines" role="presentation"><div role="presentation" style="position: relative; outline: none;"><div class="CodeMirror-measure"><pre><span>xxxxxxxxxx</span></pre></div><div class="CodeMirror-measure"></div><div style="position: relative; z-index: 1;"></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline" style="position: relative;"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter" style="left: 0px; width: 0px;"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">// 在任务明确没有执行完成的情况下，判断队列里是否有该任务，没有说明任务被偷。 &nbsp; &nbsp; &nbsp; if (w.base == w.top || w.tryRemoveAndExec(task))//帮住”窃贼“尽快完成你的任务（一个任务，可能被拆分为多个）helpStealer(w, task);//在阻塞当前线程前,尝试在添加一个线程，确保执行效率的稳定if (tryCompensate(w)) {// 阻塞当前线程 &nbsp; task.internalWait(ms);/ / 阻塞结束  ，修正活跃线程数量 &nbsp; U.getAndAddLong(this, CTL, AC_UNIT);}</span></pre></div></div></div></div></div></div><div style="position: absolute; height: 0px; width: 1px; border-bottom: 0px solid transparent; top: 115px;"></div><div class="CodeMirror-gutters" style="display: none; height: 115px;"></div></div></div></pre><p>&nbsp;</p><p><span>对窃取双端队列的感触</span></p><p>&nbsp;</p><p><span>通过我们的讲解想必大家对ForkJoinPool有一个较为清晰的认知了，它最核心的机制就是提供了窃取功能的双端队列，由于窃取机制的存在，极大的利用了线程资源，不会有空闲的资源存在。并且通过双端队列，出队和入队的实现方式，也避免了锁的争用，并保证了线程安全，而这些丰富的功能，底层的数据结构竟然是一个数组实现的，确实让人眼前一亮。</span></p><p>&nbsp;</p><h3><a name="48图文讲解大白话聊聊pipeline的工作原理和常用架构" class="md-header-anchor"></a><strong><span>48_图文讲解：大白话聊聊pipeline的工作原理和常用架构</span></strong></h3><p><span>这篇文章我们来介绍下pipeline模式。Pipeline，计算机中是流水线的意思。日常生活中流水线是怎么样子的呢，比如在富士康这样的组装工厂，它们的生产线就是一个个的流水线，在一个流水线上有很多个工人，当传送带传过来需要组装的元件，每个工人只需要处理自己负责的一小块事情，比如装个螺丝，贴个标签等等，到流水线的最后，一个组装好的成品，比如手机就组装完成了。</span></p><p>&nbsp;</p><p>&nbsp;</p><p><span>上面的案例，也可以当做一个流水线，数据过来之后，经过过滤、去重、排序、转换等操作，最后再经过收集操作，就完成了对整个数据的处理。</span></p><p><span>拿富士康的例子来看，组装手机就是一个任务，这个任务被分成了若干个处理阶段，也就是流水线上各个不同的任务，每个阶段都有相应的工人去完成相应的任务，这里的工人我们可以理解成我们程序里的工作线程， 这个工人A（线程）会完成他特定的任务，比如说要给手机贴上标签，贴完标签之后，他会把这个贴完标签的手机传给下一个工人B（线程），工人B则开始贴膜，而此时，下一个需要组装的手机，也就是下一个任务就过来了，工人A就会继续给这个手机又贴上标签，工人B再继续贴膜，如此重复作业。</span></p><p>&nbsp;</p><p><span>让我们来画图理解一下这个流程：</span></p><p>&nbsp;</p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/23480300_1623902984.png" referrerpolicy="no-referrer" alt="img"></p><p><span>图1</span></p><p><span>这里，每个需要组装的手机就是一个完整的任务，每个工人是负责执行这个任务某个步骤的工作线程，一个步骤完成之后，再传递给下一个工人，执行下一个步骤，一直到最后，一个任务完成了。虽然这样看来，组装一个手机需要分阶段依次执行，是串行的，但是我们也要看到，工人B在执行手机1的第二个步骤的组装的时候，工人A已经开始组装手机2的第一个步骤，这样在总体上就达到了并行的效果。</span></p><p>&nbsp;</p><p><span>介绍完了pipeline模式的概念，接下来我们来说说它的架构</span></p><p>&nbsp;</p><p><span>其实java里有现成的例子供我们理解，java8提供的stream流其实也实现了流水线，我们来举一个最简单的流水线处理的例子，比如我们要在一批单词中找到首字母为A的单词的最大长度，我们可以这么写：</span></p><p>&nbsp;</p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/52531200_1623902984.png" referrerpolicy="no-referrer" alt="img"></p><p><span>图2</span></p><p><span>我们看到，一批单词，经过中间操作（filter、map、distinct）的处理，最后经过结束操作（max）完成整个流水线，这里所说的中间操作就是还没有完成流水线的操作，每个中间操作都生成一个新的stream流，供下一个阶段使用，结束操作是触发整个流水线运行并得出结果的操作。画图来理解：</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/83006800_1623902984.png" referrerpolicy="no-referrer" alt="img"></p><p><span>图3</span></p><p><span>这里的每个stream对象都是以双向链表的方式连接在一起，每个stage都记录了前一个stage和本次的操作以及回调函数，这样当结束操作触发整个流水线的执行的时候，就能回溯到最初的流，并依次往后执行，完成整个流水线的操作。</span></p><p>&nbsp;</p><p><span>接下来的问题是，一个stage如何开始以及如何结束并开始下个stage的执行，stage之间还需要有相应的联系，这在stream中是通过sink包装stage的操作来实现的，sink包装了当前stage要做的操作以及指定了下一个sink，这样，当一个sink执行完成了，就可以交给下一个sink进行执行了。同样，我们还是画图来理解：</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/7644400_1623902985.png" referrerpolicy="no-referrer" alt="img"></p><p>&nbsp;</p><p><span>图4</span></p><p><span>可以看到，sink包装了stage，在数据处理完成之后，将当前阶段处理完成的数据作为输出交给下一个sink，并触发下一个sink的执行，下一个sink拿到的输入的数据，就是上一个sink的输出。这样一直流转到最后的sinkN，它包装了结束操作，在结束操作里对数据做了最终的处理，得到了最终结果。</span></p><p>&nbsp;</p><p><span>在java的流中，前后stage是串行关系，由单一的线程来执行，为了实现我们前面讲工厂流水线的例子中讲的并行，我们在自己的pipeline的实现中可以将各个stage交给不同的线程来执行，虽然前后stage依然是串行关系，但是前一个stage任务执行完成交给下一个stage后，仍然可以继续执行下一个任务的当前stage的处理。</span></p><p>&nbsp;</p><p><span>同时，对于某个阶段的处理，java的stream也提供了并行化的能力，通过对流调用parallel()使流并行化，一个简单的例子：</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/25372500_1623902985.png" referrerpolicy="no-referrer" alt="img"></p><p><span>图5</span></p><p><span>如代码所示，我们并行将集合中的每个元素加1，并将它们最终收集到一个容器中。</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/46125100_1623902985.png" referrerpolicy="no-referrer" alt="img"></p><p><span>图6</span></p><p><span>这样就通过并行加快了阶段的执行速度/性能。</span></p><p>&nbsp;</p><p><span>通过刚才工厂流水线举例以及对java的stream流的说明，我们对上面提及的阶段、任务、工作线程、输入、输出等等有了基础的认识，在这个基础上，我们就可以构建我们自己的pipeline的架构了。</span></p><p>&nbsp;</p><p><span>首先，在java的stream中，每个阶段都是一个stream，在pipeline中，我们可以将每个阶段抽象成pipe，包含了我们之前提到的sink的功能，也就是，需要接收上个阶段输出作为输入，也需要指定下一个执行阶段，也就是下一个pipe，这样往后流转，一直到最后一个pipe，就完成整个pipeline的任务。</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/76364600_1623902985.png" referrerpolicy="no-referrer" alt="img"></p><p><span>图7</span></p><p><span>其次，前后阶段的pipe虽然是串行的，但是某个阶段自身也是可以并行执行的，就像我们前面说的java stream的并行一样，所以pipeline的模式也因此可以分成两种，分别是线性和非线性的。如下图所示：</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/94091100_1623902985.png" referrerpolicy="no-referrer" alt="img"></p><p><span>图8</span></p><p><span>所以我们对pipe的实现可以有两种，线性和非线性的，对于非线性的pipe，我们需要能够将任务拆分，执行，合并结果的能力，我们可以将非线性的pipe叫做parallelPipe。</span></p><p>&nbsp;</p><p>&nbsp;</p><p><span>接下来，我们还需要有一个pipeline的抽象，它其实就是整个流水线的抽象，可以管理它里面的pipe，比如添加pipe，初始化pipe等。我们添加一些pipe到pipeline中：</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/25178200_1623902986.png" referrerpolicy="no-referrer" alt="img"></p><p><span>图9</span></p><p><span>最后就是pipe的实现，每个pipe都得有自己的执行流程，这还不够，我们还得有方式能够执行每个pipe自己的执行流程。我们前面讲过，对于每个pipe，可以将他们各自的任务交给不同的工作线程来执行，于是我们就可以提供一个包装类，它可以内部托管pipe，并且内部管理有线程池，能为pipe要执行的任务分配工作线程去执行：</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/53584100_1623902986.png" referrerpolicy="no-referrer" alt="img"></p><p><span>图10</span></p><p><span>接下来我们来讲pipeline的实际工作流程。</span></p><p>&nbsp;</p><p><span>首先是初始化，先由client来创建各个pipe以及pipeline：</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/87411400_1623902986.png" referrerpolicy="no-referrer" alt="img"></p><p><span>图11</span></p><p><span>接下来将pipe添加到pipeline：</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/21087200_1623902987.png" referrerpolicy="no-referrer" alt="img"></p><p><span>图12</span></p><p><span>之后由client初始化pipeline，并由pipeline来初始化其管理的pipe：</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/41479700_1623902987.png" referrerpolicy="no-referrer" alt="img"></p><p><span>图13</span></p><p><span>最后pipeline完成初始化并返回：</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/68787900_1623902987.png" referrerpolicy="no-referrer" alt="img"></p><p><span>图14</span></p><p><span>以上就是pipeline的初始化过程，由client创建pipeline和pipe，将pipe添加到pipeline，再由client触发pipeline的初始化，pipeline会负责初始化各个pipe。</span></p><p>&nbsp;</p><p><span>初始化完成之后，需要完成pipe自身任务的执行，这是整个pipeline模式的关键，这里就需要WorkThreadPipeDecorator出场，交付工作线程进行任务的执行， 同样我们通过画图来理解。</span></p><p>&nbsp;</p><p><span>首先，client向pipeline提交任务，通过process方法来传递初始输入：</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/89741100_1623902987.png" referrerpolicy="no-referrer" alt="img"></p><p><span>图15</span></p><p><span>接下来，pipeline调用它所管理的Pipe中的第一个pipe实例的process方法进行执行，因为pipe是一种抽象，这里的pipe实例实际上是我们前面提到的pipe的实现WorkThreadPipeDecorator：</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/12156300_1623902988.png" referrerpolicy="no-referrer" alt="img"></p><p><span>图16</span></p><p><span>提交任务之后，pipe1的workThreadPipeDecorator实例内部会分配工作线程去执行任务，对于提交任务的pipeline而言，就算是直接返回了，对client而言也是如此。此时，process方法返回：</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/27377200_1623902988.png" referrerpolicy="no-referrer" alt="img"></p><p><span>图17</span></p><p><span>接下来就是workThreadPipeDecorator分配工作线程去执行任务，我们前面提到，workThreadPipeDecorator实际上是个包装类，它托管了pipe，并且会通过线程池分配线程去执行pipe的任务，也就是执行pipe的doProcess()方法，对输入进行处理。</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/42017200_1623902988.png" referrerpolicy="no-referrer" alt="img"></p><p>&nbsp;</p><p><span>图18</span></p><p><span>到这里pipe1的执行有结果了，然后，接下来还会有后续的pipe需要执行，之前在讲stream的时候提到，sink包装了stage，前一个sink执行完成之后，能够触发下一个sink的执行，在pipeline里也是一样，当前pipe是知道下一个pipe的，当pipe自身执行完成之后，就可以拿到下一个pipe就行后续流的处理了，这里会将pipe1的输出outA作为输入传给pipe2：</span></p><p>&nbsp;</p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/57709800_1623902988.png" referrerpolicy="no-referrer" alt="img"></p><p>&nbsp;</p><p><span>图19</span></p><p><span>pipe2的执行其实和pipe1类似，同样是包装类开启工作线程进行处理，执行doProcess方法，并得到最终的结果，后续就不再赘述。</span></p><p>&nbsp;</p><p><span>如果这个pipeline一共有两个pipe，当pipe2也执行完成，整个计算就结束了，直接返回：</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/76356100_1623902988.png" referrerpolicy="no-referrer" alt="img"></p><p><span>图20</span></p><p><span>以上就是对整个pipeline模式的介绍和流程梳理，感谢阅读。</span></p><p>&nbsp;</p><h3><a name="49案例实战在电商平台页面静态化系统中实现上传静态化页面到nginx一）" class="md-header-anchor"></a><strong><span>49_案例实战：在电商平台页面静态化系统中实现上传静态化页面到nginx（一）</span></strong></h3><h4><a name="1案例分析" class="md-header-anchor"></a><span>1、案例分析</span></h4><p>&nbsp;</p><p><span>前面我们讲了pipeline模式的一些基本概念，以及基本的执行逻辑，要想真正理解和使用pipeline，必然不能仅仅停留在概念上，还需要动手实战，接下来我们以一个电商平台项目作为我们的实战案例进行学习，在电商平台页面静态化系统上传静态化页面到nginx中。</span></p><p><span>从生成静态化页面到上传nginx，需要经过多个阶段，比如从数据库中查询要生成的静态化页面数据，写入文件，文件写满后上传nginx，这里就可以使用pipeline模式。在前一篇文章中，对涉及pipeline模式的源码没有做介绍，本讲在实现具体逻辑之前，先对pipeline的完整实现做一个介绍。</span></p><p>&nbsp;</p><p>&nbsp;</p><h4><a name="2pipeline核心流程介绍" class="md-header-anchor"></a><span>2、pipeline核心流程介绍</span></h4><p><span>前面我们提到两个核心的抽象，pipe和pipeline，pipe代表流水线中的一个阶段，pipeline代表整个流水线的集合，内部管理着组成流水线的各个pipe。首先我们定义pipe接口的内容，它需要这样几个功能，包括pipe自身的初始化、pipe所代表的阶段需要对输入的数据进行处理的逻辑、停止对外服务时要做的操作、以及使流水线正常流转下去所需要的指定下一个pipe。当然pipe在执行的过程中也会有失败的情况，我们用一个上下文对象来处理pipe执行失败的情况，这个上下文我们称之为PipeContext，在pipe执行初始化的时候与pipe关联起来。</span></p><p><span>具体的pipe定义如下：</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/91861200_1626664063.png" referrerpolicy="no-referrer" alt="img"></p><p><span>图一</span></p><p>&nbsp;</p><p><span>其中PipeContext定义如下：</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/25962100_1626664064.png" referrerpolicy="no-referrer" alt="img"></p><p><span>图二</span></p><p><span>用类图表示如图3：</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/54312800_1626664064.png" referrerpolicy="no-referrer" alt="img"></p><p><span>图三</span></p><p>&nbsp;</p><p>&nbsp;</p><p><span>接下来我们定义Pipeline的接口，它可以作为一个特殊的pipe，除了pipe本身的功能之外，它还具备管理组成pipeline的各个pipe的功能，所以它继承Pipe接口，并具有向pipeline添加pipe的能力，定义如图4：</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/81109700_1626664064.png" referrerpolicy="no-referrer" alt="img"></p><p><span>图四</span></p><p><span>用类图表示就是：</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/10274000_1626664065.png" referrerpolicy="no-referrer" alt="img"></p><p><span>图五</span></p><p><span>接下来考虑Pipe的实现，图四中表示的Pipe接口的四个方法，前三个，初始化、关闭、设置下个pipe，可以认为是通用操作，大多数情况下不需要每个接口实现类都自己去定制，变化的地方主要在pipe的process方法，这里需要pipe自己定义需要执行的操作。</span></p><p>&nbsp;</p><p><span>我们这里可以定义一个抽象类实现Pipe接口，将可复用的内容放到这个抽象类中，这样子类就只需要专心于自己的业务逻辑即可，这个抽象类提供doProcess方法供子类去实现自己的数据处理逻辑，抽象类会将处理的结果作为下一个pipe实例的输入。我们将这个抽象类的名字定义成AbstractPipe，具体定义如下：</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/44797500_1626664065.png" referrerpolicy="no-referrer" alt="img"></p><p><span>图六</span></p><p><span>整体类图如下：</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/83955400_1626664065.png" referrerpolicy="no-referrer" alt="img"></p><p><span>图七</span></p><p><span>上面的AbstractPipe仅用来处理线性的pipeline，还有一种非线性的pipeline，也就是某个阶段的pipe可以并行处理任务，我们同样提供一个支持并行处理的抽象Pipe，它除了拥有AbstractPipe提供的功能之外，还需要有对输入的数据分片、并行执行任务、以及最后将结果合并的能力，因此这个并行的pipe继承自AbstractPipe，并额外有三个方法供子类实现：</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/31373000_1626664066.png" referrerpolicy="no-referrer" alt="img"></p><p><span>图八</span></p><p><span>类图表示如下：</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/68567900_1626664066.png" referrerpolicy="no-referrer" alt="img"></p><p><span>图九</span></p><p>&nbsp;</p><p><span>现有的接口和类构成了pipeline模式的基础架构，接下来就需要考虑实际的实现，Pipe本身只是接口，要执行自己的任务，需要有具体的线程去执行，分配线程有两种方式，一种就是构建一个线程池，由线程池中的线程负责具体任务的执行，另外一种我们可以基于工作者线程，将任务提交到队列中，指派相应工作者线程进行处理。这两种实现，可以基于装饰器模式，将Pipe托管于具体的线程实现。</span></p><p>&nbsp;</p><p><span>首先是基于线程池的Pipe实现，它需要依赖Pipe以及线程池，既然使用到了线程池，那么在进行任务执行和关闭的时候，还需要对线程池的状态进行管理，比如在执行数据处理的时候判断是否当前线程已经被标记为关闭，并且没有待执行的任务。</span></p><p><span>在关闭pipe的时候也同样要对当前的线程池状态进行判断，是否仍然有未完成的任务，如果有的话就等待一定时间，待任务完成或者达到超时时间再进行关闭，实现这些功能需要有一个标记来记录当前线程池的状态，包括记录当前线程池未执行的任务数量，以及是否关闭的一个标志位。所以基础的标记类的实现应该是这样的，有一个volatile修饰的标记位，以及一个原子Integer来记录未执行的任务数量：</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/1613800_1626664067.png" referrerpolicy="no-referrer" alt="img"></p><p><span>线程池的pipe实现可以更具体化的定制自己的标记类，同一个线程池共用一个标记类，提供修改标记位的方法。这个定制化的标记类只在线程池Pipe实现中使用，因此可以作为该实现的内部类使用：</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/40696700_1626664067.png" referrerpolicy="no-referrer" alt="img"></p><p><span>准备工作完成之后，我们就可以真正实现基于线程池的Pipe实现类ThreadPoolPipeDecorator，先用类图表示：</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/73490000_1626664067.png" referrerpolicy="no-referrer" alt="img"></p><p><span>现在要实现Pipe接口的四个方法，init和setNextPipe比较简单，一句代码搞定，重点是process和shutdown方法，这里要涉及到具体的线程池的使用了，我们来看代码：</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/10347300_1626664068.png" referrerpolicy="no-referrer" alt="img"></p><p><span>下面是shutdown方法的实现：</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/50903500_1626664068.png" referrerpolicy="no-referrer" alt="img"></p><p><span>最后是另外两个比较简单的方法的实现：</span></p><p><span>init</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/46565500_1626664069.png" referrerpolicy="no-referrer" alt="img"></p><p><span>setNextPipe</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/72906700_1626664069.png" referrerpolicy="no-referrer" alt="img"></p><p><span>以上就是基于线程池的Pipe实现了。接下来我们要完成基于工作者线程的pipe实现。同ThreadPoolPipeDecorator一样，WorkerThreadPipeDecorator也是托管了pipe，并指派相应的工作者线程完成pipe自身任务的处理，不同的地方在于，任务不是提交到线程池，而是交给工作者线程去处理。这里的工作者线程，需要我们自己去管理，它的创建、执行、结束，都得有相应的机制来保证。</span></p><p>&nbsp;</p><p><span>既然是自己管理的工作者线程，而且要让这个工作者线程完成相应的任务处理、线程停止等操作，就不方便直接使用原生的Thread，原生的Thread并不能满足我们对线程管理的需求，需要在Thread基础上进行定制化处理，封装线程的初始化、执行、结束的相关操作，并且对于线程要做的具体任务，要留给子类去实现。</span></p><p><span>基于上述原因，我们定义一个抽象类AbstractTerminationThread代表工作者线程，它继承自Thread，重写Thread的run方法，封装对线程执行的通用操作。</span></p><p>&nbsp;</p><p><span>但这还不够，重写run方法仅仅封装了线程的执行，对于线程结束的操作，我们也需要在这个类里进行处理，因此这里我们定义一个Termination的接口，它只有一个方法就是terminate()，代表对线程的结束操作，AbstractTerminationThread实现了Termination接口，实现terminate方法，封装线程结束的相关操作。</span></p><p><span>同之前的ThreadPoolPipeDecorator类中线程的停止操作类似，工作者线程的结束也是需要有标记来记录当前工作的状态，在还有任务执行的情况下等待，在任务都执行完成的情况下进行线程的停止，所以AbstractTerminationThread还需要关联线程停止的标记，我们在前面提到的TerminationToken类的基础上进一步的完善适配于工作者线程的标记实现，并将它在AbstractTerminationThread初始化的时候与之关联在一起，这可以通过构造器传入或者创建。</span></p><p>&nbsp;</p><p><span>如此我们对于工作者线程的设计趋于完善，下面用类图来做一个整体的概览，之后再看代码做进一步的细节梳理。</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/10675600_1626664070.png" referrerpolicy="no-referrer" alt="img"></p><p>&nbsp;</p><p><span>首先来看Termination接口的定义：</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/45285600_1626664070.png" referrerpolicy="no-referrer" alt="img"></p><p>&nbsp;</p><p><span>唯一的方法就是terminate，用来请求终止线程，这个方法会由AbstractTerminationThread来实现。</span></p><p><span>AbstractTerminationThread继承了Thread，同时实现了Termination接口，它的属性只有一个TerminationToken标记，这个标记在AbstractTerminationThread创建时在构造器中传入或者创建：</span></p><p>&nbsp;</p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/75700700_1626664070.png" referrerpolicy="no-referrer" alt="img"></p><p><span>标记实例会将当前线程注册到标记内部的队列中，用于在后续进行统一的线程停止：</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/7394300_1626664071.png" referrerpolicy="no-referrer" alt="img"></p><p><span>标记类的register方法就是将线程加入上面这个队列中：</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/36031900_1626664071.png" referrerpolicy="no-referrer" alt="img"></p><p><span>AbstractTerminationThread的terminate方法实现：</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/63830800_1626664071.png" referrerpolicy="no-referrer" alt="img"></p><p><span>接下来是AbstractTerminationThread重写的run方法，封装了线程执行任务的一些通用操作：</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/97284300_1626664071.png" referrerpolicy="no-referrer" alt="img"></p><p><span>上面提到的通知别的线程终止的notifyThreadTermination方法的实现：</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/31736800_1626664072.png" referrerpolicy="no-referrer" alt="img"></p><p><span>上面就是工作者线程的完整实现了，现在有了工作者线程，我们终于可以进行基于工作者线程的Pipe实现了，我们定义类WorkerThreadPipeDecorator来负责这一实现。首先，这个类也是实现了Pipe接口，Pipe接口的四个方法它要一一实现；其次，它的内部同样托管了Pipe，而且内部管理着我们前面定义好的工作者线程集合，来负责具体的任务执行；</span></p><p><span>另外，跟ThreadPoolPipeDecorator一样，它的内部也需要有一个线程停止的标记用来在线程停止的时候判断状态；最后，如何分配线程去执行具体任务，我们通过一个阻塞队列来完成，队列中的元素是要处理的输入数据，由工作者线程从阻塞队列中取出数据进行处理。阻塞队列的特性就是队列为空时线程阻塞，有数据时解除阻塞进行处理，这样就能够完成任务的分配了。我们画出它的类图来理解：</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/62506800_1626664072.png" referrerpolicy="no-referrer" alt="img"></p><p><span>下面来看具体的代码实现，首先是它的几个内部属性，也就是我们前面所说的托管Pipe、线程集合、任务队列以及线程停止标记：</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/95235600_1626664072.png" referrerpolicy="no-referrer" alt="img"></p><p><span>接下来是创建具体的工作者线程，在构造器中，传入任务队列、Pipe，指定需要有几个工作线程，根据数量进行创建：</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/29867200_1626664073.png" referrerpolicy="no-referrer" alt="img"></p><p><span>dispatch方法的实现如下，就是从工作队列中取出输入进行处理：</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/68838500_1626664073.png" referrerpolicy="no-referrer" alt="img"></p><p><span>这样构造器中就完成了工作线程的创建，接下来就是Pipe接口的几个方法实现了，首先init方法用来启动线程：</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/95730300_1626664073.png" referrerpolicy="no-referrer" alt="img"></p><p><span>process方法，将输入加入到工作队列中，并将标记的未完成任务数加一， 上面的init方法的线程已经启动了，而启动后的线程是从阻塞队列中取数据的，这里将输入数据加入到阻塞队列中之后，线程就从阻塞状态解除，拿出数据进行处理：</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/25681500_1626664074.png" referrerpolicy="no-referrer" alt="img"></p><p><span>接下来是shutdown方法，调用thread的terminate方法，之前讲工作者线程的实现的时候有terminate方法的具体实现，其实就是将线程标记为停止，如果当前没有未完成任务，就唤醒线程，最后给出一定时间完成pipe的结束逻辑：</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/54223700_1626664074.png" referrerpolicy="no-referrer" alt="img"></p><p><span>最后一个方法就是setNextPipe方法，它的实现跟之前一样：</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/82450500_1626664074.png" referrerpolicy="no-referrer" alt="img"></p><p><span>现在，我们已经把两种线程的Pipe实现完成了，还有最后一个需要实现的内容，就是对Pipeline接口的实现，这里我们就给出一个简单实现即可，它主要是实现addPipe方法，将我们前面实现的两种Pipe实现加入到Pipeline管理的Pipe队列中：</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/15476800_1626664075.png" referrerpolicy="no-referrer" alt="img"></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/52250800_1626664075.png" referrerpolicy="no-referrer" alt="img"></p><p><span>并完成Pipe的初始化工作：</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/94191900_1626664075.png" referrerpolicy="no-referrer" alt="img"></p><p><span>Pipe初始化任务定义如下：</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/36371000_1626664076.png" referrerpolicy="no-referrer" alt="img"></p><p><span>最后还要完成pipe的结束操作：</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/67326100_1626664076.png" referrerpolicy="no-referrer" alt="img"></p><p><span>process方法什么也不做就行，因为具体的任务是由Pipe执行的：</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/1436300_1626664077.png" referrerpolicy="no-referrer" alt="img"></p><p>&nbsp;</p><h4><a name="-n3150" class="md-header-anchor"></a><span> </span></h4><h4><a name="3总结" class="md-header-anchor"></a><span>3、总结 </span></h4><p><span>以上就是整个pipeline模式的架构和代码实现了，我们用一个完整的类图来表示：</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/50244100_1626664077.png" referrerpolicy="no-referrer" alt="img"></p><p><span>下一讲，我们来实现具体的案例代码。</span></p><p>&nbsp;</p><h3><a name="50案例实战在电商平台页面静态化系统中实现上传静态化页面到nginx二）" class="md-header-anchor"></a><strong><span>50_案例实战：在电商平台页面静态化系统中实现上传静态化页面到nginx（二）</span></strong></h3><p><span>上一讲，我们完成了pipeline模式的整体架构和代码实现，之后我们就可以用pipeline的实现进行案例实战了，这一讲，我们就来对pipeline模式进行应用，完成我们前面讲到的项目，模拟电商平台页面静态化系统上传静态化页面到nginx中。</span></p><p><span>从实战项目的描述中我们可以直观的看到，完成整个上传任务需要两个阶段，第一个阶段要从数据库中获取到商品信息，根据模板和数据，将获取到的商品信息依据模板生成静态化页面；第二个阶段自然是要将生成好的静态化页面上传到nginx，这里考虑到我们要上传的静态化页面有可能需要上传到多台nginx服务器，就可以考虑使用我们之前提到的可并行的pipe，也就是前一讲中实现的AbstractParallelPipe。</span></p><p><span>当然实际上我们这个阶段的区分是比较粗略的，比如第一个阶段根据商品数据生成静态化页面，严格区分的话，从数据库中获取商品数据也可以是一个阶段，之后的获取到数据并生成静态化页面可以是下一个阶段，还有我们上面讲到的上传到多台nginx的第二个阶段，在这之后也可以有一个专门阶段进行上传完成后的备份等，这样总共可以扩展出四个阶段甚至更多，有兴趣的同学可以在我们的两阶段划分的基础上进行拓展。</span></p><p><span>接下来我们先以一个简单的图示来明确我们的任务：</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/82571200_1626665757.png" referrerpolicy="no-referrer" alt="img"></p><p>&nbsp;</p><p><span>把上图转换成我们pipeline模式的表达，两个stage在pipeline模式中就是两个pipe，这两个pipe都应该被pipeline所管理，同时还有PipeContext进行异常处理，画图表示如下：</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/6757500_1626665758.png" referrerpolicy="no-referrer" alt="img"></p><p><span>更细化一些，每个pipe都要有工作线程进行执行，所以pipe要托管给工作线程的包装类，这里我们选用上一讲所实现的WorkerThreadPipeDecor来进行包装，如下图所示：</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/30246300_1626665758.png" referrerpolicy="no-referrer" alt="img"></p><p><span>那么接下来我们就要把上图中的所有元素组装起来，通过代码实现，我们先考虑大体的实现步骤：</span></p><p>&nbsp;</p><p><span>pipeline作为最外层的组件，我们需要首先构建出来，在构建中就需要把两个阶段的pipe纳入到pipeline的管理中，这两个阶段的pipe我们当然是通过WorkerThreadPipeDecorator来托管，并加入到pipeline中。</span></p><p>&nbsp;</p><p><span>接下来就是对pipeline以及其管理的pipe进行初始化，初始化的过程中，就可以将PipeContext与pipeline管理的pipe关联起来，实现对pipe执行出现异常时的处理。同时，还要将加入pipeline的pipe彼此之间按先后顺序关联起来，这样前一个pipe执行完成之后就会执行关联的下一个pipe。</span></p><p><span>完成了初始化工作之后，自然就是执行pipeline，也就是两个pipe依次执行。</span></p><p><span>最后，完成任务之后，结束整个pipeline。</span></p><p><span>流程如下图所示：</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/48806900_1626665758.png" referrerpolicy="no-referrer" alt="img"></p><p>&nbsp;</p><p><span>我们用类CommodityDetailSyncTask来表示上述整个流程，让类实现Runnable接口，重写run方法，将上述的整体流程放到run方法中：</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/84557200_1626665758.png" referrerpolicy="no-referrer" alt="img"></p><p>&nbsp;</p><p><span>让我们开始第一步的buildPipeline，这个方法中，我们要创建出pipeline实例，构建出两个Pipe实例，这两个pipe实例，我们可以基于之前实现的AbstractPipe和AbstractParallelPipe来分别构建，因为阶段一是单线程的；</span></p><p><span>而阶段二由于可能上传到多台服务器，所以使用支持并行的AbstractParallelPipe。这里更加关键的一点是，两个抽象类都提供了抽象方法来供子类实现自己的数据处理逻辑，在这里，我们就要实现我们自己的生成静态文件和上传nginx的实际逻辑了。接下来将生成好的两个pipe，以工作线程包装的形式加入到pipeline中（通过Pipeline的addAsWorkerThreadBasedPipe方法），就完成了构建pipeline的任务了。</span></p><p><span>语言不够直观，我们来看实际代码：</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/13868300_1626665759.png" referrerpolicy="no-referrer" alt="img"></p><p><span>上面的代码中，两个生成pipe的方法，需要完成我们本项目的业务逻辑，也就是依据商品数据生成静态页面，以及实现文件上传，我们先来看第一个生成静态化页面的实现。</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/60961400_1626665759.png" referrerpolicy="no-referrer" alt="img"></p><p><span>上述代码中，使用匿名内部类的方式，重写AbstractPipe的doProcess方法，进行实际的业务处理，其输入是一个CommodityInfoTask对象，携带了要生成静态化页面的商品信息以及要生成的文件的名称，我们来看它的类实现：</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/84143800_1626665759.png" referrerpolicy="no-referrer" alt="img"></p><p><span>第一个属性是CommodityInfo类型，封装了我们从数据库中获取到的商品信息，其字段如下：</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/15221000_1626665760.png" referrerpolicy="no-referrer" alt="img"></p><p><span>第二个属性是要生成的文件的名称，这里不再赘述。</span></p><p><span>回到doProcess方法的实现，通过上面的输入数据，我们要根据模板生成静态化页面文件，这里用CommodityDetailTemplate代表静态化模板，使用单例模式获取其实例，从输入数据中取出商品信息，传入CommodityDetailTemplate的generate方法进行静态化页面数据的生成，这里我们简单的创建一个文件来代表生成的静态化页面。</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/59678800_1626665760.png" referrerpolicy="no-referrer" alt="img"></p><p>&nbsp;</p><p><span>最后生成的这个文件file对象就是这个任务的输出了，如此就完成了阶段一的执行，输出的file将作为阶段二的输入供后续的处理。</span></p><p><span>接下来我们来看阶段二的pipe实现，这里跟阶段一不同的是我们使用了AbstractParallelPipe的抽象类，回顾AbstractParallelPipe的使用，它继承了AbstractPipe，同时提供了额外的三个方法需要实现，分别是任务的分片、执行、合并，因此这里我们也要结合我们上传nginx的任务一一实现这三个方法以及初始化和结束的方法。</span></p><p><span>要实现文件上传，我们需要有一套文件上传的组件，首先定义一个基本的文件上传的接口，对于文件上传，我们需要初始化，也就是传入服务器地址、用户名密码、上传地址等信息，连接服务器这些操作，然后是核心的上传操作，以及最后上传完成之后中断连接。接口定义如下：</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/86559800_1626665760.png" referrerpolicy="no-referrer" alt="img"></p><p><span>我们进行一个模拟的实现：</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/21701600_1626665761.png" referrerpolicy="no-referrer" alt="img"></p><p>&nbsp;</p><p><span>上传文件是一个耗时操作，我们采用前面讲过的承诺模式进行处理，承诺模式就是先获取拿结果的凭据，待任务执行完成之后，再通过凭据拿到最后的结果。</span></p><p><span>我们定义一个FtpUploaderPromisor来获取连接nginx任务的promise凭据：</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/54840000_1626665761.png" referrerpolicy="no-referrer" alt="img"></p><p>&nbsp;</p><p><span>有了连接上nginx的客户端，就可以进行文件的上传了，同样我们封装一个文件上传的task来完成文件上传的工作，这里就会从刚刚的凭据对象里取得连接上nginx的客户端，进行文件的上传。</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/82062400_1626665761.png" referrerpolicy="no-referrer" alt="img"></p><p>&nbsp;</p><p><span>这样，文件上传的组件以及通过承诺模式完成的文件上传的任务封装完成，我们就可以去实现AbstractParallelPipe的几个方法，实现真正的文件上传了。我们来看完整代码：</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/20084700_1626665762.png" referrerpolicy="no-referrer" alt="img"></p><p>&nbsp;</p><p><span>还有一个小问题，代码里似乎没有重写执行分片任务的方法，只有构建任务和合并任务，实际上是AbstractParallelPipe已经实现好了invokeParallel方法，其实就是将上面构建好的分片任务提交到线程池而已：</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/11619800_1626665763.png" referrerpolicy="no-referrer" alt="img"></p><p>&nbsp;</p><p><span>这样，阶段二的Pipe也已经构建好了，将它们都加入到pipeline中，就完成了我们的第一大步，也就是创建pipeline，构建两个阶段的pipe，并加入到pipeline。接下来就是要执行第二步初始化了。</span></p><p>&nbsp;</p><p><span>初始化里，需要关联PipeContext，并将加入到pipeline的pipe按顺序建立先后顺序，能让各个阶段相继执行。</span></p><p>&nbsp;</p><p><span>我们来看Pipeline的init方法：</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/50684600_1626665763.png" referrerpolicy="no-referrer" alt="img"></p><p><span>在实际的实现中，这里PipeContext传入的是pipeline构建的默认PipeContext：</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/70232400_1626665763.png" referrerpolicy="no-referrer" alt="img"></p><p>&nbsp;</p><p><span>这个默认的PipeContext，实际上只做了一件事就是，将pipe在执行过程中出现的异常捕获之后放到线程池进行处理，这里的处理操作我们仅仅是打印出来，实际的使用中可以按照需求自行处理：</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/93077100_1626665763.png" referrerpolicy="no-referrer" alt="img"></p><p>&nbsp;</p><p><span>封装的初始化任务的实现如下：</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/19051500_1626665764.png" referrerpolicy="no-referrer" alt="img"></p><p><span>回顾下WorkerThreadPipeDecorator的init方法实现，在这里完成了它所管理的工作线程的启动：</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/44019600_1626665764.png" referrerpolicy="no-referrer" alt="img"></p><p>&nbsp;</p><p><span>上面就是第二步初始化的完整实现了，实际上到了这一步，要完成整个文件上传任务所需要的准备已经完成了，接下来就是实际的执行了，也就是我们第三步要做的事情。</span></p><p>&nbsp;</p><p><span>首先，我们需要有商品数据作为整个pipeline的输入，这里我们模拟从db获取商品数据：</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/79126000_1626665764.png" referrerpolicy="no-referrer" alt="img"></p><p>&nbsp;</p><p><span>有了生成商品数据的db类，我们就可以执行我们的pipeline了，这通过processCommodityInfos方法，传入db类以及pipeline，进行真正的pipeline的执行，我们来看方法实现：</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/4619900_1626665765.png" referrerpolicy="no-referrer" alt="img"></p><p><span>调用了pipeline的process方法之后，pipeline就开始执行生成文件以及文件上传的任务了，那么真正的执行流程是怎么样的呢，在pipeline的process方法中，会先从它所管理的pipe的队列中拿出第一个pipe进行执行：</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/28605900_1626665765.png" referrerpolicy="no-referrer" alt="img"></p><p>&nbsp;</p><p><span>这里的firstPipe实际上是WorkerThreadPipeDecorator的实例，因此会执行这个包装类实例的process方法，这个方法中，会将input放到它的任务队列中：</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/49817900_1626665765.png" referrerpolicy="no-referrer" alt="img"></p><p>&nbsp;</p><p><span>而它所管理的线程会从任务队列中取出input，交给由它托管的Pipe进行真正的任务执行：</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/74001900_1626665765.png" referrerpolicy="no-referrer" alt="img"></p><p>&nbsp;</p><p><span>这个托管的pipe，我们在实现阶段一的pipe的时候，是通过AbstractPipe来实现的，我们重写了AbstractPipe的doProcess方法，此时我们回到AbstractPipe的process的实现：</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/25327300_1626665766.png" referrerpolicy="no-referrer" alt="img"></p><p><span>可以看到，我们重写了的doProcess方法终于被执行，此时阶段一的生成静态化文件就执行完成了，这个时候流水线的下一个pipe会在这里拿到前一个pipe的输出作为输入，继续执行后续的任务，这样，下一个阶段的pipe，也就是上传文件到nginx的任务就会得到执行。</span></p><p>&nbsp;</p><p><span>到这里，我们所模拟的整个实现电商平台页面静态化系统上传静态化页面到nginx中的任务就执行完成了，当他们执行完成之后，我们的整个流程也就走到了最后一步，就是在执行完成之后进行pipeline的关闭，也就是这行代码：</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/59154400_1626665766.png" referrerpolicy="no-referrer" alt="img"></p><p>&nbsp;</p><p><span>这里我们传入超时的时间，以防在执行关闭的时候，还有未执行完成的任务，如果有的话，就等待任务执行完成或者到达超时时间。</span></p><p>&nbsp;</p><p><span>我们来看shutdown方法的实现：</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/91065300_1626665766.png" referrerpolicy="no-referrer" alt="img"></p><p><span>做了两个事情，从pipeline所管理的pipe的队列中取出每个pipe，分别执行他们的shutdown方法，最后，关闭线程池。</span></p><p>&nbsp;</p><p><span>到这里，整个pipeline模式就讲解完毕了，我们讲了pipeline模式的概念、实现以及最后的应用，在后面遇到类似多阶段任务的时候，就可以应用pipeline模式进行处理了。</span></p><p>&nbsp;</p><h3><a name="51品味经典一起来看看知名网络框架netty的pipeline是如何设计的" class="md-header-anchor"></a><strong><span>51_品味经典：一起来看看知名网络框架netty的pipeline是如何设计的？</span></strong></h3><p><span>学完了pipeline模式的设计与实现，接下来我们来看看业界对pipeline模式的使用，Netty作为一个广泛使用的网络框架，其在channel的处理上也使用了pipeline模式。</span></p><p>&nbsp;</p><p><span>channel是NIO编程的一个核心概念，意为通道，Netty里的channel，封装了用户的通讯连接，我们正常的网络连接，会触发这么几种事情，比如建立连接，可读，可写等，所以这里的channel也会有这些事件触发。</span></p><p>&nbsp;</p><p><span>事件触发后，就需要有人来发现这些事件，那么谁来发现呢，这里就引出来另外一个组件，也就是事件循环，channel其实是注册到事件循环的，事件循环会不断的轮循各个channel，看看是不是有事件触发了，如果某个channel触发了某种事件，比如某个channel此时已经读就绪了，这时候事件循环发现了这个事情，接下来，就要处理这个读事件，读取channel里的数据进行处理。</span></p><p>&nbsp;</p><p><span>谁来处理这个事件呢，这里又出现了另外一个组件，也就是handler，当事件循环查询到了NIO就绪的事件后，就会分发到handler，由handler完成NIO操作和计算操作。说的直白一点就是，当Channel读就绪时，Hander就开始读；Channel写就绪时，Hander就开始写。先用一个简单的图来理解各个组件的位置：</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/53746900_1626673426.png" referrerpolicy="no-referrer" alt="img"></p><p><span>上图中，EventLoop会不断轮循查询注册到它身上的Channel的NIO事件，当某个NIO事件就绪后，EventLoop就会分发给相应的handler进行处理。我们要说的pipeline模式在Netty的使用，其实就是在handler处理就绪事件的时候应用的。</span></p><p>&nbsp;</p><p><span>那么，什么地方用了pipeline呢，上图中的handler画的比较简略，实际上，handler处理NIO事件要经过一系列的操作，比如Channel缓存读、数据解码、业务处理、写Channel缓存，然后由Channel（代表client）发送到最终的连接终端，我们来细化一下图：</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/78322600_1626673426.png" referrerpolicy="no-referrer" alt="img"></p><p><span>有没有发现，原来handler位置的图经过细化后，跟我们之前讲的pipeline的图比较类似，都是一个管道，包含了多个处理阶段，正如我们所见的，其实包裹一个个处理阶段的就是Netty中的ChannelPipeline, 而这一个个处理阶段，其实就是一个个NettyHandler，和我们之前讲pipeline模式时所讲到的Pipe类似。</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/5766400_1626673427.png" referrerpolicy="no-referrer" alt="img"></p><p><span>上图中我们看到对于事件的处理有很多个handler，要想管理这么多纷繁复杂的handler，就需要靠ChannelPipeline来组织和管理了。</span></p><p>&nbsp;</p><p><span>那么接下来我们就来看看pipeline的创建以及对其中的handler的管理。首先，对于Netty中pipeline的创建，由于pipeline主要是处理NettyChannel的一些列事件的，所以pipeline本身是跟NettyChannel关联在一起的，每个NettyChannel都有一个ChannelPipeline，在NettyChannel创建的时候也会创建默认的ChannelPipeline，并与NettyChannel关联在一起，源码如下：</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/41052100_1626673427.png" referrerpolicy="no-referrer" alt="img"></p><p>&nbsp;</p><p><span>可见，在Channel创建的构造器中就直接创建了一个ChannelPipeline，接下来，我们来看看创建这个pipeline的具体内容，它的结构如何，源码中跟进去看看：</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/67485300_1626673427.png" referrerpolicy="no-referrer" alt="img"></p><p>&nbsp;</p><p><span>这里调用了DefaultChannelPipeline的构造器，并将当前NettyChannel实例传进去，接下来进入到DefaultChannelPipeline的构造器中看看：</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/91784400_1626673427.png" referrerpolicy="no-referrer" alt="img"></p><p>&nbsp;</p><p><span>在DefaultChannelPipeline 构造器中， 首先将与之关联的Channel 保存到字段channel 中。然后实例化两个ChannelHandlerContext：一个是HeadContext 实例head，另一个是TailContext 实例tail。接着将head 和tail 互相指向， 构成一个双向链表。</span></p><p>&nbsp;</p><p><span>到这里可能会有人问了，不是说pipeline管理了handler吗，为什么这里只看到了两个context，而没有看到handler的踪迹，这是因为HeadContext 和TailContext继承于AbstractChannelHandlerContext 的同时也实现了ChannelHandler 接口，因此它们有Context 和Handler的双重属性。</span></p><p>&nbsp;</p><p><span>除了head和tail这两个特殊的context，其他handler会以另一种形式的context加入，我们后续会讲到。</span></p><p>&nbsp;</p><p><span>现在我们知道了pipeline和channel的关系以及pipeline中handler的结构，我们用图来说明：</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/16385000_1626673428.png" referrerpolicy="no-referrer" alt="img"></p><p>&nbsp;</p><p><span>以上仅仅是创建channel时的默认结构，在没有加入业务handler之前，pipeline基本上做不了什么事情，也就是说pipeline管理的handler必然不能仅仅有一个head和tail，还得有别的业务handler加入才能真正的执行任务。新加入的业务handler会添加在tail的前一个位置，它的类型就不是HeadContext或者TailContext了，而是一个上下文对象DefaultChannelHandlerContext，内部包裹了一个ChannelHandler：</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/39663300_1626673428.png" referrerpolicy="no-referrer" alt="img"></p><p>&nbsp;</p><p><span>注意，这个类和HeadContext与TailContext一样，也是继承了AbstractChannelHandlerContext，这个抽象类实现了ChannelHandlerContext接口，所以HeadContext和TailContext以及DefaultChannelHandlerContext他们的顶层接口都是ChannelHandlerContext。</span></p><p>&nbsp;</p><p><span>之所以pipeline管理的handler都是这样的上下文对象，是因为handler本身是不关联任何channel的，它只负责完成自己的任务，而它们跟channel的联系，也就靠context来完成了，在构造器中会传入pipeline，而pipeline本身又跟channel关联在一起，所以handler和channel也就关联起来了。</span></p><p>&nbsp;</p><p><span>接下来，我们来说说pipeline如何添加其他业务handler，就像我们实现自己的pipeline 模式那样，也是由pipeline本身负责添加它所管理的handler，在DefaultChannelPipeline中有addLast方法，会将handler加入到它所管理的双向链表中tail的前一个位置。addLast有很多重载方法，我们关注比较重要的即可。源码如下：</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/65866100_1626673428.png" referrerpolicy="no-referrer" alt="img"></p><p>&nbsp;</p><p><span>这样就将业务handler添加到双向链表中，pipeline的结构就变成了：</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/89296200_1626673428.png" referrerpolicy="no-referrer" alt="img"></p><p>&nbsp;</p><p><span>如果继续向pipeline添加handler，就是在这个双向链表的基础上继续添加一个元素而已。现在我们已经有了具备任务处理能力的pipeline，接下来就要考虑这个pipeline的任务执行了，Netty的pipeline是像我们之前自己实现的pipeline那样，从头执行到尾吗？实际上这里还是有玄机的。pipeline中的handler实际上被分成了两类，分别是ChannelInBoundHandler和ChannelOutBoundHandler，这是两个接口，都实现了ChannelHandler接口，而pipeline中handler的执行，跟这个handler属于这两种handler的哪一种有关系。</span></p><p>&nbsp;</p><p><span>为什么handler会区分InBound和OutBound，这跟Pipeline事件的流向有关系，它关系到pipeline的事件的流向和分类，因此是十分关键的。从名字中我们可以看出是将事件分成了InBound和OutBound两类，我们把InBound和OutBound称之为入站和出站，pipeline在执行的时候，如果是入站事件，那么仅有入站类型的handler，也就是实现了ChannelInBoundHandler接口的handler会执行，如果是出站事件，那么就会仅有出站的handler会执行，也就是实现了ChannelOutBoundHandler接口的handler。</span></p><p>&nbsp;</p><p><span>虽然知道了handler区分为两类，但是我们还是没明白什么是入站事件，什么是出站事件，用官方文档的话解释就是，如果是接收数据或者关联的Channel的状态发生改变的事件，就是入站事件，也就是说此时是被动触发的，比如像连接建立事件、异常通知事件、读事件和读完成事件等等，都是在发生这些事件的时候会触发回调（These are called when data is received or when the state of the associated Channel changes）。</span></p><p>&nbsp;</p><p><span>出站事件或者说出站操作，是由我们主动触发的，比如要绑定端口、连接服务端、往外写数据等等，是我们自己主动发起的请求。出站操作的方法是被Channel、ChannelPipeline和ChannelHandlerContext调用的（Outbound operations and data are processed by ChannelOutboundHandler. Its methods are invoked by Channel, ChannelPipeline, and ChannelHandlerContext.）。</span></p><p>&nbsp;</p><p><span>更简单的理解，如果channel是被动的接收，那么就是InBound，这个事件是外部发起的，进入channel；如果channel是发起者，那么就是OutBound，是写出去的。</span></p><p>&nbsp;</p><p><span>画图来理解：</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/24321100_1626673429.png" referrerpolicy="no-referrer" alt="img"></p><p>&nbsp;</p><p><span>所以pipeline的执行就被分成了两条线，一个入站一个出站：</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/42499600_1626673429.png" referrerpolicy="no-referrer" alt="img"></p><p><span>入站操作的执行顺序是从head开始的，如源码所示：</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/65089000_1626673429.png" referrerpolicy="no-referrer" alt="img"></p><p>&nbsp;</p><p><span>在之后就会去寻找下一个InBound类型的handler继续执行，如何判断一个handler是InBound还是OutBound，其实是通过这个handler的类型来判断的，如果这个handler实现的是ChannelInBoundHandler，那么就属于InBound，如果实现的是ChannelOutBoundHandler，就属于OutBound，在创建Context上下文的时候，会传入这个handler的类型，context会判断这个属于哪种bound：</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/89204600_1626673429.png" referrerpolicy="no-referrer" alt="img"></p><p>&nbsp;</p><p><span>而出站操作的执行顺序与入站正好相反，是从tail开始，再接着往前去寻找下一个OutBound的handler。这里要注意的一点是，HeadContext既实现了ChannelOutBoundHandler，也实现了ChannelInBoundHandler，所以它既是InBound也是OutBound，它是InBound事件的入口（inBound事件从head开始），也是OutBound事件的出口（OutBound事件从tail开始）。来看它的源码：</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/19197000_1626673430.png" referrerpolicy="no-referrer" alt="img"></p><p>&nbsp;</p><p><span>以上就是对Netty中pipeline模式的一个大体介绍，可以看到，pipeline模式对于channel事件的处理发挥了巨大的作用，它的双向链表结构，inbound和outbound的区分也值得我们借鉴。</span></p><p>&nbsp;</p><h3><a name="52图文讲解深入剖析半同步-半异步模式的工作原理" class="md-header-anchor"></a><strong><span>52_图文讲解：深入剖析半同步-半异步模式的工作原理</span></strong></h3><h4><a name="1开篇词" class="md-header-anchor"></a><strong><span>1、开篇词</span></strong></h4><p><span>大家好，本篇文章将给大家带来半同步/半异步（half-sync/half-async）多线程设计模式的讲解</span></p><p>&nbsp;</p><h4><a name="2半同步半异步模式的应用场景一" class="md-header-anchor"></a><span>2、半同步/半异步模式的应用场景一</span></h4><p><span>废话不多说，大家先看一幅图，如图1：</span><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/89053300_1626673593.png" referrerpolicy="no-referrer" alt="img"></p><p><span>     图1</span></p><p><span>假设当一个用户如果要完成一次IO操作，要1秒多一点的时间，服务才能完成操作，并把结果返回给用户，可以说这个系统吞吐量是很不乐观的。</span></p><p><span>如果人非常多每次都要等一个IO操作彻底完成，才能开始处理下一个，这种用户体验将差到无以复加的地步,如图2：</span><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/15439500_1626673594.png" referrerpolicy="no-referrer" alt="img"><span>    图2</span></p><p><span>那么我们现在怎么办呢？很明显，大部分时间都是消耗在socket IO流的读写上，并且线程是一个很宝贵的系统资源，最好不要轻易占用，在不考虑修改IO读写方案和创建过多线程的前提下，有什么好办法么？</span></p><p><span>这个我们就要考虑用户对IO读写的时效性要求了，如果要求不高我们就可以采用如下方案，如图3：</span><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/44616400_1626673594.png" referrerpolicy="no-referrer" alt="img"></p><p><span>                                        图3</span></p><p><span>大家可以看到，如果我们做了图3那样的改造，在socket的放入内存队列的时间完全可以忽略不记的情况下，当系统取得客户端的socket对象之后，就可以直接给用户响应了，这个过程只需200ms即可,是非常短的一段时间了，然后由一个后台线程，不断的从队列取出socket对象，然后进行IO流的操作，也就是说在系统处理IO读写的时候用户这个时候可以去做点别的事情，没有必要在这傻傻的等待了，隔一段时间，通过轮询的方式看一看IO读写的处理结果就行了。如果失败了，可以重新发送请求，一般情况下消耗的时间，也不会占用太多。</span></p><p><span>这样做的好处就比较明显了，用户的请求的响应时间极大缩短，也就意味这可以更快的处理下一个请求了。</span></p><p><span>说到这里大家有没有对这种场景很熟悉呢？这不就是生产者/消费者模式吗！是的没错，生产者/消费者就是半同步/半异步的落地方式。生产者/消费者前调的是解耦性，但是单纯的解耦只能改善服务与服务之间的扩展性和维护性，但是不能改善服务之间的执行效率会相互影响的问题，所以要想在生产者/消费者的架构模式有一个良好的运转状态，我就必须解决这个问题，而要想解决这个问题，就得融入半同步/半异步的设计模式的思想了。</span></p><p><span>所以大家要明白一个健壮的一个模式架构，往往是融入了各种优良的设计思想，这样才能扬长避短，让这种模式架构得以落地。</span></p><p><span>生产者/消费者模式是我们后端开发人员最为常见的半同步/半异步的设计模式的落地方案了，那么大家可能就要问了，除了在生产者/消费者模式中得以运用，还有别的地方，经常运用吗？答案是有的，只不过那个就不属于后端开发范畴了，那属于GUI的开发领域，但是为了让大家对半同步/半异步的设计模式更为清晰的认知，我还是决定给大家讲一讲。</span></p><h4><a name="-n3353" class="md-header-anchor"></a><span> </span></h4><h4><a name="3半同步半异步模式的应用场景应用二" class="md-header-anchor"></a><span>3、半同步/半异步模式的应用场景应用二</span></h4><p><span>先给大家看一张图，如图4：</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/7277500_1626673595.gif" referrerpolicy="no-referrer" alt="img"></p><p><span>图4</span></p><p><span>上面是一个android下载管理器的界面，大家首先要知道一点就是在安卓开发里所有的你所能看到的界面ui变化都是由一个主线程去进行执行，这个主线程被称为UI Thread ，而界面上的控件因为用户的行为而触发的执行逻辑也都是在UI线程里执行，如图5：</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/32351100_1626673595.png" referrerpolicy="no-referrer" alt="img"></p><p><span>图5</span></p><p><span>像图5这样，因为用户点击了按钮触发了，文本框内容和字体颜色的设置，这些逻辑都是由ui Thread 负责执行，执行之后的效果如图6:</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/56188300_1626673595.png" referrerpolicy="no-referrer" alt="img"></p><p><span>图6</span></p><p><span>那么，我们现在开始要进行下载操作怎么办呢？你可能会想这不容易吗？我点击下载然后主线程，就替我执行下载操作不就行啦？但是很遗憾，这样做是不行的，我说过一切ui效果的交互都是由UI thread来进行完成的，那么此时，如果文件下载这种联网且耗时的事情，占用了UI线程，那么导致的结果就是界面卡死，点击任何控件将没有任何效果，也是基于这个原因在Android开发里默认就不允许在UI Thread里进行网络访问，否则直接报</span></p><p><span>NetworkOnMainThreadException异常，那么此时我们在android开发中，如何进行下载操作呢？如图7：</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/84342200_1626673595.png" referrerpolicy="no-referrer" alt="img"></p><p><span>图7</span></p><p><span>可以清楚的看到当用户点击下载按钮时，会创建一个用于下载的Task对象，把它放入线程池中，由线程中的线程去执行下载逻辑即可。那么现在大家猜一猜，如果我根据下载的实际进度，去更新显示的进度条进度，那该怎么办呢？由于在android开发里所有的控件都是非线程安全的，如果多线程执行，极容易发生UI错乱，所以android默认除主线程外的其他线程，都不能更新ui控件的显示状态，那么现在的问题也就是说怎么让ui线程和非ui线程之间通信了，这就要牵扯到android开发中的消息机制了，如图8：</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/17263400_1626673596.png" referrerpolicy="no-referrer" alt="img"></p><p><span>图8</span></p><p><span>从上图中我们可以看出，所谓的消息机制就是把下载进度包装成一个消息对象，放入到一个消息队列之中，然后通过主线程里一个Looper组件不断从队列里取出消息，交由一个Handler对象去处理，通过其handlerMessage方法，去处理消息，也就是通过消息的处理去提取消息里携带的参数，然后用那个参数去更新控件显示状态。</span></p><h4><a name="4总结" class="md-header-anchor"></a><span>4、总结</span></h4><p><span>好了，两种应用场景都介绍完了。我们可以对半同步/半异步模式在这两种场景中解决的问题做一个总结：</span></p><ul><li><span>通过半同步/半异步模式的方式在生产者/消费者模式中的运用，从而让两个线程的执行效率不受彼此的影响，同时也是保证系统对外的吞吐量，让一个线程直接收用户的请求，一个负责执行耗时的用户请求逻辑。</span></li><li><span>通过半同步/半异步模式的在GUI开发场景中的运用，保证耗时的网络交互操作的同时，不会影响到图形界面UI交互的流畅性。</span></li></ul><p><span>半同步/半异步模式的设计架构</span></p><p><span>通过对两种场景的讲解，我们不难发现运用通过半同步/半异步模式的场景，有一个共同点那就是，</span></p><p><span>都有一个线程将用户请求做一个小小的包装之后，将包装之后的对象放入一个线程队列之中。也就是说将用户请求异步化，之后总有一个线程不断的从队列里取出那些包装的对象，一个个执行用户的请求任务。好了共同点我们都知道了，我们就可以根据这共通的地方针对半同步/半异步模式提炼出一个抽象模型了：</span></p><p><span>AsyncTask:用于接收用户的请求，将这些请求要执行的逻辑放入队列之中，也就是将用户的请求异步化。</span></p><p><span>SyncTask:用于处理用户请求的执行逻辑。</span></p><p><span>Queue:对用户的请求进行缓冲，并保证用户请求的执行的顺序性</span></p><p><span>好了，对于半同步/半异步模式的所涉及到的一些角色抽取完毕，此时我就可以给出如图9中的类图了：</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/48050500_1626673596.png" referrerpolicy="no-referrer" alt="img"></p><p><span>        图9</span></p><p><span>稍微有点要主义的地方就是 dispatch()方法了，此方法负责将用户的请求的请求进行包装，别的类和方法，看名字就一目了然，就不多说了。</span></p><p>&nbsp;</p><h3><a name="53技术挑战如何解决广告计费预警系统中性能太差的问题" class="md-header-anchor"></a><strong><span>53_技术挑战：如何解决广告计费预警系统中性能太差的问题？</span></strong></h3><h4><a name="1开篇词-n3391" class="md-header-anchor"></a><strong><span>1、开篇词</span></strong></h4><p><span>从这一讲开始我们以广告投放系统作为案例背景，告诉大家如何将半同步/半异步的多线程设计模式思想贯彻其中，并将贯彻设计设计思想时产生的问题带着大家一一去解决。</span></p><h4><a name="2背景引入" class="md-header-anchor"></a><span>2、背景引入</span></h4><p><span>假如你现在是某一大型电商的一个商户，为了吸引更多的顾客，你必须不断投放广告，巴不得能占据该电商版面C位才好，所谓天下没有白吃的午餐，既然你要占据别人平台很重要的版面，人家要钱不寒掺。那么这个电商就有一个广告投放系统，并且你一定在这个系统充值一定的费用，那么当你广告投放成功之后，会进行金额的扣减，并且扣完之后，会以短信的形式通知你，用于广告投放的余额还剩下多少，大致的业务链路如图1：</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/90344000_1626674156.jpeg" referrerpolicy="no-referrer" alt="img"></p><p><span>图1</span></p><p><span>其中绿色方块代表涉及到的交互系统，橙色方块代表处理广告投放的业务节点</span></p><p>&nbsp;</p><h4><a name="3链路上的哪个点会存在性能问题" class="md-header-anchor"></a><span>3、链路上的哪个点会存在性能问题？</span></h4><p><span>从图中我们可以看出，即使我们投递投递成功之后，费用也正常扣除了，但是这还没完，我们还要等扣费成功后的短信发送成功，投递广告成功与否的状态才能返回给商户。大家是否有觉得不合理的地方，我们不妨一起来思考思考：</span></p><ol start='' ><li><span>首先我们来思考一下，所谓的性能问题，说白了就是看哪个地方的处理效率存在较大的隐患，那么毫无疑问就是发送商户广告投放余额短信了，因为他必须要和第三方短信运营商的系统有所交互。</span></li><li><span>好了，我们明确了发送短信，是我们投放广告链路上处理效率最慢的一环，那么我们来思考一下短信发送结果的对于商户的意义以及时效性要求：</span></li></ol><p><span>余额短信通知的对于商户的意义：诚然，用于投放广告的余额通知从流程规范上来说，是不可或缺的一部分，但是别忘了，用户投放广告系统的主旨是为了让商户投放广告，结果你一个扣费的短信通知，这个对核心业务处理产生不了什么影响，反而成了最为耗时的一环，这合适吗？</span></p><p><span>余额短信通知的时效信：说白了你既然以短信的方式通知，你的核心目的，也只是让商户知晓怎么一个情况，甚至说一句不好听的，你发短信通知用户这个只是出于一种礼貌行为，至于商户到底自己重视与否，或者说商户啥时能看到短信息，电商平台根本不关心这个。</span></p><h4><a name="4总结-n3408" class="md-header-anchor"></a><span>4、总结</span></h4><p><span>所以综上所述，投放广告的业务链路上，商户余额的短信通知，是最大的性能隐患，并且在处理链路上即不重要，时效性的要求还低，但是咱们能把短信通知这一环节剔除吗？这还是不能剔除的，这个通知多多少少，会给商户们一个提醒，对别人多一份关心总是一件好事情。所以接下来的几讲我们将针对这个问题，对系统链路进行优化</span></p><p>&nbsp;</p><h3><a name="54性能优化基于半同步-半异步模式优化广告计费预警系统" class="md-header-anchor"></a><strong><span>54_性能优化：基于半同步-半异步模式，优化广告计费预警系统</span></strong></h3><h4><a name="1开篇词-n3412" class="md-header-anchor"></a><span>1、开篇词</span></h4><p><span>上一篇给大家讲到，有一个投放广告的系统，但是却因为在投放广告的链路上由于要给用户发送投放广告之后的所剩余额，严重影响了系统的吞吐量，并且这个功能虽然不重要但也不能没有，那我们应该怎么办呢？</span></p><h4><a name="2正篇开始" class="md-header-anchor"></a><span>2、正篇开始</span></h4><p><span>首先大家想一想为啥一个小小的发短信环节会对整个系统造成如此之大的影响？想必大家都看过《三国演义》这部古典著作，大家应该对火烧赤壁的相关章节记忆犹新，曹操兵力数倍于孙刘联军，为啥会遭遇如此惨败呢？从小说的角度来看，就是庞统让曹操铁索连舟，遂让对方可以用火攻的方式进行袭击，并使得曹操几十万大军，在谈笑间，灰飞烟灭。</span></p><p><span>因为大家都紧紧相连在一起，相互受到影响所致，用程序员的话讲那就是因为高度耦合。现在广告系统，也是类似的情况，图1：</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/26935100_1626675111.jpeg" referrerpolicy="no-referrer" alt="img"></p><p><span>图1</span></p><p><span>那么由此可见解耦是多么重要，甚至可以说因为不解耦的问题，都有可能影响历史发展进程。</span></p><p><span>说到解耦，相信大家用半个屁股想想都应该知道要使用MQ来解决,但MQ都是解决进程与进程之间的耦合，那么我在同一个进程里想做到，各个逻辑之间的解耦，要怎么做呢？那就是将你要解耦的逻辑放到两个线程里执行。也就说现在每当我投放广告成功之后都要让另外一个线程去发送短信，而线程最好不要肆意开辟，那就必须把发短信的任务交给线程池去处理了，如图2</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/57794200_1626675111.jpeg" referrerpolicy="no-referrer" alt="img"></p><p><span>图2</span></p><h4><a name="3总结-n3423" class="md-header-anchor"></a><span>3、总结</span></h4><p><span>听到这大家就要问了，我们现在在讲半同步/半异步的解决方案，怎么讲了半天解决的问题是解耦啊，那不是生产者与消费者模式解决的问题吗？大家想想我在53讲说的啥？</span></p><p><span>生产者与消费者模式是半同步/半异步的落地方案，也就是说半同步/半异步设计模式，是对生产者与消费者模式的优化，它并不能直接拿来解决我们的开发中的问题，只是对别的设计模式的一种补充方式而已。所以在12种多线程设计模式中，它并不包含其中。</span></p><p>&nbsp;</p><h3><a name="55大开脑洞如果任务过多队列积压怎么处理" class="md-header-anchor"></a><strong><span>55_大开脑洞：如果任务过多，队列积压怎么处理？</span></strong></h3><p><strong><span>1、开篇词</span></strong></p><p><span>上一讲我们讲到我们利用半同步/半异步的多线程设计模式，使得用户投放广告时，可以在广告投放成功时，就可以立即返回了，解决了系统因为发送商家投放广告可用余额的短信对系统吞吐量造成的影响，但是问题仅仅是这样吗？</span></p><p>&nbsp;</p><h4><a name="2我快吃不下啦------内存队列满了应该怎么办" class="md-header-anchor"></a><span>2、”我快吃不下啦！！！“——内存队列满了应该怎么办</span></h4><p><span>老规矩，先来一幅图，如图1：</span><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/50900100_1626674465.jpeg" referrerpolicy="no-referrer" alt="img"></p><p><span>图1</span></p><p><span>大家可以看到，虽然现在发短信和广告投递，彼此之间的执行效率不受彼此影响，但是请大家注意，投放广告之后还要把请求放到内存队列里面去，而内存空间是很有限的，比方说有一个很热情的厨师，他强行的把自己做好的菜，往客人嘴里塞，然而作为一个普通人你的肠胃对食物的消化速度远远比不了人家做菜的速度，就这样，你肠胃里的食物，还没消化完，厨师还是不停的往你嘴里送。</span></p><p><span>不用多说这样下去你的肠胃一定会有问题，那么同理发短信的速度，远远比不上商户们投放广告速度，内存就像人的肠胃样，是会被撑爆的，那么如果现在我们没办法改变我们肠胃的消化能力，又不想被热情的厨师做的菜撑爆，那我们最好先客人跟厨师说明，它的饭量大概是多少，当厨师发现你快吃不下的时候人家厨师或许就放慢做菜速度，乃至停止继续做菜了。</span></p><p><span>内存队列也是一样，我们可以通过对发送短信系统的压测，评估出一个对数据处理的执行效率，从而制定内存队列的大小，投放广高系统，刚知道队列快满的时候可以选择，延缓将数据放入队列的速度甚至极端情况，就可以将数据丢弃，因为本来发短信也不是什么太重要的事情。</span></p><h4><a name="3问题要治本------发短信导致吞吐量降低的问题不能忽略" class="md-header-anchor"></a><span>3、问题要治本——发短信导致吞吐量降低的问题不能忽略！！</span></h4><p><span>内存被撑爆的问题，算是解决了，但是不是有一种治标不治本呢？因为最根本的问题是还是发送短信的环节导致的？我们所谓的调整内存队列大小，换句话说就是因为发送短信的效率低下最终还是影响了系统的吞吐量，是不是很不爽呢？那么你可能会问了，创建多个线程，多部署几台与短信运营商交互的机器不就行了吗？如图2：</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/77919600_1626674465.jpeg" referrerpolicy="no-referrer" alt="img"></p><p><span>图2</span></p><p><span>是的，没错，这样三个线程消费队列中的请求的的确确是加强了消费速度，但是还是有令人不舒服的地方：</span></p><ol start='' ><li><span>线程是宝贵的系统资源，确实不想为发短信这样的事情开辟更多资源</span></li><li><span>单个线程的利用率还是很低，只要进行了短信发送就意味着这个线程将被长时间阻塞，还是没能解决消费过慢的根本原因。</span></li></ol><p><span>以一个购物狂的生活状态为背景，思考如何解决队列数据消费过慢的问题</span></p><p><span>假如有怎么一个购物狂，人生最大的快乐就是网购，拆包裹，由于对购物的热情已达到一种病态的程度，以至于当他买了一将商品之后，就日日夜夜的在快递存放点蹲守等着收自己的快递，直到拿到了才罢休。</span></p><p><span>我们把这种取快递的方式如果比作是IO操作的一种方式，那就是阻塞IO了，也就是说我只要调用了read方法我必须读取到所要的信息才行，否则我就一直在这里阻塞着。这也是发短信系统中的线程所采取的IO读写方式。</span></p><p><span>过了几天，购物狂也明白了，毕竟他还要买买买啊，老在这花大把的时间干等，也不是一个事儿，所以他现在稍微理性了些，不管在快递存放点取没取到包裹，就会回去了，但是别忘了拆包裹对他来说也是很重要的一部分。</span></p><p><span>所以他来往快递存放点的频率非常高，快递还没有送达，他就来快递存放点好几个来回，这也就表示他空手而归成了将常便饭，你想每天都要去一个地方好几回，而且也都是做的无用功，但这个过程对购物狂的时间消耗是实实在在的。</span></p><p><span>像上面这种情况就可以被看做是非阻塞IO的处理方式，当你发起IO请求的时候，当服务器接收到请求，调用方如果发现有数据可读就读取完数据在返回，没数据就立即返回并且无奈的继续消费下一个请求了，之后找机会再去查看发送状态了。如图3：</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/18262600_1626674466.jpeg" referrerpolicy="no-referrer" alt="img"></p><p><span>图3</span></p><p><span>好了，我们现在来看看采用非阻塞IO的去点有哪些？</span></p><ol start='' ><li><span>现在虽然拿快递和购物之间取得了一个平衡，不像之前那样为了取快递，而不能购物，但是取快递很大概率是做的无用功，性能还是比较差。</span></li><li><span>如果一个小区有多个快递存放点，那么购物狂就要每个点都要去找一下，到头来很可能是一无所获，那么你就做了多分无用功了。</span></li></ol><p><span>那么假设现在购物狂的小区增设了快递存放点，购物狂实在是受不了做无用功的日子，所以他留下各个物流的快递员的联系电话，那么当他购买一件商品之后，是否可以取件，必须接到快递员的电话才行他从去站点取件。</span></p><p><span>这样的好处就是，购物狂虽然看到来电还不知道快递被放在什么地方，但是电话来了说明一定会在某一个收快递的站点拿到快递了，还有像购物狂这种不理性消费的人，往往就是月光族，没啥积蓄，很难保证天天都有较高消费，那么很可能全身心地坐等取件，如果收快递的时间等的太久，他可能自己就控制不住购买欲，也不管之前买的东西是否已签收，就继续买新的商品了。如上所述的此场景大致如图4所示：</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/47146800_1626674466.jpeg" referrerpolicy="no-referrer" alt="img"></p><p><span>图4</span></p><p><span>大家可以看到图4中一直准备着收取快递，但没有接听到快递员发来的消息，一直没去快递站点去找自己的包裹，自己等了太久，决定不等了就去购物了，那么把购物狂比作一个线程，也就是说虽然这个线程发生了阻塞，但是他阻塞是有时限的，当时间比较长的时候，它就不再阻塞，接着购物了，那么如果此时收到了快递员来电的话，场景大致如图5：</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/71810300_1626674466.jpeg" referrerpolicy="no-referrer" alt="img"></p><p><span>图5</span></p><p><span>大家可以看到，只要快递员来电了，那么购物狂100%能收到一份包裹，只不过上面这位快递小哥不怎么靠谱，没有明确告诉购物狂，还得他两个站点都要看一下，如果像下面这种情况就舒服很多了，如图6：</span><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/95736000_1626674466.jpeg" referrerpolicy="no-referrer" alt="img"></p><p><span>图6</span></p><p><span>你看这个快递小哥就挺靠谱，告诉购物狂快件放在哪里，购物狂一下就找到了。</span></p><p><span>现在就比较舒服了，如果把这种取件形式也看作是IO读写的一种方式，是不是完全规避了之前的IO操作形式的所有关键性问题吗？我们现在就来看看吧：</span></p><ol start='' ><li><span>为了获取数据可能依然会阻塞一会儿，但是这个时间完全是可控的，当购物狂由于长时间没有获取到信息，他放弃在傻傻的等待，可以买东西，购买完成之后再回来等待一下有没有收到快递小哥的来电，就像这样不断地循环往复，不像从前如果获取不到数据就一直阻塞着啥也干不了。</span></li><li><span>只要一收到快递小哥的消息，就意味着100%可以获取到自己要的东西，虽然可能由于小区里有多个站点加上有些快递小哥不是很靠谱，没能确切告诉你，快件存放在哪个站点里，但是你把所有的站点都跑一下绝对不会空手而回。</span></li><li><span>现在就来讲这套IO处理方式最厉害的地方，你们发现没有，如果服务站点我们看作是服务器的话，购物狂现在只要能听到消息，有可能就一次性的在多个站点那里获取到数据了，因为有可能多个站点同时都有你的包裹，只要碰上一个稍微靠谱点的快递小哥告诉你哪个地方有快件，我就有针对性的去取数据了，每一个站点都不会让我空手而归。不像从前去一个站点取快递的话，可能有时候只能靠没日没夜的蹲守才能在一个站点获取到你的快递，那么在多站点的情况下，有可能出现由于你在一个站点蹲守，然而这时其他站点已经有你的包裹了，致使你无法获得它，那在以前我们面对这样的情况应该怎么办呢？那就只好叫上你的亲朋好友们蹲守在各个站点才行，从程序的角度来说，解决这样的问题，就得创建多线程，就像图2中那样，也就是说如果说在这样的IO处理方式下，一个线程就能进听到来自各个服务器的数据，挨个去读取就行了。</span></li></ol><p><span>这套IO模型是不是很强大，没错这套IO处理方式是非常强大的，也就是大名鼎鼎的多路复用的IO模型了，唯一的缺点就是编码实现比较复杂，所以才有了像Netty这样的Nio框架的出现。</span></p><h4><a name="4多路复用io模型的核心组件简介" class="md-header-anchor"></a><span>4、多路复用IO模型的核心组件简介</span></h4><p><span>好了，相信大家已经对多路复用的IO模型已经有一个初步的认识了，那么我们现在把购物狂生活中一起构建出IO多路复用场景中的角色抽象成代码模型大概是什么样的。</span></p><p><span>首先我们不妨来看看，这个在没有收到快递员信息的情况向下，让购物狂先静静的等待一会儿，如果收到快递小哥来电就可以在小区里的站点展开快递搜索的行为叫做select，也就是说select是一个阻塞方法，既然它是一个IO多路复用里的通用行为，那么自然就跟我们业务代码无关，肯定是有一个在这套模型里有拥有这个方法的接口或类。</span></p><p><span>从本文里我们知道，select定位的是有数据的站点，那么我们所能搜索的站点范围是有谁圈定的？，那毫无疑问这个角色，就是我们的小区，也就是说通过小区这个对象的select方法给我们返回所有有数据的站点信息。那么这个小区这个对象在多路复用IO模型的架构下，扮演的角色被称为Selector,这个角色通过select方法帮我们实现站点有无数据监测，那么剩下的对象的作用就一目了然了，站点是我们获取数据的地方，在模型里被称为Channel</span></p><p><span>那我们从Channel里获取的数据，不对，应该是包裹，包裹里面才是我们的数据，那么包裹叫什么呢？叫Buffer,也就是缓冲区，也就是说我们要想在Channel中获取数据必须把数据写入缓冲区才行。那么那个可能靠谱或者可能不靠谱，影响着我们是否能精确定位的角色是谁呢？那个自然就是我们的操作系统了,这也正好契合了，你想以怎么样的形式去定位Channel是否有数据，我们没办法自己决定的 只能任由自己所处的环境摆布。那如果在windows下很不幸，你只能面对不靠谱的快递小哥了，如果在linux上运行，恭喜你，你遇到的都是靠谱的快递小哥。</span></p><p><span>靠谱的快递小哥在多路复用IO模型下让用户使用select方法轮询方式称为epoll,不靠谱的快递小哥，不靠谱的快递小哥在多路复用IO模型下让用户使用select方法轮询方式称为select与java Selector对象的select方法名称相同，希望大家不要把两者搞混了。</span></p><p><span>好了核心组件都抽离出来了，让我们把这些角色带入我们画的图里，如图7：</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/18515200_1626674467.jpeg" referrerpolicy="no-referrer" alt="img"></p><p><span>图7</span></p><p><span>那么我们现在用多路复用的IO模型改造我们的广告投放系统，效果大致如图8：</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/45216800_1626674467.jpeg" referrerpolicy="no-referrer" alt="img"></p><p><span>图8</span></p><p><span>基于多路复用的伪代码大致如下：</span></p><pre spellcheck="false" class="md-fences md-end-block ty-contain-cm modeLoaded" lang="java" style="break-inside: unset;"><div class="CodeMirror cm-s-inner CodeMirror-wrap" lang="java"><div style="overflow: hidden; position: relative; width: 3px; height: 0px; top: 0px; left: 8px;"><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0" style="position: absolute; bottom: -1em; padding: 0px; width: 1000px; height: 1em; outline: none;"></textarea></div><div class="CodeMirror-scrollbar-filler" cm-not-content="true"></div><div class="CodeMirror-gutter-filler" cm-not-content="true"></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer" style="margin-left: 0px; margin-bottom: 0px; border-right-width: 0px; padding-right: 0px; padding-bottom: 0px;"><div style="position: relative; top: 0px;"><div class="CodeMirror-lines" role="presentation"><div role="presentation" style="position: relative; outline: none;"><div class="CodeMirror-measure"><span><span>​</span>x</span></div><div class="CodeMirror-measure"></div><div style="position: relative; z-index: 1;"></div><div class="CodeMirror-code" role="presentation" style=""><div class="CodeMirror-activeline" style="position: relative;"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter" style="left: 0px; width: 0px;"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-variable">Selector</span> <span class="cm-variable">selector</span> <span class="cm-operator">=</span> <span class="cm-variable">Selector</span>.<span class="cm-variable">open</span>();</span></pre></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span cm-text="">​</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; <span class="cm-variable">Map</span><span class="cm-operator">&lt;</span><span class="cm-variable-3">String</span>,<span class="cm-variable">SelectionKey</span><span class="cm-operator">&gt;</span> <span class="cm-variable">keyMap</span> &nbsp;<span class="cm-operator">=</span> <span class="cm-keyword">new</span> <span class="cm-variable">ConcurrentHashMap</span><span class="cm-operator">&lt;&gt;</span>();</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span cm-text="">​</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; <span class="cm-variable">ConcurrentLinkedQueue</span><span class="cm-operator">&lt;</span><span class="cm-variable-3">String</span><span class="cm-operator">&gt;</span> <span class="cm-variable">requestQueue</span> <span class="cm-operator">=</span> <span class="cm-keyword">new</span> <span class="cm-variable">ConcurrentLinkedQueue</span><span class="cm-operator">&lt;</span><span class="cm-variable-3">String</span><span class="cm-operator">&gt;</span>() ;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span cm-text="">​</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; <span class="cm-keyword">while</span> (<span class="cm-atom">true</span>){</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span cm-text="">​</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="cm-comment">// select方法阻塞1秒钟</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span cm-text="">​</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="cm-variable-3">int</span> <span class="cm-variable">count</span> <span class="cm-operator">=</span> <span class="cm-variable">selector</span>.<span class="cm-variable">select</span>(<span class="cm-number">1000</span>);</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span cm-text="">​</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="cm-keyword">if</span>(<span class="cm-variable">count</span> <span class="cm-operator">&gt;</span> <span class="cm-number">0</span> ){</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span cm-text="">​</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="cm-variable">Set</span><span class="cm-operator">&lt;</span><span class="cm-variable">SelectionKey</span><span class="cm-operator">&gt;</span> <span class="cm-variable">selectionKeys</span> <span class="cm-operator">=</span> <span class="cm-variable">selector</span>.<span class="cm-variable">selectedKeys</span>();</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span cm-text="">​</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="cm-variable">Iterator</span><span class="cm-operator">&lt;</span><span class="cm-variable">SelectionKey</span><span class="cm-operator">&gt;</span> <span class="cm-variable">iterator</span> <span class="cm-operator">=</span> <span class="cm-variable">selectionKeys</span>.<span class="cm-variable">iterator</span>();</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span cm-text="">​</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="cm-keyword">while</span> (<span class="cm-variable">iterator</span>.<span class="cm-variable">hasNext</span>()){</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span cm-text="">​</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="cm-variable">SelectionKey</span> <span class="cm-variable">key</span> <span class="cm-operator">=</span> <span class="cm-variable">iterator</span>.<span class="cm-variable">next</span>();</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span cm-text="">​</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="cm-variable">iterator</span>.<span class="cm-variable">remove</span>();</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span cm-text="">​</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="cm-comment">// 如果发来的请求是可读请求，证明是接入层发来的响应</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span cm-text="">​</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="cm-keyword">if</span>(<span class="cm-variable">key</span>.<span class="cm-variable">isReadable</span>()){</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span cm-text="">​</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="cm-comment">// 获取与第三方短信运营商接入系统的通信管道</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span cm-text="">​</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span class="cm-variable">SocketChannel</span> <span class="cm-variable">channel</span> <span class="cm-operator">=</span> (<span class="cm-variable">SocketChannel</span>) <span class="cm-variable">key</span>.<span class="cm-variable">channel</span>();</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span cm-text="">​</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="cm-comment">//  接入层订阅可读请求</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span cm-text="">​</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span class="cm-variable">key</span>.<span class="cm-variable">interestOps</span>(<span class="cm-variable">SelectionKey</span>.<span class="cm-variable">OP_READ</span>) ;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span cm-text="">​</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="cm-comment">//  向接入层的管道写数据，也就是向接入层发起可写请求</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span cm-text="">​</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span class="cm-variable">channel</span>.<span class="cm-variable">write</span>(<span class="cm-variable">ByteBuffer</span>.<span class="cm-variable">wrap</span>(<span class="cm-variable">requestQueue</span>.<span class="cm-variable">poll</span>().<span class="cm-variable">getBytes</span>())) ;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span cm-text="">​</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span cm-text="">​</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span cm-text="">​</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span cm-text="">​</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="cm-comment">// 1秒内没有收到接入层的响应，继续消费队列里的数据</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span cm-text="">​</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="cm-keyword">else</span> {</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span cm-text="">​</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="cm-variable">SelectionKey</span> <span class="cm-variable">key</span> <span class="cm-operator">=</span> <span class="cm-variable">keyMap</span>.<span class="cm-variable">get</span>(<span class="cm-string">"shishan"</span>);</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span cm-text="">​</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="cm-variable">SocketChannel</span> <span class="cm-variable">channel</span> <span class="cm-operator">=</span> (<span class="cm-variable">SocketChannel</span>) <span class="cm-variable">key</span>.<span class="cm-variable">channel</span>();</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span cm-text="">​</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="cm-variable">key</span>.<span class="cm-variable">interestOps</span>(<span class="cm-variable">SelectionKey</span>.<span class="cm-variable">OP_READ</span>) ;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span cm-text="">​</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="cm-variable">channel</span>.<span class="cm-variable">write</span>(<span class="cm-variable">ByteBuffer</span>.<span class="cm-variable">wrap</span>(<span class="cm-variable">requestQueue</span>.<span class="cm-variable">poll</span>().<span class="cm-variable">getBytes</span>())) ;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span cm-text="">​</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span cm-text="">​</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; }</span></pre></div></div></div></div></div><div style="position: absolute; height: 0px; width: 1px; border-bottom: 0px solid transparent; top: 1403px;"></div><div class="CodeMirror-gutters" style="display: none; height: 1403px;"></div></div></div></pre><p>&nbsp;</p><h3><a name="56动手演练编写可复用半同步-半异步模式的代码" class="md-header-anchor"></a><strong><span>56_动手演练：编写可复用半同步-半异步模式的代码</span></strong></h3><p><strong><span>1、开篇词</span></strong></p><p><span>想必大家通过这几天的学习，已经对半同步/半异步模式运用已经是信手拈来了。大家是不是觉得这种设计模式无论运用于那种场景下，都可以简化成四个步骤，如图1：</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/81985900_1626675497.jpeg" referrerpolicy="no-referrer" alt="img"></p><p><span>图1</span></p><p><span>好了为了让大家感受的更直观些，请大家看图2和图3</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/7190200_1626675498.jpeg" referrerpolicy="no-referrer" alt="img"></p><p><span>图2</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/34077600_1626675498.jpeg" referrerpolicy="no-referrer" alt="img"></p><p><span>图3</span></p><p><span>好了大家明白这一点，我就可以开始讲解我们的内容了</span></p><h4><a name="-n3506" class="md-header-anchor"></a><span> </span></h4><h4><a name="2正片开始" class="md-header-anchor"></a><span>2、正片开始</span></h4><p><span>首先我们上面抽出的4个通用步骤，可以简单概括为，如图4所示：</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/37783400_1626675499.jpeg" referrerpolicy="no-referrer" alt="img"></p><p><span>图4</span></p><p><span>也就是说白了，实际上我们传递给服务端的无论参数是什么，逻辑是什么 说到底它就是一个异步任务，那么异步化，大家首先想到继承Runnable不就行了吗？是的没错，但大家有没有发现从入队列开始到执行我们业务逻辑这里，整个流程是不是很熟悉，好像已经有现成的东西给我们提供了实现这些步骤的类？</span></p><p><span>毫无疑问就是线程池了，但是我们在整个将请求异步化的过程中，将任务提交给线程池之前，有可能有我们自己的一些特殊的逻辑，那么当我们还需要相同的异步执行很多次时，每次都要把相近的代码重写一遍，是不是非常的繁琐？，为了让一些异步逻辑可以很方便的被重复调用，我们把它们有必要封装成一个个的task对象，而这些异步任务执行的整体流程都是相同的，只是根据自己的业务场景来决定此步骤的处理方式是啥样的，那么也就是说我们需要一个含有线程池的抽象类，如图5：</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/61603000_1626675499.png" referrerpolicy="no-referrer" alt="img"><span> 图5</span></p><p><span>然后，最关键的就是让线程池执行每个任务具体逻辑的调用入口，如图6：</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/2792200_1626675500.png" referrerpolicy="no-referrer" alt="img"></p><p><span>图6</span></p><p><span>最后是一个根据自己的情况，选择是否要将任务提交给线程池之前执行一段逻辑的一个方法，如图7：</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/53457400_1626675500.png" referrerpolicy="no-referrer" alt="img"></p><p><span>图7</span></p><p><span>好了，我们已经梳理除了提供给用户自己实现的方法入口都有了，其他的任务都交给线程池来做就ok了。现在其实还有一个关键的方法,也就是暴露给用户的方法有哪些，如图8:</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/99477300_1626675500.png" referrerpolicy="no-referrer" alt="img"></p><p><span>图8</span></p><p><span>注意红色边线框出的地方,其实暴露给客户端一个dispatch（）方法就行了，为了规范起见，需要为这个抽象类一个接口，里面只包含暴露给客户端的方法，如图9：</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/27768400_1626675501.png" referrerpolicy="no-referrer" alt="img"></p><p><span>图9</span></p><p><span>那触发整个流程的dispatch（）方法实现如图10所示：</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/60196200_1626675501.png" referrerpolicy="no-referrer" alt="img"></p><p><span>图10</span></p><p><span>最后在向大家展示一下现在整体的UML类图,如图11：</span></p><p><img src="http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/88624200_1626675501.png" referrerpolicy="no-referrer" alt="img"></p><p>&nbsp;</p><h3><a name="57结业典礼你可以通过实战本课程收获哪些能力" class="md-header-anchor"></a><strong><span>57_结业典礼：你可以通过实战本课程收获哪些能力？</span></strong></h3><p><span>不知不觉我们课程已经接近了尾声，最后我们将所有讲解知识点做一个总结：</span></p><ol start='' ><li><span>Immutable Object：不可变对象模式：在不引入锁的条件下，能保证访问共享变量时是线程安全的，缺点是会频繁的创建变量。</span></li><li><span>Guarded Suspension：保护性暂挂模式：将线程间的等待与唤醒规范化</span></li><li><span>week3 Two-phase Termination：两阶段终止模式：优雅的终止run方法的执行，让其有做一些收尾工作的可能</span></li><li><span>Promise：承诺模式：能够优雅的让当前线程，获取到另一个线程的执行结果</span></li><li><span>生产者/消费者模式：让输入逻辑和输出逻辑解耦，让两端易于维护</span></li><li><span>Active Object：主动对象模式：为了保证系统的吞吐量，让其真正的执行请求异步化，请求将成为一个任务对象，放入缓冲区，让其他线程来处理。</span></li><li><span>Thread Pool：线程池模式:避免线程资源的频繁创建与销毁导致的性能损耗，同时也是对线程的开辟数量进行管控。</span></li><li><span>Thread Specific Storage：线程特有存储模式：让每个线程都拥有一份相同全局变量的副本，避免了线程安全问题，只不过可能导致内存泄漏。</span></li><li><span>Serial Thread Confinement：串行线程封闭模式：将并发任务串行化，交由统一的线程去处理，保证线程安全</span></li><li><span>Master-Slave：主仆模式：将一个任务切分成多个子任务，并且由一个主任务对其他子任务负责管控，分而治之确保执行效率。</span></li><li><span>Pipeline：流水线模式：让有依赖关系的子任务，进行任务编排，能够顺利的并行执行。</span></li><li><span>半同步/半异步模式：将原有任务按执行效率高低，进行子任务的拆分，从而保证系统的整体的执行效率。</span></li></ol><p><span>通过以上的总结，多线程设计模式，不难看出它真正要解决的问题，核心就两个：确保任务的执行效率与确保数据的线程安全。同时相信大家也不难看出，一种设计模式想要真正落地，很大程度上必须同时杂糅多种其他设计模式的思想。</span></p></div>
</body>
</html>